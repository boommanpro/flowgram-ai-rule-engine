{"version":3,"file":"2276.js","sources":["webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/platform/contextkey/common/scanner.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/platform/log/common/log.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isChrome, isEdge, isFirefox, isLinux, isMacintosh, isSafari, isWeb, isWindows } from '../../../base/common/platform.js';\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\nimport { Scanner } from './scanner.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { localize } from '../../../nls.js';\nconst CONSTANT_VALUES = new Map();\nCONSTANT_VALUES.set('false', false);\nCONSTANT_VALUES.set('true', true);\nCONSTANT_VALUES.set('isMac', isMacintosh);\nCONSTANT_VALUES.set('isLinux', isLinux);\nCONSTANT_VALUES.set('isWindows', isWindows);\nCONSTANT_VALUES.set('isWeb', isWeb);\nCONSTANT_VALUES.set('isMacNative', isMacintosh && !isWeb);\nCONSTANT_VALUES.set('isEdge', isEdge);\nCONSTANT_VALUES.set('isFirefox', isFirefox);\nCONSTANT_VALUES.set('isChrome', isChrome);\nCONSTANT_VALUES.set('isSafari', isSafari);\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst defaultConfig = {\n    regexParsingWithErrorRecovery: true\n};\nconst errorEmptyString = localize('contextkey.parser.error.emptyString', \"Empty context key expression\");\nconst hintEmptyString = localize('contextkey.parser.error.emptyString.hint', \"Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively.\");\nconst errorNoInAfterNot = localize('contextkey.parser.error.noInAfterNot', \"'in' after 'not'.\");\nconst errorClosingParenthesis = localize('contextkey.parser.error.closingParenthesis', \"closing parenthesis ')'\");\nconst errorUnexpectedToken = localize('contextkey.parser.error.unexpectedToken', \"Unexpected token\");\nconst hintUnexpectedToken = localize('contextkey.parser.error.unexpectedToken.hint', \"Did you forget to put && or || before the token?\");\nconst errorUnexpectedEOF = localize('contextkey.parser.error.unexpectedEOF', \"Unexpected end of expression\");\nconst hintUnexpectedEOF = localize('contextkey.parser.error.unexpectedEOF.hint', \"Did you forget to put a context key?\");\n/**\n * A parser for context key expressions.\n *\n * Example:\n * ```ts\n * const parser = new Parser();\n * const expr = parser.parse('foo == \"bar\" && baz == true');\n *\n * if (expr === undefined) {\n * \t// there were lexing or parsing errors\n * \t// process lexing errors with `parser.lexingErrors`\n *  // process parsing errors with `parser.parsingErrors`\n * } else {\n * \t// expr is a valid expression\n * }\n * ```\n */\nexport class Parser {\n    // Note: this doesn't produce an exact syntax tree but a normalized one\n    // ContextKeyExpression's that we use as AST nodes do not expose constructors that do not normalize\n    static { this._parseError = new Error(); }\n    constructor(_config = defaultConfig) {\n        this._config = _config;\n        // lifetime note: `_scanner` lives as long as the parser does, i.e., is not reset between calls to `parse`\n        this._scanner = new Scanner();\n        // lifetime note: `_tokens`, `_current`, and `_parsingErrors` must be reset between calls to `parse`\n        this._tokens = [];\n        this._current = 0; // invariant: 0 <= this._current < this._tokens.length ; any incrementation of this value must first call `_isAtEnd`\n        this._parsingErrors = [];\n        this._flagsGYRe = /g|y/g;\n    }\n    /**\n     * Parse a context key expression.\n     *\n     * @param input the expression to parse\n     * @returns the parsed expression or `undefined` if there's an error - call `lexingErrors` and `parsingErrors` to see the errors\n     */\n    parse(input) {\n        if (input === '') {\n            this._parsingErrors.push({ message: errorEmptyString, offset: 0, lexeme: '', additionalInfo: hintEmptyString });\n            return undefined;\n        }\n        this._tokens = this._scanner.reset(input).scan();\n        // @ulugbekna: we do not stop parsing if there are lexing errors to be able to reconstruct regexes with unescaped slashes; TODO@ulugbekna: make this respect config option for recovery\n        this._current = 0;\n        this._parsingErrors = [];\n        try {\n            const expr = this._expr();\n            if (!this._isAtEnd()) {\n                const peek = this._peek();\n                const additionalInfo = peek.type === 17 /* TokenType.Str */ ? hintUnexpectedToken : undefined;\n                this._parsingErrors.push({ message: errorUnexpectedToken, offset: peek.offset, lexeme: Scanner.getLexeme(peek), additionalInfo });\n                throw Parser._parseError;\n            }\n            return expr;\n        }\n        catch (e) {\n            if (!(e === Parser._parseError)) {\n                throw e;\n            }\n            return undefined;\n        }\n    }\n    _expr() {\n        return this._or();\n    }\n    _or() {\n        const expr = [this._and()];\n        while (this._matchOne(16 /* TokenType.Or */)) {\n            const right = this._and();\n            expr.push(right);\n        }\n        return expr.length === 1 ? expr[0] : ContextKeyExpr.or(...expr);\n    }\n    _and() {\n        const expr = [this._term()];\n        while (this._matchOne(15 /* TokenType.And */)) {\n            const right = this._term();\n            expr.push(right);\n        }\n        return expr.length === 1 ? expr[0] : ContextKeyExpr.and(...expr);\n    }\n    _term() {\n        if (this._matchOne(2 /* TokenType.Neg */)) {\n            const peek = this._peek();\n            switch (peek.type) {\n                case 11 /* TokenType.True */:\n                    this._advance();\n                    return ContextKeyFalseExpr.INSTANCE;\n                case 12 /* TokenType.False */:\n                    this._advance();\n                    return ContextKeyTrueExpr.INSTANCE;\n                case 0 /* TokenType.LParen */: {\n                    this._advance();\n                    const expr = this._expr();\n                    this._consume(1 /* TokenType.RParen */, errorClosingParenthesis);\n                    return expr?.negate();\n                }\n                case 17 /* TokenType.Str */:\n                    this._advance();\n                    return ContextKeyNotExpr.create(peek.lexeme);\n                default:\n                    throw this._errExpectedButGot(`KEY | true | false | '(' expression ')'`, peek);\n            }\n        }\n        return this._primary();\n    }\n    _primary() {\n        const peek = this._peek();\n        switch (peek.type) {\n            case 11 /* TokenType.True */:\n                this._advance();\n                return ContextKeyExpr.true();\n            case 12 /* TokenType.False */:\n                this._advance();\n                return ContextKeyExpr.false();\n            case 0 /* TokenType.LParen */: {\n                this._advance();\n                const expr = this._expr();\n                this._consume(1 /* TokenType.RParen */, errorClosingParenthesis);\n                return expr;\n            }\n            case 17 /* TokenType.Str */: {\n                // KEY\n                const key = peek.lexeme;\n                this._advance();\n                // =~ regex\n                if (this._matchOne(9 /* TokenType.RegexOp */)) {\n                    // @ulugbekna: we need to reconstruct the regex from the tokens because some extensions use unescaped slashes in regexes\n                    const expr = this._peek();\n                    if (!this._config.regexParsingWithErrorRecovery) {\n                        this._advance();\n                        if (expr.type !== 10 /* TokenType.RegexStr */) {\n                            throw this._errExpectedButGot(`REGEX`, expr);\n                        }\n                        const regexLexeme = expr.lexeme;\n                        const closingSlashIndex = regexLexeme.lastIndexOf('/');\n                        const flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n                        let regexp;\n                        try {\n                            regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);\n                        }\n                        catch (e) {\n                            throw this._errExpectedButGot(`REGEX`, expr);\n                        }\n                        return ContextKeyRegexExpr.create(key, regexp);\n                    }\n                    switch (expr.type) {\n                        case 10 /* TokenType.RegexStr */:\n                        case 19 /* TokenType.Error */: { // also handle an ErrorToken in case of smth such as /(/file)/\n                            const lexemeReconstruction = [expr.lexeme]; // /REGEX/ or /REGEX/FLAGS\n                            this._advance();\n                            let followingToken = this._peek();\n                            let parenBalance = 0;\n                            for (let i = 0; i < expr.lexeme.length; i++) {\n                                if (expr.lexeme.charCodeAt(i) === 40 /* CharCode.OpenParen */) {\n                                    parenBalance++;\n                                }\n                                else if (expr.lexeme.charCodeAt(i) === 41 /* CharCode.CloseParen */) {\n                                    parenBalance--;\n                                }\n                            }\n                            while (!this._isAtEnd() && followingToken.type !== 15 /* TokenType.And */ && followingToken.type !== 16 /* TokenType.Or */) {\n                                switch (followingToken.type) {\n                                    case 0 /* TokenType.LParen */:\n                                        parenBalance++;\n                                        break;\n                                    case 1 /* TokenType.RParen */:\n                                        parenBalance--;\n                                        break;\n                                    case 10 /* TokenType.RegexStr */:\n                                    case 18 /* TokenType.QuotedStr */:\n                                        for (let i = 0; i < followingToken.lexeme.length; i++) {\n                                            if (followingToken.lexeme.charCodeAt(i) === 40 /* CharCode.OpenParen */) {\n                                                parenBalance++;\n                                            }\n                                            else if (expr.lexeme.charCodeAt(i) === 41 /* CharCode.CloseParen */) {\n                                                parenBalance--;\n                                            }\n                                        }\n                                }\n                                if (parenBalance < 0) {\n                                    break;\n                                }\n                                lexemeReconstruction.push(Scanner.getLexeme(followingToken));\n                                this._advance();\n                                followingToken = this._peek();\n                            }\n                            const regexLexeme = lexemeReconstruction.join('');\n                            const closingSlashIndex = regexLexeme.lastIndexOf('/');\n                            const flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n                            let regexp;\n                            try {\n                                regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);\n                            }\n                            catch (e) {\n                                throw this._errExpectedButGot(`REGEX`, expr);\n                            }\n                            return ContextKeyExpr.regex(key, regexp);\n                        }\n                        case 18 /* TokenType.QuotedStr */: {\n                            const serializedValue = expr.lexeme;\n                            this._advance();\n                            // replicate old regex parsing behavior\n                            let regex = null;\n                            if (!isFalsyOrWhitespace(serializedValue)) {\n                                const start = serializedValue.indexOf('/');\n                                const end = serializedValue.lastIndexOf('/');\n                                if (start !== end && start >= 0) {\n                                    const value = serializedValue.slice(start + 1, end);\n                                    const caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n                                    try {\n                                        regex = new RegExp(value, caseIgnoreFlag);\n                                    }\n                                    catch (_e) {\n                                        throw this._errExpectedButGot(`REGEX`, expr);\n                                    }\n                                }\n                            }\n                            if (regex === null) {\n                                throw this._errExpectedButGot('REGEX', expr);\n                            }\n                            return ContextKeyRegexExpr.create(key, regex);\n                        }\n                        default:\n                            throw this._errExpectedButGot('REGEX', this._peek());\n                    }\n                }\n                // [ 'not' 'in' value ]\n                if (this._matchOne(14 /* TokenType.Not */)) {\n                    this._consume(13 /* TokenType.In */, errorNoInAfterNot);\n                    const right = this._value();\n                    return ContextKeyExpr.notIn(key, right);\n                }\n                // [ ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in') value ]\n                const maybeOp = this._peek().type;\n                switch (maybeOp) {\n                    case 3 /* TokenType.Eq */: {\n                        this._advance();\n                        const right = this._value();\n                        if (this._previous().type === 18 /* TokenType.QuotedStr */) { // to preserve old parser behavior: \"foo == 'true'\" is preserved as \"foo == 'true'\", but \"foo == true\" is optimized as \"foo\"\n                            return ContextKeyExpr.equals(key, right);\n                        }\n                        switch (right) {\n                            case 'true':\n                                return ContextKeyExpr.has(key);\n                            case 'false':\n                                return ContextKeyExpr.not(key);\n                            default:\n                                return ContextKeyExpr.equals(key, right);\n                        }\n                    }\n                    case 4 /* TokenType.NotEq */: {\n                        this._advance();\n                        const right = this._value();\n                        if (this._previous().type === 18 /* TokenType.QuotedStr */) { // same as above with \"foo != 'true'\"\n                            return ContextKeyExpr.notEquals(key, right);\n                        }\n                        switch (right) {\n                            case 'true':\n                                return ContextKeyExpr.not(key);\n                            case 'false':\n                                return ContextKeyExpr.has(key);\n                            default:\n                                return ContextKeyExpr.notEquals(key, right);\n                        }\n                    }\n                    // TODO: ContextKeyExpr.smaller(key, right) accepts only `number` as `right` AND during eval of this node, we just eval to `false` if `right` is not a number\n                    // consequently, package.json linter should _warn_ the user if they're passing undesired things to ops\n                    case 5 /* TokenType.Lt */:\n                        this._advance();\n                        return ContextKeySmallerExpr.create(key, this._value());\n                    case 6 /* TokenType.LtEq */:\n                        this._advance();\n                        return ContextKeySmallerEqualsExpr.create(key, this._value());\n                    case 7 /* TokenType.Gt */:\n                        this._advance();\n                        return ContextKeyGreaterExpr.create(key, this._value());\n                    case 8 /* TokenType.GtEq */:\n                        this._advance();\n                        return ContextKeyGreaterEqualsExpr.create(key, this._value());\n                    case 13 /* TokenType.In */:\n                        this._advance();\n                        return ContextKeyExpr.in(key, this._value());\n                    default:\n                        return ContextKeyExpr.has(key);\n                }\n            }\n            case 20 /* TokenType.EOF */:\n                this._parsingErrors.push({ message: errorUnexpectedEOF, offset: peek.offset, lexeme: '', additionalInfo: hintUnexpectedEOF });\n                throw Parser._parseError;\n            default:\n                throw this._errExpectedButGot(`true | false | KEY \\n\\t| KEY '=~' REGEX \\n\\t| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this._peek());\n        }\n    }\n    _value() {\n        const token = this._peek();\n        switch (token.type) {\n            case 17 /* TokenType.Str */:\n            case 18 /* TokenType.QuotedStr */:\n                this._advance();\n                return token.lexeme;\n            case 11 /* TokenType.True */:\n                this._advance();\n                return 'true';\n            case 12 /* TokenType.False */:\n                this._advance();\n                return 'false';\n            case 13 /* TokenType.In */: // we support `in` as a value, e.g., \"when\": \"languageId == in\" - exists in existing extensions\n                this._advance();\n                return 'in';\n            default:\n                // this allows \"when\": \"foo == \" which's used by existing extensions\n                // we do not call `_advance` on purpose - we don't want to eat unintended tokens\n                return '';\n        }\n    }\n    _removeFlagsGY(flags) {\n        return flags.replaceAll(this._flagsGYRe, '');\n    }\n    // careful: this can throw if current token is the initial one (ie index = 0)\n    _previous() {\n        return this._tokens[this._current - 1];\n    }\n    _matchOne(token) {\n        if (this._check(token)) {\n            this._advance();\n            return true;\n        }\n        return false;\n    }\n    _advance() {\n        if (!this._isAtEnd()) {\n            this._current++;\n        }\n        return this._previous();\n    }\n    _consume(type, message) {\n        if (this._check(type)) {\n            return this._advance();\n        }\n        throw this._errExpectedButGot(message, this._peek());\n    }\n    _errExpectedButGot(expected, got, additionalInfo) {\n        const message = localize('contextkey.parser.error.expectedButGot', \"Expected: {0}\\nReceived: '{1}'.\", expected, Scanner.getLexeme(got));\n        const offset = got.offset;\n        const lexeme = Scanner.getLexeme(got);\n        this._parsingErrors.push({ message, offset, lexeme, additionalInfo });\n        return Parser._parseError;\n    }\n    _check(type) {\n        return this._peek().type === type;\n    }\n    _peek() {\n        return this._tokens[this._current];\n    }\n    _isAtEnd() {\n        return this._peek().type === 20 /* TokenType.EOF */;\n    }\n}\nexport class ContextKeyExpr {\n    static false() {\n        return ContextKeyFalseExpr.INSTANCE;\n    }\n    static true() {\n        return ContextKeyTrueExpr.INSTANCE;\n    }\n    static has(key) {\n        return ContextKeyDefinedExpr.create(key);\n    }\n    static equals(key, value) {\n        return ContextKeyEqualsExpr.create(key, value);\n    }\n    static notEquals(key, value) {\n        return ContextKeyNotEqualsExpr.create(key, value);\n    }\n    static regex(key, value) {\n        return ContextKeyRegexExpr.create(key, value);\n    }\n    static in(key, value) {\n        return ContextKeyInExpr.create(key, value);\n    }\n    static notIn(key, value) {\n        return ContextKeyNotInExpr.create(key, value);\n    }\n    static not(key) {\n        return ContextKeyNotExpr.create(key);\n    }\n    static and(...expr) {\n        return ContextKeyAndExpr.create(expr, null, true);\n    }\n    static or(...expr) {\n        return ContextKeyOrExpr.create(expr, null, true);\n    }\n    static { this._parser = new Parser({ regexParsingWithErrorRecovery: false }); }\n    static deserialize(serialized) {\n        if (serialized === undefined || serialized === null) { // an empty string needs to be handled by the parser to get a corresponding parsing error reported\n            return undefined;\n        }\n        const expr = this._parser.parse(serialized);\n        return expr;\n    }\n}\nexport function expressionsAreEqualWithConstantSubstitution(a, b) {\n    const aExpr = a ? a.substituteConstants() : undefined;\n    const bExpr = b ? b.substituteConstants() : undefined;\n    if (!aExpr && !bExpr) {\n        return true;\n    }\n    if (!aExpr || !bExpr) {\n        return false;\n    }\n    return aExpr.equals(bExpr);\n}\nfunction cmp(a, b) {\n    return a.cmp(b);\n}\nexport class ContextKeyFalseExpr {\n    static { this.INSTANCE = new ContextKeyFalseExpr(); }\n    constructor() {\n        this.type = 0 /* ContextKeyExprType.False */;\n    }\n    cmp(other) {\n        return this.type - other.type;\n    }\n    equals(other) {\n        return (other.type === this.type);\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return false;\n    }\n    serialize() {\n        return 'false';\n    }\n    keys() {\n        return [];\n    }\n    negate() {\n        return ContextKeyTrueExpr.INSTANCE;\n    }\n}\nexport class ContextKeyTrueExpr {\n    static { this.INSTANCE = new ContextKeyTrueExpr(); }\n    constructor() {\n        this.type = 1 /* ContextKeyExprType.True */;\n    }\n    cmp(other) {\n        return this.type - other.type;\n    }\n    equals(other) {\n        return (other.type === this.type);\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return true;\n    }\n    serialize() {\n        return 'true';\n    }\n    keys() {\n        return [];\n    }\n    negate() {\n        return ContextKeyFalseExpr.INSTANCE;\n    }\n}\nexport class ContextKeyDefinedExpr {\n    static create(key, negated = null) {\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n        }\n        return new ContextKeyDefinedExpr(key, negated);\n    }\n    constructor(key, negated) {\n        this.key = key;\n        this.negated = negated;\n        this.type = 2 /* ContextKeyExprType.Defined */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp1(this.key, other.key);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (!!context.getValue(this.key));\n    }\n    serialize() {\n        return this.key;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotExpr.create(this.key, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyEqualsExpr {\n    static create(key, value, negated = null) {\n        if (typeof value === 'boolean') {\n            return (value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated));\n        }\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            const trueValue = constantValue ? 'true' : 'false';\n            return (value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n        }\n        return new ContextKeyEqualsExpr(key, value, negated);\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 4 /* ContextKeyExprType.Equals */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            const trueValue = constantValue ? 'true' : 'false';\n            return (this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        // Intentional ==\n        // eslint-disable-next-line eqeqeq\n        return (context.getValue(this.key) == this.value);\n    }\n    serialize() {\n        return `${this.key} == '${this.value}'`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyInExpr {\n    static create(key, valueKey) {\n        return new ContextKeyInExpr(key, valueKey);\n    }\n    constructor(key, valueKey) {\n        this.key = key;\n        this.valueKey = valueKey;\n        this.type = 10 /* ContextKeyExprType.In */;\n        this.negated = null;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.valueKey, other.key, other.valueKey);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.valueKey === other.valueKey);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        const source = context.getValue(this.valueKey);\n        const item = context.getValue(this.key);\n        if (Array.isArray(source)) {\n            return source.includes(item);\n        }\n        if (typeof item === 'string' && typeof source === 'object' && source !== null) {\n            return hasOwnProperty.call(source, item);\n        }\n        return false;\n    }\n    serialize() {\n        return `${this.key} in '${this.valueKey}'`;\n    }\n    keys() {\n        return [this.key, this.valueKey];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotInExpr {\n    static create(key, valueKey) {\n        return new ContextKeyNotInExpr(key, valueKey);\n    }\n    constructor(key, valueKey) {\n        this.key = key;\n        this.valueKey = valueKey;\n        this.type = 11 /* ContextKeyExprType.NotIn */;\n        this._negated = ContextKeyInExpr.create(key, valueKey);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return this._negated.cmp(other._negated);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return this._negated.equals(other._negated);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return !this._negated.evaluate(context);\n    }\n    serialize() {\n        return `${this.key} not in '${this.valueKey}'`;\n    }\n    keys() {\n        return this._negated.keys();\n    }\n    negate() {\n        return this._negated;\n    }\n}\nexport class ContextKeyNotEqualsExpr {\n    static create(key, value, negated = null) {\n        if (typeof value === 'boolean') {\n            if (value) {\n                return ContextKeyNotExpr.create(key, negated);\n            }\n            return ContextKeyDefinedExpr.create(key, negated);\n        }\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            const falseValue = constantValue ? 'true' : 'false';\n            return (value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return new ContextKeyNotEqualsExpr(key, value, negated);\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 5 /* ContextKeyExprType.NotEquals */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            const falseValue = constantValue ? 'true' : 'false';\n            return (this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        // Intentional !=\n        // eslint-disable-next-line eqeqeq\n        return (context.getValue(this.key) != this.value);\n    }\n    serialize() {\n        return `${this.key} != '${this.value}'`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotExpr {\n    static create(key, negated = null) {\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return new ContextKeyNotExpr(key, negated);\n    }\n    constructor(key, negated) {\n        this.key = key;\n        this.negated = negated;\n        this.type = 3 /* ContextKeyExprType.Not */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp1(this.key, other.key);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (!context.getValue(this.key));\n    }\n    serialize() {\n        return `!${this.key}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyDefinedExpr.create(this.key, this);\n        }\n        return this.negated;\n    }\n}\nfunction withFloatOrStr(value, callback) {\n    if (typeof value === 'string') {\n        const n = parseFloat(value);\n        if (!isNaN(n)) {\n            value = n;\n        }\n    }\n    if (typeof value === 'string' || typeof value === 'number') {\n        return callback(value);\n    }\n    return ContextKeyFalseExpr.INSTANCE;\n}\nexport class ContextKeyGreaterExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeyGreaterExpr(key, value, negated));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 12 /* ContextKeyExprType.Greater */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) > this.value);\n    }\n    serialize() {\n        return `${this.key} > ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyGreaterEqualsExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeyGreaterEqualsExpr(key, value, negated));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 13 /* ContextKeyExprType.GreaterEquals */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) >= this.value);\n    }\n    serialize() {\n        return `${this.key} >= ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeySmallerExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeySmallerExpr(key, value, negated));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 14 /* ContextKeyExprType.Smaller */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) < this.value);\n    }\n    serialize() {\n        return `${this.key} < ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeySmallerEqualsExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeySmallerEqualsExpr(key, value, negated));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 15 /* ContextKeyExprType.SmallerEquals */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) <= this.value);\n    }\n    serialize() {\n        return `${this.key} <= ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyRegexExpr {\n    static create(key, regexp) {\n        return new ContextKeyRegexExpr(key, regexp);\n    }\n    constructor(key, regexp) {\n        this.key = key;\n        this.regexp = regexp;\n        this.type = 7 /* ContextKeyExprType.Regex */;\n        this.negated = null;\n        //\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.key < other.key) {\n            return -1;\n        }\n        if (this.key > other.key) {\n            return 1;\n        }\n        const thisSource = this.regexp ? this.regexp.source : '';\n        const otherSource = other.regexp ? other.regexp.source : '';\n        if (thisSource < otherSource) {\n            return -1;\n        }\n        if (thisSource > otherSource) {\n            return 1;\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            const thisSource = this.regexp ? this.regexp.source : '';\n            const otherSource = other.regexp ? other.regexp.source : '';\n            return (this.key === other.key && thisSource === otherSource);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        const value = context.getValue(this.key);\n        return this.regexp ? this.regexp.test(value) : false;\n    }\n    serialize() {\n        const value = this.regexp\n            ? `/${this.regexp.source}/${this.regexp.flags}`\n            : '/invalid/';\n        return `${this.key} =~ ${value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotRegexExpr.create(this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotRegexExpr {\n    static create(actual) {\n        return new ContextKeyNotRegexExpr(actual);\n    }\n    constructor(_actual) {\n        this._actual = _actual;\n        this.type = 8 /* ContextKeyExprType.NotRegex */;\n        //\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return this._actual.cmp(other._actual);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return this._actual.equals(other._actual);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return !this._actual.evaluate(context);\n    }\n    serialize() {\n        return `!(${this._actual.serialize()})`;\n    }\n    keys() {\n        return this._actual.keys();\n    }\n    negate() {\n        return this._actual;\n    }\n}\n/**\n * @returns the same instance if nothing changed.\n */\nfunction eliminateConstantsInArray(arr) {\n    // Allocate array only if there is a difference\n    let newArr = null;\n    for (let i = 0, len = arr.length; i < len; i++) {\n        const newExpr = arr[i].substituteConstants();\n        if (arr[i] !== newExpr) {\n            // something has changed!\n            // allocate array on first difference\n            if (newArr === null) {\n                newArr = [];\n                for (let j = 0; j < i; j++) {\n                    newArr[j] = arr[j];\n                }\n            }\n        }\n        if (newArr !== null) {\n            newArr[i] = newExpr;\n        }\n    }\n    if (newArr === null) {\n        return arr;\n    }\n    return newArr;\n}\nexport class ContextKeyAndExpr {\n    static create(_expr, negated, extraRedundantCheck) {\n        return ContextKeyAndExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n    }\n    constructor(expr, negated) {\n        this.expr = expr;\n        this.negated = negated;\n        this.type = 6 /* ContextKeyExprType.And */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.expr.length < other.expr.length) {\n            return -1;\n        }\n        if (this.expr.length > other.expr.length) {\n            return 1;\n        }\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            const r = cmp(this.expr[i], other.expr[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    substituteConstants() {\n        const exprArr = eliminateConstantsInArray(this.expr);\n        if (exprArr === this.expr) {\n            // no change\n            return this;\n        }\n        return ContextKeyAndExpr.create(exprArr, this.negated, false);\n    }\n    evaluate(context) {\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            if (!this.expr[i].evaluate(context)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _normalizeArr(arr, negated, extraRedundantCheck) {\n        const expr = [];\n        let hasTrue = false;\n        for (const e of arr) {\n            if (!e) {\n                continue;\n            }\n            if (e.type === 1 /* ContextKeyExprType.True */) {\n                // anything && true ==> anything\n                hasTrue = true;\n                continue;\n            }\n            if (e.type === 0 /* ContextKeyExprType.False */) {\n                // anything && false ==> false\n                return ContextKeyFalseExpr.INSTANCE;\n            }\n            if (e.type === 6 /* ContextKeyExprType.And */) {\n                expr.push(...e.expr);\n                continue;\n            }\n            expr.push(e);\n        }\n        if (expr.length === 0 && hasTrue) {\n            return ContextKeyTrueExpr.INSTANCE;\n        }\n        if (expr.length === 0) {\n            return undefined;\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        expr.sort(cmp);\n        // eliminate duplicate terms\n        for (let i = 1; i < expr.length; i++) {\n            if (expr[i - 1].equals(expr[i])) {\n                expr.splice(i, 1);\n                i--;\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // We must distribute any OR expression because we don't support parens\n        // OR extensions will be at the end (due to sorting rules)\n        while (expr.length > 1) {\n            const lastElement = expr[expr.length - 1];\n            if (lastElement.type !== 9 /* ContextKeyExprType.Or */) {\n                break;\n            }\n            // pop the last element\n            expr.pop();\n            // pop the second to last element\n            const secondToLastElement = expr.pop();\n            const isFinished = (expr.length === 0);\n            // distribute `lastElement` over `secondToLastElement`\n            const resultElement = ContextKeyOrExpr.create(lastElement.expr.map(el => ContextKeyAndExpr.create([el, secondToLastElement], null, extraRedundantCheck)), null, isFinished);\n            if (resultElement) {\n                expr.push(resultElement);\n                expr.sort(cmp);\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // resolve false AND expressions\n        if (extraRedundantCheck) {\n            for (let i = 0; i < expr.length; i++) {\n                for (let j = i + 1; j < expr.length; j++) {\n                    if (expr[i].negate().equals(expr[j])) {\n                        // A && !A case\n                        return ContextKeyFalseExpr.INSTANCE;\n                    }\n                }\n            }\n            if (expr.length === 1) {\n                return expr[0];\n            }\n        }\n        return new ContextKeyAndExpr(expr, negated);\n    }\n    serialize() {\n        return this.expr.map(e => e.serialize()).join(' && ');\n    }\n    keys() {\n        const result = [];\n        for (const expr of this.expr) {\n            result.push(...expr.keys());\n        }\n        return result;\n    }\n    negate() {\n        if (!this.negated) {\n            const result = [];\n            for (const expr of this.expr) {\n                result.push(expr.negate());\n            }\n            this.negated = ContextKeyOrExpr.create(result, this, true);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyOrExpr {\n    static create(_expr, negated, extraRedundantCheck) {\n        return ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n    }\n    constructor(expr, negated) {\n        this.expr = expr;\n        this.negated = negated;\n        this.type = 9 /* ContextKeyExprType.Or */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.expr.length < other.expr.length) {\n            return -1;\n        }\n        if (this.expr.length > other.expr.length) {\n            return 1;\n        }\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            const r = cmp(this.expr[i], other.expr[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    substituteConstants() {\n        const exprArr = eliminateConstantsInArray(this.expr);\n        if (exprArr === this.expr) {\n            // no change\n            return this;\n        }\n        return ContextKeyOrExpr.create(exprArr, this.negated, false);\n    }\n    evaluate(context) {\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            if (this.expr[i].evaluate(context)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static _normalizeArr(arr, negated, extraRedundantCheck) {\n        let expr = [];\n        let hasFalse = false;\n        if (arr) {\n            for (let i = 0, len = arr.length; i < len; i++) {\n                const e = arr[i];\n                if (!e) {\n                    continue;\n                }\n                if (e.type === 0 /* ContextKeyExprType.False */) {\n                    // anything || false ==> anything\n                    hasFalse = true;\n                    continue;\n                }\n                if (e.type === 1 /* ContextKeyExprType.True */) {\n                    // anything || true ==> true\n                    return ContextKeyTrueExpr.INSTANCE;\n                }\n                if (e.type === 9 /* ContextKeyExprType.Or */) {\n                    expr = expr.concat(e.expr);\n                    continue;\n                }\n                expr.push(e);\n            }\n            if (expr.length === 0 && hasFalse) {\n                return ContextKeyFalseExpr.INSTANCE;\n            }\n            expr.sort(cmp);\n        }\n        if (expr.length === 0) {\n            return undefined;\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // eliminate duplicate terms\n        for (let i = 1; i < expr.length; i++) {\n            if (expr[i - 1].equals(expr[i])) {\n                expr.splice(i, 1);\n                i--;\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // resolve true OR expressions\n        if (extraRedundantCheck) {\n            for (let i = 0; i < expr.length; i++) {\n                for (let j = i + 1; j < expr.length; j++) {\n                    if (expr[i].negate().equals(expr[j])) {\n                        // A || !A case\n                        return ContextKeyTrueExpr.INSTANCE;\n                    }\n                }\n            }\n            if (expr.length === 1) {\n                return expr[0];\n            }\n        }\n        return new ContextKeyOrExpr(expr, negated);\n    }\n    serialize() {\n        return this.expr.map(e => e.serialize()).join(' || ');\n    }\n    keys() {\n        const result = [];\n        for (const expr of this.expr) {\n            result.push(...expr.keys());\n        }\n        return result;\n    }\n    negate() {\n        if (!this.negated) {\n            const result = [];\n            for (const expr of this.expr) {\n                result.push(expr.negate());\n            }\n            // We don't support parens, so here we distribute the AND over the OR terminals\n            // We always take the first 2 AND pairs and distribute them\n            while (result.length > 1) {\n                const LEFT = result.shift();\n                const RIGHT = result.shift();\n                const all = [];\n                for (const left of getTerminals(LEFT)) {\n                    for (const right of getTerminals(RIGHT)) {\n                        all.push(ContextKeyAndExpr.create([left, right], null, false));\n                    }\n                }\n                result.unshift(ContextKeyOrExpr.create(all, null, false));\n            }\n            this.negated = ContextKeyOrExpr.create(result, this, true);\n        }\n        return this.negated;\n    }\n}\nexport class RawContextKey extends ContextKeyDefinedExpr {\n    static { this._info = []; }\n    static all() {\n        return RawContextKey._info.values();\n    }\n    constructor(key, defaultValue, metaOrHide) {\n        super(key, null);\n        this._defaultValue = defaultValue;\n        // collect all context keys into a central place\n        if (typeof metaOrHide === 'object') {\n            RawContextKey._info.push({ ...metaOrHide, key });\n        }\n        else if (metaOrHide !== true) {\n            RawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined });\n        }\n    }\n    bindTo(target) {\n        return target.createKey(this.key, this._defaultValue);\n    }\n    getValue(target) {\n        return target.getContextKeyValue(this.key);\n    }\n    toNegated() {\n        return this.negate();\n    }\n    isEqualTo(value) {\n        return ContextKeyEqualsExpr.create(this.key, value);\n    }\n}\nexport const IContextKeyService = createDecorator('contextKeyService');\nfunction cmp1(key1, key2) {\n    if (key1 < key2) {\n        return -1;\n    }\n    if (key1 > key2) {\n        return 1;\n    }\n    return 0;\n}\nfunction cmp2(key1, value1, key2, value2) {\n    if (key1 < key2) {\n        return -1;\n    }\n    if (key1 > key2) {\n        return 1;\n    }\n    if (value1 < value2) {\n        return -1;\n    }\n    if (value1 > value2) {\n        return 1;\n    }\n    return 0;\n}\n/**\n * Returns true if it is provable `p` implies `q`.\n */\nexport function implies(p, q) {\n    if (p.type === 0 /* ContextKeyExprType.False */ || q.type === 1 /* ContextKeyExprType.True */) {\n        // false implies anything\n        // anything implies true\n        return true;\n    }\n    if (p.type === 9 /* ContextKeyExprType.Or */) {\n        if (q.type === 9 /* ContextKeyExprType.Or */) {\n            // `a || b || c` can only imply something like `a || b || c || d`\n            return allElementsIncluded(p.expr, q.expr);\n        }\n        return false;\n    }\n    if (q.type === 9 /* ContextKeyExprType.Or */) {\n        for (const element of q.expr) {\n            if (implies(p, element)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (p.type === 6 /* ContextKeyExprType.And */) {\n        if (q.type === 6 /* ContextKeyExprType.And */) {\n            // `a && b && c` implies `a && c`\n            return allElementsIncluded(q.expr, p.expr);\n        }\n        for (const element of p.expr) {\n            if (implies(element, q)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return p.equals(q);\n}\n/**\n * Returns true if all elements in `p` are also present in `q`.\n * The two arrays are assumed to be sorted\n */\nfunction allElementsIncluded(p, q) {\n    let pIndex = 0;\n    let qIndex = 0;\n    while (pIndex < p.length && qIndex < q.length) {\n        const cmp = p[pIndex].cmp(q[qIndex]);\n        if (cmp < 0) {\n            // an element from `p` is missing from `q`\n            return false;\n        }\n        else if (cmp === 0) {\n            pIndex++;\n            qIndex++;\n        }\n        else {\n            qIndex++;\n        }\n    }\n    return (pIndex === p.length);\n}\nfunction getTerminals(node) {\n    if (node.type === 9 /* ContextKeyExprType.Or */) {\n        return node.expr;\n    }\n    return [node];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { illegalState } from '../../../base/common/errors.js';\nimport { localize } from '../../../nls.js';\nfunction hintDidYouMean(...meant) {\n    switch (meant.length) {\n        case 1:\n            return localize('contextkey.scanner.hint.didYouMean1', \"Did you mean {0}?\", meant[0]);\n        case 2:\n            return localize('contextkey.scanner.hint.didYouMean2', \"Did you mean {0} or {1}?\", meant[0], meant[1]);\n        case 3:\n            return localize('contextkey.scanner.hint.didYouMean3', \"Did you mean {0}, {1} or {2}?\", meant[0], meant[1], meant[2]);\n        default: // we just don't expect that many\n            return undefined;\n    }\n}\nconst hintDidYouForgetToOpenOrCloseQuote = localize('contextkey.scanner.hint.didYouForgetToOpenOrCloseQuote', \"Did you forget to open or close the quote?\");\nconst hintDidYouForgetToEscapeSlash = localize('contextkey.scanner.hint.didYouForgetToEscapeSlash', \"Did you forget to escape the '/' (slash) character? Put two backslashes before it to escape, e.g., '\\\\\\\\/\\'.\");\n/**\n * A simple scanner for context keys.\n *\n * Example:\n *\n * ```ts\n * const scanner = new Scanner().reset('resourceFileName =~ /docker/ && !config.docker.enabled');\n * const tokens = [...scanner];\n * if (scanner.errorTokens.length > 0) {\n *     scanner.errorTokens.forEach(err => console.error(`Unexpected token at ${err.offset}: ${err.lexeme}\\nHint: ${err.additional}`));\n * } else {\n *     // process tokens\n * }\n * ```\n */\nexport class Scanner {\n    constructor() {\n        this._input = '';\n        this._start = 0;\n        this._current = 0;\n        this._tokens = [];\n        this._errors = [];\n        // u - unicode, y - sticky // TODO@ulugbekna: we accept double quotes as part of the string rather than as a delimiter (to preserve old parser's behavior)\n        this.stringRe = /[a-zA-Z0-9_<>\\-\\./\\\\:\\*\\?\\+\\[\\]\\^,#@;\"%\\$\\p{L}-]+/uy;\n    }\n    static getLexeme(token) {\n        switch (token.type) {\n            case 0 /* TokenType.LParen */:\n                return '(';\n            case 1 /* TokenType.RParen */:\n                return ')';\n            case 2 /* TokenType.Neg */:\n                return '!';\n            case 3 /* TokenType.Eq */:\n                return token.isTripleEq ? '===' : '==';\n            case 4 /* TokenType.NotEq */:\n                return token.isTripleEq ? '!==' : '!=';\n            case 5 /* TokenType.Lt */:\n                return '<';\n            case 6 /* TokenType.LtEq */:\n                return '<=';\n            case 7 /* TokenType.Gt */:\n                return '>=';\n            case 8 /* TokenType.GtEq */:\n                return '>=';\n            case 9 /* TokenType.RegexOp */:\n                return '=~';\n            case 10 /* TokenType.RegexStr */:\n                return token.lexeme;\n            case 11 /* TokenType.True */:\n                return 'true';\n            case 12 /* TokenType.False */:\n                return 'false';\n            case 13 /* TokenType.In */:\n                return 'in';\n            case 14 /* TokenType.Not */:\n                return 'not';\n            case 15 /* TokenType.And */:\n                return '&&';\n            case 16 /* TokenType.Or */:\n                return '||';\n            case 17 /* TokenType.Str */:\n                return token.lexeme;\n            case 18 /* TokenType.QuotedStr */:\n                return token.lexeme;\n            case 19 /* TokenType.Error */:\n                return token.lexeme;\n            case 20 /* TokenType.EOF */:\n                return 'EOF';\n            default:\n                throw illegalState(`unhandled token type: ${JSON.stringify(token)}; have you forgotten to add a case?`);\n        }\n    }\n    static { this._regexFlags = new Set(['i', 'g', 's', 'm', 'y', 'u'].map(ch => ch.charCodeAt(0))); }\n    static { this._keywords = new Map([\n        ['not', 14 /* TokenType.Not */],\n        ['in', 13 /* TokenType.In */],\n        ['false', 12 /* TokenType.False */],\n        ['true', 11 /* TokenType.True */],\n    ]); }\n    reset(value) {\n        this._input = value;\n        this._start = 0;\n        this._current = 0;\n        this._tokens = [];\n        this._errors = [];\n        return this;\n    }\n    scan() {\n        while (!this._isAtEnd()) {\n            this._start = this._current;\n            const ch = this._advance();\n            switch (ch) {\n                case 40 /* CharCode.OpenParen */:\n                    this._addToken(0 /* TokenType.LParen */);\n                    break;\n                case 41 /* CharCode.CloseParen */:\n                    this._addToken(1 /* TokenType.RParen */);\n                    break;\n                case 33 /* CharCode.ExclamationMark */:\n                    if (this._match(61 /* CharCode.Equals */)) {\n                        const isTripleEq = this._match(61 /* CharCode.Equals */); // eat last `=` if `!==`\n                        this._tokens.push({ type: 4 /* TokenType.NotEq */, offset: this._start, isTripleEq });\n                    }\n                    else {\n                        this._addToken(2 /* TokenType.Neg */);\n                    }\n                    break;\n                case 39 /* CharCode.SingleQuote */:\n                    this._quotedString();\n                    break;\n                case 47 /* CharCode.Slash */:\n                    this._regex();\n                    break;\n                case 61 /* CharCode.Equals */:\n                    if (this._match(61 /* CharCode.Equals */)) { // support `==`\n                        const isTripleEq = this._match(61 /* CharCode.Equals */); // eat last `=` if `===`\n                        this._tokens.push({ type: 3 /* TokenType.Eq */, offset: this._start, isTripleEq });\n                    }\n                    else if (this._match(126 /* CharCode.Tilde */)) {\n                        this._addToken(9 /* TokenType.RegexOp */);\n                    }\n                    else {\n                        this._error(hintDidYouMean('==', '=~'));\n                    }\n                    break;\n                case 60 /* CharCode.LessThan */:\n                    this._addToken(this._match(61 /* CharCode.Equals */) ? 6 /* TokenType.LtEq */ : 5 /* TokenType.Lt */);\n                    break;\n                case 62 /* CharCode.GreaterThan */:\n                    this._addToken(this._match(61 /* CharCode.Equals */) ? 8 /* TokenType.GtEq */ : 7 /* TokenType.Gt */);\n                    break;\n                case 38 /* CharCode.Ampersand */:\n                    if (this._match(38 /* CharCode.Ampersand */)) {\n                        this._addToken(15 /* TokenType.And */);\n                    }\n                    else {\n                        this._error(hintDidYouMean('&&'));\n                    }\n                    break;\n                case 124 /* CharCode.Pipe */:\n                    if (this._match(124 /* CharCode.Pipe */)) {\n                        this._addToken(16 /* TokenType.Or */);\n                    }\n                    else {\n                        this._error(hintDidYouMean('||'));\n                    }\n                    break;\n                // TODO@ulugbekna: 1) rewrite using a regex 2) reconsider what characters are considered whitespace, including unicode, nbsp, etc.\n                case 32 /* CharCode.Space */:\n                case 13 /* CharCode.CarriageReturn */:\n                case 9 /* CharCode.Tab */:\n                case 10 /* CharCode.LineFeed */:\n                case 160 /* CharCode.NoBreakSpace */: // &nbsp\n                    break;\n                default:\n                    this._string();\n            }\n        }\n        this._start = this._current;\n        this._addToken(20 /* TokenType.EOF */);\n        return Array.from(this._tokens);\n    }\n    _match(expected) {\n        if (this._isAtEnd()) {\n            return false;\n        }\n        if (this._input.charCodeAt(this._current) !== expected) {\n            return false;\n        }\n        this._current++;\n        return true;\n    }\n    _advance() {\n        return this._input.charCodeAt(this._current++);\n    }\n    _peek() {\n        return this._isAtEnd() ? 0 /* CharCode.Null */ : this._input.charCodeAt(this._current);\n    }\n    _addToken(type) {\n        this._tokens.push({ type, offset: this._start });\n    }\n    _error(additional) {\n        const offset = this._start;\n        const lexeme = this._input.substring(this._start, this._current);\n        const errToken = { type: 19 /* TokenType.Error */, offset: this._start, lexeme };\n        this._errors.push({ offset, lexeme, additionalInfo: additional });\n        this._tokens.push(errToken);\n    }\n    _string() {\n        this.stringRe.lastIndex = this._start;\n        const match = this.stringRe.exec(this._input);\n        if (match) {\n            this._current = this._start + match[0].length;\n            const lexeme = this._input.substring(this._start, this._current);\n            const keyword = Scanner._keywords.get(lexeme);\n            if (keyword) {\n                this._addToken(keyword);\n            }\n            else {\n                this._tokens.push({ type: 17 /* TokenType.Str */, lexeme, offset: this._start });\n            }\n        }\n    }\n    // captures the lexeme without the leading and trailing '\n    _quotedString() {\n        while (this._peek() !== 39 /* CharCode.SingleQuote */ && !this._isAtEnd()) { // TODO@ulugbekna: add support for escaping ' ?\n            this._advance();\n        }\n        if (this._isAtEnd()) {\n            this._error(hintDidYouForgetToOpenOrCloseQuote);\n            return;\n        }\n        // consume the closing '\n        this._advance();\n        this._tokens.push({ type: 18 /* TokenType.QuotedStr */, lexeme: this._input.substring(this._start + 1, this._current - 1), offset: this._start + 1 });\n    }\n    /*\n     * Lexing a regex expression: /.../[igsmyu]*\n     * Based on https://github.com/microsoft/TypeScript/blob/9247ef115e617805983740ba795d7a8164babf89/src/compiler/scanner.ts#L2129-L2181\n     *\n     * Note that we want slashes within a regex to be escaped, e.g., /file:\\\\/\\\\/\\\\// should match `file:///`\n     */\n    _regex() {\n        let p = this._current;\n        let inEscape = false;\n        let inCharacterClass = false;\n        while (true) {\n            if (p >= this._input.length) {\n                this._current = p;\n                this._error(hintDidYouForgetToEscapeSlash);\n                return;\n            }\n            const ch = this._input.charCodeAt(p);\n            if (inEscape) { // parsing an escape character\n                inEscape = false;\n            }\n            else if (ch === 47 /* CharCode.Slash */ && !inCharacterClass) { // end of regex\n                p++;\n                break;\n            }\n            else if (ch === 91 /* CharCode.OpenSquareBracket */) {\n                inCharacterClass = true;\n            }\n            else if (ch === 92 /* CharCode.Backslash */) {\n                inEscape = true;\n            }\n            else if (ch === 93 /* CharCode.CloseSquareBracket */) {\n                inCharacterClass = false;\n            }\n            p++;\n        }\n        // Consume flags // TODO@ulugbekna: use regex instead\n        while (p < this._input.length && Scanner._regexFlags.has(this._input.charCodeAt(p))) {\n            p++;\n        }\n        this._current = p;\n        const lexeme = this._input.substring(this._start, this._current);\n        this._tokens.push({ type: 10 /* TokenType.RegexStr */, lexeme, offset: this._start });\n    }\n    _isAtEnd() {\n        return this._current >= this._input.length;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// ------ internal util\nexport var _util;\n(function (_util) {\n    _util.serviceIds = new Map();\n    _util.DI_TARGET = '$di$target';\n    _util.DI_DEPENDENCIES = '$di$dependencies';\n    function getServiceDependencies(ctor) {\n        return ctor[_util.DI_DEPENDENCIES] || [];\n    }\n    _util.getServiceDependencies = getServiceDependencies;\n})(_util || (_util = {}));\nexport const IInstantiationService = createDecorator('instantiationService');\nfunction storeServiceDependency(id, target, index) {\n    if (target[_util.DI_TARGET] === target) {\n        target[_util.DI_DEPENDENCIES].push({ id, index });\n    }\n    else {\n        target[_util.DI_DEPENDENCIES] = [{ id, index }];\n        target[_util.DI_TARGET] = target;\n    }\n}\n/**\n * The *only* valid way to create a {{ServiceIdentifier}}.\n */\nexport function createDecorator(serviceId) {\n    if (_util.serviceIds.has(serviceId)) {\n        return _util.serviceIds.get(serviceId);\n    }\n    const id = function (target, key, index) {\n        if (arguments.length !== 3) {\n            throw new Error('@IServiceName-decorator can only be used to decorate a parameter');\n        }\n        storeServiceDependency(id, target, index);\n    };\n    id.toString = () => serviceId;\n    _util.serviceIds.set(serviceId, id);\n    return id;\n}\n","import { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { RawContextKey } from '../../contextkey/common/contextkey.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const ILogService = createDecorator('logService');\nexport var LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"Off\"] = 0] = \"Off\";\n    LogLevel[LogLevel[\"Trace\"] = 1] = \"Trace\";\n    LogLevel[LogLevel[\"Debug\"] = 2] = \"Debug\";\n    LogLevel[LogLevel[\"Info\"] = 3] = \"Info\";\n    LogLevel[LogLevel[\"Warning\"] = 4] = \"Warning\";\n    LogLevel[LogLevel[\"Error\"] = 5] = \"Error\";\n})(LogLevel || (LogLevel = {}));\nexport const DEFAULT_LOG_LEVEL = LogLevel.Info;\nexport class AbstractLogger extends Disposable {\n    constructor() {\n        super(...arguments);\n        this.level = DEFAULT_LOG_LEVEL;\n        this._onDidChangeLogLevel = this._register(new Emitter());\n        this.onDidChangeLogLevel = this._onDidChangeLogLevel.event;\n    }\n    setLevel(level) {\n        if (this.level !== level) {\n            this.level = level;\n            this._onDidChangeLogLevel.fire(this.level);\n        }\n    }\n    getLevel() {\n        return this.level;\n    }\n    checkLogLevel(level) {\n        return this.level !== LogLevel.Off && this.level <= level;\n    }\n}\nexport class ConsoleLogger extends AbstractLogger {\n    constructor(logLevel = DEFAULT_LOG_LEVEL, useColors = true) {\n        super();\n        this.useColors = useColors;\n        this.setLevel(logLevel);\n    }\n    trace(message, ...args) {\n        if (this.checkLogLevel(LogLevel.Trace)) {\n            if (this.useColors) {\n                console.log('%cTRACE', 'color: #888', message, ...args);\n            }\n            else {\n                console.log(message, ...args);\n            }\n        }\n    }\n    debug(message, ...args) {\n        if (this.checkLogLevel(LogLevel.Debug)) {\n            if (this.useColors) {\n                console.log('%cDEBUG', 'background: #eee; color: #888', message, ...args);\n            }\n            else {\n                console.log(message, ...args);\n            }\n        }\n    }\n    info(message, ...args) {\n        if (this.checkLogLevel(LogLevel.Info)) {\n            if (this.useColors) {\n                console.log('%c INFO', 'color: #33f', message, ...args);\n            }\n            else {\n                console.log(message, ...args);\n            }\n        }\n    }\n    warn(message, ...args) {\n        if (this.checkLogLevel(LogLevel.Warning)) {\n            if (this.useColors) {\n                console.log('%c WARN', 'color: #993', message, ...args);\n            }\n            else {\n                console.log(message, ...args);\n            }\n        }\n    }\n    error(message, ...args) {\n        if (this.checkLogLevel(LogLevel.Error)) {\n            if (this.useColors) {\n                console.log('%c  ERR', 'color: #f33', message, ...args);\n            }\n            else {\n                console.error(message, ...args);\n            }\n        }\n    }\n}\nexport class MultiplexLogger extends AbstractLogger {\n    constructor(loggers) {\n        super();\n        this.loggers = loggers;\n        if (loggers.length) {\n            this.setLevel(loggers[0].getLevel());\n        }\n    }\n    setLevel(level) {\n        for (const logger of this.loggers) {\n            logger.setLevel(level);\n        }\n        super.setLevel(level);\n    }\n    trace(message, ...args) {\n        for (const logger of this.loggers) {\n            logger.trace(message, ...args);\n        }\n    }\n    debug(message, ...args) {\n        for (const logger of this.loggers) {\n            logger.debug(message, ...args);\n        }\n    }\n    info(message, ...args) {\n        for (const logger of this.loggers) {\n            logger.info(message, ...args);\n        }\n    }\n    warn(message, ...args) {\n        for (const logger of this.loggers) {\n            logger.warn(message, ...args);\n        }\n    }\n    error(message, ...args) {\n        for (const logger of this.loggers) {\n            logger.error(message, ...args);\n        }\n    }\n    dispose() {\n        for (const logger of this.loggers) {\n            logger.dispose();\n        }\n        super.dispose();\n    }\n}\nexport function LogLevelToString(logLevel) {\n    switch (logLevel) {\n        case LogLevel.Trace: return 'trace';\n        case LogLevel.Debug: return 'debug';\n        case LogLevel.Info: return 'info';\n        case LogLevel.Warning: return 'warn';\n        case LogLevel.Error: return 'error';\n        case LogLevel.Off: return 'off';\n    }\n}\n// Contexts\nexport const CONTEXT_LOG_LEVEL = new RawContextKey('logLevel', LogLevelToString(LogLevel.Info));\n"],"names":["implies","p","q","allElementsIncluded","element","hintDidYouMean","meant","hintDidYouForgetToOpenOrCloseQuote","hintDidYouForgetToEscapeSlash","Scanner","token","JSON","Set","ch","Map","value","isTripleEq","Array","expected","type","additional","offset","lexeme","errToken","match","keyword","inEscape","inCharacterClass","CONSTANT_VALUES","Object","defaultConfig","errorEmptyString","hintEmptyString","errorNoInAfterNot","errorClosingParenthesis","errorUnexpectedToken","hintUnexpectedToken","errorUnexpectedEOF","hintUnexpectedEOF","Parser","Error","_config","input","expr","peek","additionalInfo","undefined","e","right","ContextKeyExpr","ContextKeyFalseExpr","ContextKeyTrueExpr","ContextKeyNotExpr","key","regexp","regexLexeme","closingSlashIndex","flags","RegExp","ContextKeyRegexExpr","lexemeReconstruction","followingToken","parenBalance","i","serializedValue","regex","start","end","caseIgnoreFlag","_e","ContextKeySmallerExpr","ContextKeySmallerEqualsExpr","ContextKeyGreaterExpr","ContextKeyGreaterEqualsExpr","message","got","ContextKeyDefinedExpr","ContextKeyEqualsExpr","ContextKeyNotEqualsExpr","ContextKeyInExpr","ContextKeyNotInExpr","ContextKeyAndExpr","ContextKeyOrExpr","serialized","expressionsAreEqualWithConstantSubstitution","a","b","aExpr","bExpr","other","context","negated","constantValue","cmp1","key1","key2","cmp2","valueKey","source","item","withFloatOrStr","callback","n","parseFloat","isNaN","_value","thisSource","otherSource","ContextKeyNotRegexExpr","actual","_actual","eliminateConstantsInArray","arr","newArr","len","newExpr","j","_expr","extraRedundantCheck","r","exprArr","hasTrue","lastElement","secondToLastElement","isFinished","resultElement","el","result","hasFalse","LEFT","RIGHT","all","left","getTerminals","RawContextKey","defaultValue","metaOrHide","target","IContextKeyService","value1","value2","pIndex","qIndex","cmp","node","_util","ctor","IInstantiationService","createDecorator","serviceId","id","index","arguments","LogLevel","ILogService","DEFAULT_LOG_LEVEL","AbstractLogger","level","ConsoleLogger","logLevel","useColors","args","console","MultiplexLogger","loggers","logger","LogLevelToString"],"mappings":"qKA28CO,SAASA,EAAQC,CAAC,CAAEC,CAAC,EACxB,GAAID,AAAW,IAAXA,EAAE,IAAI,EAAyCC,AAAW,IAAXA,EAAE,IAAI,CAGrD,MAAO,GAEX,GAAID,AAAW,IAAXA,EAAE,IAAI,QACN,AAAe,IAAXC,EAAE,IAAI,EAECC,EAAoBF,EAAE,IAAI,CAAEC,EAAE,IAAI,EAIjD,GAAIA,AAAW,IAAXA,EAAE,IAAI,CAAoC,CAC1C,IAAK,IAAME,KAAWF,EAAE,IAAI,CACxB,GAAIF,EAAQC,EAAGG,GACX,MAAO,GAGf,MAAO,EACX,CACA,GAAIH,AAAW,IAAXA,EAAE,IAAI,CAAqC,CAC3C,GAAIC,AAAW,IAAXA,EAAE,IAAI,CAEN,OAAOC,EAAoBD,EAAE,IAAI,CAAED,EAAE,IAAI,EAE7C,IAAK,IAAMG,KAAWH,EAAE,IAAI,CACxB,GAAID,EAAQI,EAASF,GACjB,MAAO,GAGf,MAAO,EACX,CACA,OAAOD,EAAE,MAAM,CAACC,EACpB,E,+FCv+CA,SAASG,EAAe,GAAGC,CAAK,EAC5B,OAAQA,EAAM,MAAM,EAChB,KAAK,EACD,MAAO,SAAS,sCAAuC,oBAAqBA,CAAK,CAAC,EAAE,CACxF,MAAK,EACD,MAAO,SAAS,sCAAuC,2BAA4BA,CAAK,CAAC,EAAE,CAAEA,CAAK,CAAC,EAAE,CACzG,MAAK,EACD,MAAO,SAAS,sCAAuC,gCAAiCA,CAAK,CAAC,EAAE,CAAEA,CAAK,CAAC,EAAE,CAAEA,CAAK,CAAC,EAAE,CACxH,SACI,MACR,CACJ,CACA,IAAMC,EAAqC,SAAS,yDAA0D,8CACxGC,EAAgC,SAAS,oDAAqD,8GAgB7F,OAAMC,EACT,aAAc,CACV,IAAI,CAAC,MAAM,CAAG,GACd,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,OAAO,CAAG,EAAE,CACjB,IAAI,CAAC,OAAO,CAAG,EAAE,CAEjB,IAAI,CAAC,QAAQ,CAAG,qDACpB,CACA,OAAO,UAAUC,CAAK,CAAE,CACpB,OAAQA,EAAM,IAAI,EACd,KAAK,EACD,MAAO,GACX,MAAK,EACD,MAAO,GACX,MAAK,EACD,MAAO,GACX,MAAK,EACD,OAAOA,EAAM,UAAU,CAAG,MAAQ,IACtC,MAAK,EACD,OAAOA,EAAM,UAAU,CAAG,MAAQ,IACtC,MAAK,EACD,MAAO,GACX,MAAK,EACD,MAAO,IACX,MAAK,EAEL,KAAK,EADD,MAAO,IAGX,MAAK,EACD,MAAO,IACX,MAAK,GAcL,KAAK,GAEL,KAAK,GAEL,KAAK,GAjBD,OAAOA,EAAM,MAAM,AACvB,MAAK,GACD,MAAO,MACX,MAAK,GACD,MAAO,OACX,MAAK,GACD,MAAO,IACX,MAAK,GACD,MAAO,KACX,MAAK,GACD,MAAO,IACX,MAAK,GACD,MAAO,IAOX,MAAK,GACD,MAAO,KACX,SACI,KAAM,SAAa,CAAC,sBAAsB,EAAEC,KAAK,SAAS,CAACD,GAAO,mCAAmC,CAAC,CAC9G,CACJ,CACA,MAAO,CAAE,IAAI,CAAC,WAAW,CAAG,IAAIE,IAAI,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAI,CAAC,GAAG,CAACC,GAAMA,EAAG,UAAU,CAAC,IAAM,CAAC,AAClG,MAAO,CAAE,IAAI,CAAC,SAAS,CAAG,IAAIC,IAAI,CAC9B,CAAC,MAAO,GAAuB,CAC/B,CAAC,KAAM,GAAsB,CAC7B,CAAC,QAAS,GAAyB,CACnC,CAAC,OAAQ,GAAwB,CACpC,CAAG,CAAC,AACL,MAAMC,CAAK,CAAE,CAMT,OALA,IAAI,CAAC,MAAM,CAAGA,EACd,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,OAAO,CAAG,EAAE,CACjB,IAAI,CAAC,OAAO,CAAG,EAAE,CACV,IAAI,AACf,CACA,MAAO,CACH,KAAO,CAAC,IAAI,CAAC,QAAQ,IAGjB,OAFA,IAAI,CAAC,MAAM,CAAG,IAAI,CAAC,QAAQ,CAChB,IAAI,CAAC,QAAQ,IAEpB,KAAK,GACD,IAAI,CAAC,SAAS,CAAC,GACf,KACJ,MAAK,GACD,IAAI,CAAC,SAAS,CAAC,GACf,KACJ,MAAK,GACD,GAAI,IAAI,CAAC,MAAM,CAAC,IAA2B,CACvC,IAAMC,EAAa,IAAI,CAAC,MAAM,CAAC,IAC/B,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAE,KAAM,EAAyB,OAAQ,IAAI,CAAC,MAAM,CAAEA,WAAAA,CAAW,EACvF,MAEI,IAAI,CAAC,SAAS,CAAC,GAEnB,KACJ,MAAK,GACD,IAAI,CAAC,aAAa,GAClB,KACJ,MAAK,GACD,IAAI,CAAC,MAAM,GACX,KACJ,MAAK,GACD,GAAI,IAAI,CAAC,MAAM,CAAC,IAA2B,CACvC,IAAMA,EAAa,IAAI,CAAC,MAAM,CAAC,IAC/B,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAE,KAAM,EAAsB,OAAQ,IAAI,CAAC,MAAM,CAAEA,WAAAA,CAAW,EACpF,MACS,IAAI,CAAC,MAAM,CAAC,KACjB,IAAI,CAAC,SAAS,CAAC,GAGf,IAAI,CAAC,MAAM,CAACX,EAAe,KAAM,OAErC,KACJ,MAAK,GACD,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,IAA4B,EAAyB,GAChF,KACJ,MAAK,GACD,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,IAA4B,EAAyB,GAChF,KACJ,MAAK,GACG,IAAI,CAAC,MAAM,CAAC,IACZ,IAAI,CAAC,SAAS,CAAC,IAGf,IAAI,CAAC,MAAM,CAACA,EAAe,OAE/B,KACJ,MAAK,IACG,IAAI,CAAC,MAAM,CAAC,KACZ,IAAI,CAAC,SAAS,CAAC,IAGf,IAAI,CAAC,MAAM,CAACA,EAAe,OAE/B,KAEJ,MAAK,GACL,KAAK,GACL,KAAK,EACL,KAAK,GACL,KAAK,IACD,KACJ,SACI,IAAI,CAAC,OAAO,EACpB,CAIJ,OAFA,IAAI,CAAC,MAAM,CAAG,IAAI,CAAC,QAAQ,CAC3B,IAAI,CAAC,SAAS,CAAC,IACRY,MAAM,IAAI,CAAC,IAAI,CAAC,OAAO,CAClC,CACA,OAAOC,CAAQ,CAAE,OACb,CAAI,IAAI,CAAC,QAAQ,IAGb,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,IAAMA,IAG9C,IAAI,CAAC,QAAQ,GACN,GACX,CACA,UAAW,CACP,OAAO,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,GAC/C,CACA,OAAQ,CACJ,OAAO,IAAI,CAAC,QAAQ,GAAK,EAAwB,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CACzF,CACA,UAAUC,CAAI,CAAE,CACZ,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAEA,KAAAA,EAAM,OAAQ,IAAI,CAAC,MAAM,AAAC,EAClD,CACA,OAAOC,CAAU,CAAE,CACf,IAAMC,EAAS,IAAI,CAAC,MAAM,CACpBC,EAAS,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAE,IAAI,CAAC,QAAQ,EACzDC,EAAW,CAAE,KAAM,GAA0B,OAAQ,IAAI,CAAC,MAAM,CAAED,OAAAA,CAAO,EAC/E,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAED,OAAAA,EAAQC,OAAAA,EAAQ,eAAgBF,CAAW,GAC/D,IAAI,CAAC,OAAO,CAAC,IAAI,CAACG,EACtB,CACA,SAAU,CACN,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAG,IAAI,CAAC,MAAM,CACrC,IAAMC,EAAQ,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,EAC5C,GAAIA,EAAO,CACP,IAAI,CAAC,QAAQ,CAAG,IAAI,CAAC,MAAM,CAAGA,CAAK,CAAC,EAAE,CAAC,MAAM,CAC7C,IAAMF,EAAS,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAE,IAAI,CAAC,QAAQ,EACzDG,EAAUhB,EAAQ,SAAS,CAAC,GAAG,CAACa,GAClCG,EACA,IAAI,CAAC,SAAS,CAACA,GAGf,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAE,KAAM,GAAwBH,OAAAA,EAAQ,OAAQ,IAAI,CAAC,MAAM,AAAC,EAEtF,CACJ,CAEA,eAAgB,CACZ,KAAO,AAAiB,KAAjB,IAAI,CAAC,KAAK,IAAwC,CAAC,IAAI,CAAC,QAAQ,IACnE,IAAI,CAAC,QAAQ,GAEjB,GAAI,IAAI,CAAC,QAAQ,GAAI,CACjB,IAAI,CAAC,MAAM,CAACf,GACZ,MACJ,CAEA,IAAI,CAAC,QAAQ,GACb,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAE,KAAM,GAA8B,OAAQ,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAG,EAAG,IAAI,CAAC,QAAQ,CAAG,GAAI,OAAQ,IAAI,CAAC,MAAM,CAAG,CAAE,EACvJ,CAOA,QAAS,CACL,IAAIN,EAAI,IAAI,CAAC,QAAQ,CACjByB,EAAW,GACXC,EAAmB,GACvB,OAAa,CACT,GAAI1B,GAAK,IAAI,CAAC,MAAM,CAAC,MAAM,CAAE,CACzB,IAAI,CAAC,QAAQ,CAAGA,EAChB,IAAI,CAAC,MAAM,CAACO,GACZ,MACJ,CACA,IAAMK,EAAK,IAAI,CAAC,MAAM,CAAC,UAAU,CAACZ,GAClC,GAAIyB,EACAA,EAAW,QAEV,GAAIb,AAAO,KAAPA,GAAmCc,EAInCd,AAAO,KAAPA,EACLc,EAAmB,GAEdd,AAAO,KAAPA,EACLa,EAAW,GAEC,KAAPb,GACLc,CAAAA,EAAmB,EAAI,MAXmC,CAC1D1B,IACA,KACJ,CAUAA,GACJ,CAEA,KAAOA,EAAI,IAAI,CAAC,MAAM,CAAC,MAAM,EAAIQ,EAAQ,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,CAACR,KAC5EA,GAEJ,KAAI,CAAC,QAAQ,CAAGA,EAChB,IAAMqB,EAAS,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAE,IAAI,CAAC,QAAQ,EAC/D,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAE,KAAM,GAA6BA,OAAAA,EAAQ,OAAQ,IAAI,CAAC,MAAM,AAAC,EACvF,CACA,UAAW,CACP,OAAO,IAAI,CAAC,QAAQ,EAAI,IAAI,CAAC,MAAM,CAAC,MAAM,AAC9C,CACJ,C,eDlRA,IAAMM,EAAkB,IAAId,IAC5Bc,EAAgB,GAAG,CAAC,QAAS,IAC7BA,EAAgB,GAAG,CAAC,OAAQ,IAC5BA,EAAgB,GAAG,CAAC,QAAS,IAAW,EACxCA,EAAgB,GAAG,CAAC,UAAW,IAAO,EACtCA,EAAgB,GAAG,CAAC,YAAa,IAAS,EAC1CA,EAAgB,GAAG,CAAC,QAAS,IAAK,EAClCA,EAAgB,GAAG,CAAC,cAAe,IAAW,EAAI,CAAC,IAAK,EACxDA,EAAgB,GAAG,CAAC,SAAU,IAAM,EACpCA,EAAgB,GAAG,CAAC,YAAa,IAAS,EAC1CA,EAAgB,GAAG,CAAC,WAAY,IAAQ,EACxCA,EAAgB,GAAG,CAAC,WAAY,IAAQ,EACxC,IAAM,EAAiBC,OAAO,SAAS,CAAC,cAAc,CAChDC,EAAgB,CAClB,8BAA+B,EACnC,EACMC,EAAmB,SAAS,sCAAuC,gCACnEC,EAAkB,SAAS,2CAA4C,gIACvEC,EAAoB,SAAS,uCAAwC,qBACrEC,EAA0B,SAAS,6CAA8C,2BACjFC,EAAuB,SAAS,0CAA2C,oBAC3EC,EAAsB,SAAS,+CAAgD,oDAC/EC,EAAqB,SAAS,wCAAyC,gCACvEC,EAAoB,SAAS,6CAA8C,uCAkB1E,OAAMC,EAGT,MAAO,CAAE,IAAI,CAAC,WAAW,CAAG,AAAIC,OAAS,CAAC,AAC1C,YAAYC,EAAUX,CAAa,CAAE,CACjC,IAAI,CAAC,OAAO,CAAGW,EAEf,IAAI,CAAC,QAAQ,CAAG,IAAIhC,EAEpB,IAAI,CAAC,OAAO,CAAG,EAAE,CACjB,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,cAAc,CAAG,EAAE,CACxB,IAAI,CAAC,UAAU,CAAG,MACtB,CAOA,MAAMiC,CAAK,CAAE,CACT,GAAIA,AAAU,KAAVA,EAAc,CACd,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAE,QAASX,EAAkB,OAAQ,EAAG,OAAQ,GAAI,eAAgBC,CAAgB,GAC7G,MACJ,CACA,IAAI,CAAC,OAAO,CAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAACU,GAAO,IAAI,GAE9C,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,cAAc,CAAG,EAAE,CACxB,GAAI,CACA,IAAMC,EAAO,IAAI,CAAC,KAAK,GACvB,GAAI,CAAC,IAAI,CAAC,QAAQ,GAAI,CAClB,IAAMC,EAAO,IAAI,CAAC,KAAK,GACjBC,EAAiBD,AAAc,KAAdA,EAAK,IAAI,CAA8BR,EAAsBU,KAAAA,CAEpF,OADA,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAE,QAASX,EAAsB,OAAQS,EAAK,MAAM,CAAE,OAAQnC,EAAQ,SAAS,CAACmC,GAAOC,eAAAA,CAAe,GACzHN,EAAO,WAAW,AAC5B,CACA,OAAOI,CACX,CACA,MAAOI,EAAG,CACN,GAAMA,IAAMR,EAAO,WAAW,CAC1B,MAAMQ,EAEV,MACJ,CACJ,CACA,OAAQ,CACJ,OAAO,IAAI,CAAC,GAAG,EACnB,CACA,KAAM,CACF,IAAMJ,EAAO,CAAC,IAAI,CAAC,IAAI,GAAG,CAC1B,KAAO,IAAI,CAAC,SAAS,CAAC,KAAwB,CAC1C,IAAMK,EAAQ,IAAI,CAAC,IAAI,GACvBL,EAAK,IAAI,CAACK,EACd,CACA,OAAOL,AAAgB,IAAhBA,EAAK,MAAM,CAASA,CAAI,CAAC,EAAE,CAAGM,EAAe,EAAE,IAAIN,EAC9D,CACA,MAAO,CACH,IAAMA,EAAO,CAAC,IAAI,CAAC,KAAK,GAAG,CAC3B,KAAO,IAAI,CAAC,SAAS,CAAC,KAAyB,CAC3C,IAAMK,EAAQ,IAAI,CAAC,KAAK,GACxBL,EAAK,IAAI,CAACK,EACd,CACA,OAAOL,AAAgB,IAAhBA,EAAK,MAAM,CAASA,CAAI,CAAC,EAAE,CAAGM,EAAe,GAAG,IAAIN,EAC/D,CACA,OAAQ,CACJ,GAAI,IAAI,CAAC,SAAS,CAAC,GAAwB,CACvC,IAAMC,EAAO,IAAI,CAAC,KAAK,GACvB,OAAQA,EAAK,IAAI,EACb,KAAK,GAED,OADA,IAAI,CAAC,QAAQ,GACNM,EAAoB,QAAQ,AACvC,MAAK,GAED,OADA,IAAI,CAAC,QAAQ,GACNC,EAAmB,QAAQ,AACtC,MAAK,EAA0B,CAC3B,IAAI,CAAC,QAAQ,GACb,IAAMR,EAAO,IAAI,CAAC,KAAK,GAEvB,OADA,IAAI,CAAC,QAAQ,CAAC,EAA0BT,GACjCS,GAAM,QACjB,CACA,KAAK,GAED,OADA,IAAI,CAAC,QAAQ,GACNS,EAAkB,MAAM,CAACR,EAAK,MAAM,CAC/C,SACI,MAAM,IAAI,CAAC,kBAAkB,CAAC,0CAA2CA,EACjF,CACJ,CACA,OAAO,IAAI,CAAC,QAAQ,EACxB,CACA,UAAW,CACP,IAAMA,EAAO,IAAI,CAAC,KAAK,GACvB,OAAQA,EAAK,IAAI,EACb,KAAK,GAED,OADA,IAAI,CAAC,QAAQ,GACNK,EAAe,IAAI,EAC9B,MAAK,GAED,OADA,IAAI,CAAC,QAAQ,GACNA,EAAe,KAAK,EAC/B,MAAK,EAA0B,CAC3B,IAAI,CAAC,QAAQ,GACb,IAAMN,EAAO,IAAI,CAAC,KAAK,GAEvB,OADA,IAAI,CAAC,QAAQ,CAAC,EAA0BT,GACjCS,CACX,CACA,KAAK,GAAwB,CAEzB,IAAMU,EAAMT,EAAK,MAAM,CAGvB,GAFA,IAAI,CAAC,QAAQ,GAET,IAAI,CAAC,SAAS,CAAC,GAA4B,CAE3C,IAAMD,EAAO,IAAI,CAAC,KAAK,GACvB,GAAI,CAAC,IAAI,CAAC,OAAO,CAAC,6BAA6B,CAAE,KAQzCW,EANJ,GADA,IAAI,CAAC,QAAQ,GACTX,AAAc,KAAdA,EAAK,IAAI,CACT,MAAM,IAAI,CAAC,kBAAkB,CAAC,QAASA,GAE3C,IAAMY,EAAcZ,EAAK,MAAM,CACzBa,EAAoBD,EAAY,WAAW,CAAC,KAC5CE,EAAQD,IAAsBD,EAAY,MAAM,CAAG,EAAIT,KAAAA,EAAY,IAAI,CAAC,cAAc,CAACS,EAAY,SAAS,CAACC,EAAoB,IAEvI,GAAI,CACAF,EAAS,IAAII,OAAOH,EAAY,SAAS,CAAC,EAAGC,GAAoBC,EACrE,CACA,MAAOV,EAAG,CACN,MAAM,IAAI,CAAC,kBAAkB,CAAC,QAASJ,EAC3C,CACA,OAAOgB,EAAoB,MAAM,CAACN,EAAKC,EAC3C,CACA,OAAQX,EAAK,IAAI,EACb,KAAK,GACL,KAAK,GAA0B,KA0CvBW,EAzCJ,IAAMM,EAAuB,CAACjB,EAAK,MAAM,CAAC,CAC1C,IAAI,CAAC,QAAQ,GACb,IAAIkB,EAAiB,IAAI,CAAC,KAAK,GAC3BC,EAAe,EACnB,IAAK,IAAIC,EAAI,EAAGA,EAAIpB,EAAK,MAAM,CAAC,MAAM,CAAEoB,IAChCpB,AAA8B,KAA9BA,EAAK,MAAM,CAAC,UAAU,CAACoB,GACvBD,IAEmC,KAA9BnB,EAAK,MAAM,CAAC,UAAU,CAACoB,IAC5BD,IAGR,KAAO,CAAC,IAAI,CAAC,QAAQ,IAAMD,AAAwB,KAAxBA,EAAe,IAAI,EAA+BA,AAAwB,KAAxBA,EAAe,IAAI,EAA4B,CACxH,OAAQA,EAAe,IAAI,EACvB,KAAK,EACDC,IACA,KACJ,MAAK,EACDA,IACA,KACJ,MAAK,GACL,KAAK,GACD,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAe,MAAM,CAAC,MAAM,CAAEE,IAC1CF,AAAwC,KAAxCA,EAAe,MAAM,CAAC,UAAU,CAACE,GACjCD,IAEmC,KAA9BnB,EAAK,MAAM,CAAC,UAAU,CAACoB,IAC5BD,GAGhB,CACA,GAAIA,EAAe,EACf,MAEJF,EAAqB,IAAI,CAACnD,EAAQ,SAAS,CAACoD,IAC5C,IAAI,CAAC,QAAQ,GACbA,EAAiB,IAAI,CAAC,KAAK,EAC/B,CACA,IAAMN,EAAcK,EAAqB,IAAI,CAAC,IACxCJ,EAAoBD,EAAY,WAAW,CAAC,KAC5CE,EAAQD,IAAsBD,EAAY,MAAM,CAAG,EAAIT,KAAAA,EAAY,IAAI,CAAC,cAAc,CAACS,EAAY,SAAS,CAACC,EAAoB,IAEvI,GAAI,CACAF,EAAS,IAAII,OAAOH,EAAY,SAAS,CAAC,EAAGC,GAAoBC,EACrE,CACA,MAAOV,EAAG,CACN,MAAM,IAAI,CAAC,kBAAkB,CAAC,QAASJ,EAC3C,CACA,OAAOM,EAAe,KAAK,CAACI,EAAKC,EACrC,CACA,KAAK,GAA8B,CAC/B,IAAMU,EAAkBrB,EAAK,MAAM,CACnC,IAAI,CAAC,QAAQ,GAEb,IAAIsB,EAAQ,KACZ,GAAI,CAAC,SAAoBD,GAAkB,CACvC,IAAME,EAAQF,EAAgB,OAAO,CAAC,KAChCG,EAAMH,EAAgB,WAAW,CAAC,KACxC,GAAIE,IAAUC,GAAOD,GAAS,EAAG,CAC7B,IAAMnD,EAAQiD,EAAgB,KAAK,CAACE,EAAQ,EAAGC,GACzCC,EAAiBJ,AAA6B,MAA7BA,CAAe,CAACG,EAAM,EAAE,CAAW,IAAM,GAChE,GAAI,CACAF,EAAQ,IAAIP,OAAO3C,EAAOqD,EAC9B,CACA,MAAOC,EAAI,CACP,MAAM,IAAI,CAAC,kBAAkB,CAAC,QAAS1B,EAC3C,CACJ,CACJ,CACA,GAAIsB,AAAU,OAAVA,EACA,MAAM,IAAI,CAAC,kBAAkB,CAAC,QAAStB,GAE3C,OAAOgB,EAAoB,MAAM,CAACN,EAAKY,EAC3C,CACA,QACI,MAAM,IAAI,CAAC,kBAAkB,CAAC,QAAS,IAAI,CAAC,KAAK,GACzD,CACJ,CAEA,GAAI,IAAI,CAAC,SAAS,CAAC,IAAyB,CACxC,IAAI,CAAC,QAAQ,CAAC,GAAuBhC,GACrC,IAAMe,EAAQ,IAAI,CAAC,MAAM,GACzB,OAAOC,EAAe,KAAK,CAACI,EAAKL,EACrC,CAGA,OADgB,IAAI,CAAC,KAAK,GAAG,IAAI,EAE7B,KAAK,EAAsB,CACvB,IAAI,CAAC,QAAQ,GACb,IAAMA,EAAQ,IAAI,CAAC,MAAM,GACzB,GAAI,AAA0B,KAA1B,IAAI,CAAC,SAAS,GAAG,IAAI,CACrB,OAAOC,EAAe,MAAM,CAACI,EAAKL,GAEtC,OAAQA,GACJ,IAAK,OACD,OAAOC,EAAe,GAAG,CAACI,EAC9B,KAAK,QACD,OAAOJ,EAAe,GAAG,CAACI,EAC9B,SACI,OAAOJ,EAAe,MAAM,CAACI,EAAKL,EAC1C,CACJ,CACA,KAAK,EAAyB,CAC1B,IAAI,CAAC,QAAQ,GACb,IAAMA,EAAQ,IAAI,CAAC,MAAM,GACzB,GAAI,AAA0B,KAA1B,IAAI,CAAC,SAAS,GAAG,IAAI,CACrB,OAAOC,EAAe,SAAS,CAACI,EAAKL,GAEzC,OAAQA,GACJ,IAAK,OACD,OAAOC,EAAe,GAAG,CAACI,EAC9B,KAAK,QACD,OAAOJ,EAAe,GAAG,CAACI,EAC9B,SACI,OAAOJ,EAAe,SAAS,CAACI,EAAKL,EAC7C,CACJ,CAGA,KAAK,EAED,OADA,IAAI,CAAC,QAAQ,GACNsB,EAAsB,MAAM,CAACjB,EAAK,IAAI,CAAC,MAAM,GACxD,MAAK,EAED,OADA,IAAI,CAAC,QAAQ,GACNkB,EAA4B,MAAM,CAAClB,EAAK,IAAI,CAAC,MAAM,GAC9D,MAAK,EAED,OADA,IAAI,CAAC,QAAQ,GACNmB,EAAsB,MAAM,CAACnB,EAAK,IAAI,CAAC,MAAM,GACxD,MAAK,EAED,OADA,IAAI,CAAC,QAAQ,GACNoB,EAA4B,MAAM,CAACpB,EAAK,IAAI,CAAC,MAAM,GAC9D,MAAK,GAED,OADA,IAAI,CAAC,QAAQ,GACNJ,EAAe,EAAE,CAACI,EAAK,IAAI,CAAC,MAAM,GAC7C,SACI,OAAOJ,EAAe,GAAG,CAACI,EAClC,CACJ,CACA,KAAK,GAED,MADA,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAE,QAAShB,EAAoB,OAAQO,EAAK,MAAM,CAAE,OAAQ,GAAI,eAAgBN,CAAkB,GACrHC,EAAO,WAAW,AAC5B,SACI,MAAM,IAAI,CAAC,kBAAkB,CAAC,CAAC;AAAqB;AAAqB,wEAAyE,CAAC,CAAE,IAAI,CAAC,KAAK,GACvK,CACJ,CACA,QAAS,CACL,IAAM7B,EAAQ,IAAI,CAAC,KAAK,GACxB,OAAQA,EAAM,IAAI,EACd,KAAK,GACL,KAAK,GAED,OADA,IAAI,CAAC,QAAQ,GACNA,EAAM,MAAM,AACvB,MAAK,GAED,OADA,IAAI,CAAC,QAAQ,GACN,MACX,MAAK,GAED,OADA,IAAI,CAAC,QAAQ,GACN,OACX,MAAK,GAED,OADA,IAAI,CAAC,QAAQ,GACN,IACX,SAGI,MAAO,EACf,CACJ,CACA,eAAe+C,CAAK,CAAE,CAClB,OAAOA,EAAM,UAAU,CAAC,IAAI,CAAC,UAAU,CAAE,GAC7C,CAEA,WAAY,CACR,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAG,EAAE,AAC1C,CACA,UAAU/C,CAAK,CAAE,OACb,EAAI,IAAI,CAAC,MAAM,CAACA,KACZ,IAAI,CAAC,QAAQ,GACN,GAGf,CACA,UAAW,CAIP,MAHI,CAAC,IAAI,CAAC,QAAQ,IACd,IAAI,CAAC,QAAQ,GAEV,IAAI,CAAC,SAAS,EACzB,CACA,SAASS,CAAI,CAAEuD,CAAO,CAAE,CACpB,GAAI,IAAI,CAAC,MAAM,CAACvD,GACZ,OAAO,IAAI,CAAC,QAAQ,EAExB,OAAM,IAAI,CAAC,kBAAkB,CAACuD,EAAS,IAAI,CAAC,KAAK,GACrD,CACA,mBAAmBxD,CAAQ,CAAEyD,CAAG,CAAE9B,CAAc,CAAE,CAC9C,IAAM6B,EAAU,SAAS,yCAA0C,kCAAmCxD,EAAUT,EAAQ,SAAS,CAACkE,IAC5HtD,EAASsD,EAAI,MAAM,CACnBrD,EAASb,EAAQ,SAAS,CAACkE,GAEjC,OADA,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAED,QAAAA,EAASrD,OAAAA,EAAQC,OAAAA,EAAQuB,eAAAA,CAAe,GAC5DN,EAAO,WAAW,AAC7B,CACA,OAAOpB,CAAI,CAAE,CACT,OAAO,IAAI,CAAC,KAAK,GAAG,IAAI,GAAKA,CACjC,CACA,OAAQ,CACJ,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,AACtC,CACA,UAAW,CACP,OAAO,AAAsB,KAAtB,IAAI,CAAC,KAAK,GAAG,IAAI,AAC5B,CACJ,CACO,MAAM8B,EACT,OAAO,OAAQ,CACX,OAAOC,EAAoB,QAAQ,AACvC,CACA,OAAO,MAAO,CACV,OAAOC,EAAmB,QAAQ,AACtC,CACA,OAAO,IAAIE,CAAG,CAAE,CACZ,OAAOuB,EAAsB,MAAM,CAACvB,EACxC,CACA,OAAO,OAAOA,CAAG,CAAEtC,CAAK,CAAE,CACtB,OAAO8D,EAAqB,MAAM,CAACxB,EAAKtC,EAC5C,CACA,OAAO,UAAUsC,CAAG,CAAEtC,CAAK,CAAE,CACzB,OAAO+D,EAAwB,MAAM,CAACzB,EAAKtC,EAC/C,CACA,OAAO,MAAMsC,CAAG,CAAEtC,CAAK,CAAE,CACrB,OAAO4C,EAAoB,MAAM,CAACN,EAAKtC,EAC3C,CACA,OAAO,GAAGsC,CAAG,CAAEtC,CAAK,CAAE,CAClB,OAAOgE,EAAiB,MAAM,CAAC1B,EAAKtC,EACxC,CACA,OAAO,MAAMsC,CAAG,CAAEtC,CAAK,CAAE,CACrB,OAAOiE,EAAoB,MAAM,CAAC3B,EAAKtC,EAC3C,CACA,OAAO,IAAIsC,CAAG,CAAE,CACZ,OAAOD,EAAkB,MAAM,CAACC,EACpC,CACA,OAAO,IAAI,GAAGV,CAAI,CAAE,CAChB,OAAOsC,EAAkB,MAAM,CAACtC,EAAM,KAAM,GAChD,CACA,OAAO,GAAG,GAAGA,CAAI,CAAE,CACf,OAAOuC,EAAiB,MAAM,CAACvC,EAAM,KAAM,GAC/C,CACA,MAAO,CAAE,IAAI,CAAC,OAAO,CAAG,IAAIJ,EAAO,CAAE,8BAA+B,EAAM,EAAI,CAAC,AAC/E,OAAO,YAAY4C,CAAU,CAAE,CAC3B,GAAIA,MAAAA,EAIJ,OADa,IAAI,CAAC,OAAO,CAAC,KAAK,CAACA,EAEpC,CACJ,CACO,SAASC,EAA4CC,CAAC,CAAEC,CAAC,EAC5D,IAAMC,EAAQF,EAAIA,EAAE,mBAAmB,GAAKvC,KAAAA,EACtC0C,EAAQF,EAAIA,EAAE,mBAAmB,GAAKxC,KAAAA,QAC5C,CAAKyC,IAAUC,KAGVD,KAAUC,GAGRD,EAAM,MAAM,CAACC,EACxB,CACA,SAAS,EAAIH,CAAC,CAAEC,CAAC,EACb,OAAOD,EAAE,GAAG,CAACC,EACjB,CACO,MAAMpC,EACT,MAAO,CAAE,IAAI,CAAC,QAAQ,CAAG,IAAIA,CAAuB,CAAC,AACrD,aAAc,CACV,IAAI,CAAC,IAAI,CAAG,CAChB,CACA,IAAIuC,CAAK,CAAE,CACP,OAAO,IAAI,CAAC,IAAI,CAAGA,EAAM,IAAI,AACjC,CACA,OAAOA,CAAK,CAAE,CACV,OAAQA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,AACpC,CACA,qBAAsB,CAClB,OAAO,IAAI,AACf,CACA,SAASC,CAAO,CAAE,CACd,MAAO,EACX,CACA,WAAY,CACR,MAAO,OACX,CACA,MAAO,CACH,MAAO,EAAE,AACb,CACA,QAAS,CACL,OAAOvC,EAAmB,QAAQ,AACtC,CACJ,CACO,MAAMA,EACT,MAAO,CAAE,IAAI,CAAC,QAAQ,CAAG,IAAIA,CAAsB,CAAC,AACpD,aAAc,CACV,IAAI,CAAC,IAAI,CAAG,CAChB,CACA,IAAIsC,CAAK,CAAE,CACP,OAAO,IAAI,CAAC,IAAI,CAAGA,EAAM,IAAI,AACjC,CACA,OAAOA,CAAK,CAAE,CACV,OAAQA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,AACpC,CACA,qBAAsB,CAClB,OAAO,IAAI,AACf,CACA,SAASC,CAAO,CAAE,CACd,MAAO,EACX,CACA,WAAY,CACR,MAAO,MACX,CACA,MAAO,CACH,MAAO,EAAE,AACb,CACA,QAAS,CACL,OAAOxC,EAAoB,QAAQ,AACvC,CACJ,CACO,MAAM0B,EACT,OAAO,OAAOvB,CAAG,CAAEsC,EAAU,IAAI,CAAE,CAC/B,IAAMC,EAAgBhE,EAAgB,GAAG,CAACyB,SAC1C,AAAI,AAAyB,WAAzB,OAAOuC,EACAA,EAAgBzC,EAAmB,QAAQ,CAAGD,EAAoB,QAAQ,CAE9E,IAAI0B,EAAsBvB,EAAKsC,EAC1C,CACA,YAAYtC,CAAG,CAAEsC,CAAO,CAAE,CACtB,IAAI,CAAC,GAAG,CAAGtC,EACX,IAAI,CAAC,OAAO,CAAGsC,EACf,IAAI,CAAC,IAAI,CAAG,CAChB,CACA,IAAIF,CAAK,CAAE,QACP,AAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,CACjB,IAAI,CAAC,IAAI,CAAGA,EAAM,IAAI,CAE1BI,AAu6Bf,SAAcC,CAAI,CAAEC,CAAI,SACpB,AAAID,EAAOC,EACA,IAEPD,CAAAA,EAAOC,CAAG,CAIlB,EA/6BoB,IAAI,CAAC,GAAG,CAAEN,EAAM,GAAG,CACnC,CACA,OAAOA,CAAK,CAAE,QACV,AAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,EAChB,IAAI,CAAC,GAAG,GAAKA,EAAM,GAAG,AAGtC,CACA,qBAAsB,CAClB,IAAMG,EAAgBhE,EAAgB,GAAG,CAAC,IAAI,CAAC,GAAG,QAClD,AAAI,AAAyB,WAAzB,OAAOgE,EACAA,EAAgBzC,EAAmB,QAAQ,CAAGD,EAAoB,QAAQ,CAE9E,IAAI,AACf,CACA,SAASwC,CAAO,CAAE,CACd,MAAQ,CAAC,CAACA,EAAQ,QAAQ,CAAC,IAAI,CAAC,GAAG,CACvC,CACA,WAAY,CACR,OAAO,IAAI,CAAC,GAAG,AACnB,CACA,MAAO,CACH,MAAO,CAAC,IAAI,CAAC,GAAG,CAAC,AACrB,CACA,QAAS,CAIL,OAHK,IAAI,CAAC,OAAO,EACb,KAAI,CAAC,OAAO,CAAGtC,EAAkB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAE,IAAI,GAEnD,IAAI,CAAC,OAAO,AACvB,CACJ,CACO,MAAMyB,EACT,OAAO,OAAOxB,CAAG,CAAEtC,CAAK,CAAE4E,EAAU,IAAI,CAAE,CACtC,GAAI,AAAiB,WAAjB,OAAO5E,EACP,OAAQA,EAAQ6D,EAAsB,MAAM,CAACvB,EAAKsC,GAAWvC,EAAkB,MAAM,CAACC,EAAKsC,GAE/F,IAAMC,EAAgBhE,EAAgB,GAAG,CAACyB,SAC1C,AAAI,AAAyB,WAAzB,OAAOuC,EAEC7E,IADU6E,CAAAA,EAAgB,OAAS,OAAM,EACnBzC,EAAmB,QAAQ,CAAGD,EAAoB,QAAQ,CAErF,IAAI2B,EAAqBxB,EAAKtC,EAAO4E,EAChD,CACA,YAAYtC,CAAG,CAAEtC,CAAK,CAAE4E,CAAO,CAAE,CAC7B,IAAI,CAAC,GAAG,CAAGtC,EACX,IAAI,CAAC,KAAK,CAAGtC,EACb,IAAI,CAAC,OAAO,CAAG4E,EACf,IAAI,CAAC,IAAI,CAAG,CAChB,CACA,IAAIF,CAAK,CAAE,QACP,AAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,CACjB,IAAI,CAAC,IAAI,CAAGA,EAAM,IAAI,CAE1BO,EAAK,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,KAAK,CAAEP,EAAM,GAAG,CAAEA,EAAM,KAAK,CAC5D,CACA,OAAOA,CAAK,CAAE,QACV,AAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,EAChB,IAAI,CAAC,GAAG,GAAKA,EAAM,GAAG,EAAI,IAAI,CAAC,KAAK,GAAKA,EAAM,KAAK,AAGpE,CACA,qBAAsB,CAClB,IAAMG,EAAgBhE,EAAgB,GAAG,CAAC,IAAI,CAAC,GAAG,QAClD,AAAI,AAAyB,WAAzB,OAAOgE,EAEC,IAAI,CAAC,KAAK,GADAA,CAAAA,EAAgB,OAAS,OAAM,EACdzC,EAAmB,QAAQ,CAAGD,EAAoB,QAAQ,CAE1F,IAAI,AACf,CACA,SAASwC,CAAO,CAAE,CAGd,OAAQA,EAAQ,QAAQ,CAAC,IAAI,CAAC,GAAG,GAAK,IAAI,CAAC,KAAK,AACpD,CACA,WAAY,CACR,MAAO,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,AAC3C,CACA,MAAO,CACH,MAAO,CAAC,IAAI,CAAC,GAAG,CAAC,AACrB,CACA,QAAS,CAIL,OAHK,IAAI,CAAC,OAAO,EACb,KAAI,CAAC,OAAO,CAAGZ,EAAwB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,KAAK,CAAE,IAAI,GAErE,IAAI,CAAC,OAAO,AACvB,CACJ,CACO,MAAMC,EACT,OAAO,OAAO1B,CAAG,CAAE4C,CAAQ,CAAE,CACzB,OAAO,IAAIlB,EAAiB1B,EAAK4C,EACrC,CACA,YAAY5C,CAAG,CAAE4C,CAAQ,CAAE,CACvB,IAAI,CAAC,GAAG,CAAG5C,EACX,IAAI,CAAC,QAAQ,CAAG4C,EAChB,IAAI,CAAC,IAAI,CAAG,GACZ,IAAI,CAAC,OAAO,CAAG,IACnB,CACA,IAAIR,CAAK,CAAE,QACP,AAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,CACjB,IAAI,CAAC,IAAI,CAAGA,EAAM,IAAI,CAE1BO,EAAK,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,QAAQ,CAAEP,EAAM,GAAG,CAAEA,EAAM,QAAQ,CAClE,CACA,OAAOA,CAAK,CAAE,QACV,AAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,EAChB,IAAI,CAAC,GAAG,GAAKA,EAAM,GAAG,EAAI,IAAI,CAAC,QAAQ,GAAKA,EAAM,QAAQ,AAG1E,CACA,qBAAsB,CAClB,OAAO,IAAI,AACf,CACA,SAASC,CAAO,CAAE,CACd,IAAMQ,EAASR,EAAQ,QAAQ,CAAC,IAAI,CAAC,QAAQ,EACvCS,EAAOT,EAAQ,QAAQ,CAAC,IAAI,CAAC,GAAG,SACtC,AAAIzE,MAAM,OAAO,CAACiF,GACPA,EAAO,QAAQ,CAACC,GAEP,UAAhB,OAAOA,GAAqB,AAAkB,UAAlB,OAAOD,GAAuBA,AAAW,OAAXA,GACnD,EAAe,IAAI,CAACA,EAAQC,EAG3C,CACA,WAAY,CACR,MAAO,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,AAC9C,CACA,MAAO,CACH,MAAO,CAAC,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,QAAQ,CAAC,AACpC,CACA,QAAS,CAIL,OAHK,IAAI,CAAC,OAAO,EACb,KAAI,CAAC,OAAO,CAAGnB,EAAoB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,QAAQ,GAE9D,IAAI,CAAC,OAAO,AACvB,CACJ,CACO,MAAMA,EACT,OAAO,OAAO3B,CAAG,CAAE4C,CAAQ,CAAE,CACzB,OAAO,IAAIjB,EAAoB3B,EAAK4C,EACxC,CACA,YAAY5C,CAAG,CAAE4C,CAAQ,CAAE,CACvB,IAAI,CAAC,GAAG,CAAG5C,EACX,IAAI,CAAC,QAAQ,CAAG4C,EAChB,IAAI,CAAC,IAAI,CAAG,GACZ,IAAI,CAAC,QAAQ,CAAGlB,EAAiB,MAAM,CAAC1B,EAAK4C,EACjD,CACA,IAAIR,CAAK,CAAE,QACP,AAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,CACjB,IAAI,CAAC,IAAI,CAAGA,EAAM,IAAI,CAE1B,IAAI,CAAC,QAAQ,CAAC,GAAG,CAACA,EAAM,QAAQ,CAC3C,CACA,OAAOA,CAAK,CAAE,QACV,AAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,EACjB,IAAI,CAAC,QAAQ,CAAC,MAAM,CAACA,EAAM,QAAQ,CAGlD,CACA,qBAAsB,CAClB,OAAO,IAAI,AACf,CACA,SAASC,CAAO,CAAE,CACd,MAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAACA,EACnC,CACA,WAAY,CACR,MAAO,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,AAClD,CACA,MAAO,CACH,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,EAC7B,CACA,QAAS,CACL,OAAO,IAAI,CAAC,QAAQ,AACxB,CACJ,CACO,MAAMZ,EACT,OAAO,OAAOzB,CAAG,CAAEtC,CAAK,CAAE4E,EAAU,IAAI,CAAE,CACtC,GAAI,AAAiB,WAAjB,OAAO5E,SACP,AAAIA,EACOqC,EAAkB,MAAM,CAACC,EAAKsC,GAElCf,EAAsB,MAAM,CAACvB,EAAKsC,GAE7C,IAAMC,EAAgBhE,EAAgB,GAAG,CAACyB,SAC1C,AAAI,AAAyB,WAAzB,OAAOuC,EAEC7E,IADW6E,CAAAA,EAAgB,OAAS,OAAM,EACnB1C,EAAoB,QAAQ,CAAGC,EAAmB,QAAQ,CAEtF,IAAI2B,EAAwBzB,EAAKtC,EAAO4E,EACnD,CACA,YAAYtC,CAAG,CAAEtC,CAAK,CAAE4E,CAAO,CAAE,CAC7B,IAAI,CAAC,GAAG,CAAGtC,EACX,IAAI,CAAC,KAAK,CAAGtC,EACb,IAAI,CAAC,OAAO,CAAG4E,EACf,IAAI,CAAC,IAAI,CAAG,CAChB,CACA,IAAIF,CAAK,CAAE,QACP,AAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,CACjB,IAAI,CAAC,IAAI,CAAGA,EAAM,IAAI,CAE1BO,EAAK,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,KAAK,CAAEP,EAAM,GAAG,CAAEA,EAAM,KAAK,CAC5D,CACA,OAAOA,CAAK,CAAE,QACV,AAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,EAChB,IAAI,CAAC,GAAG,GAAKA,EAAM,GAAG,EAAI,IAAI,CAAC,KAAK,GAAKA,EAAM,KAAK,AAGpE,CACA,qBAAsB,CAClB,IAAMG,EAAgBhE,EAAgB,GAAG,CAAC,IAAI,CAAC,GAAG,QAClD,AAAI,AAAyB,WAAzB,OAAOgE,EAEC,IAAI,CAAC,KAAK,GADCA,CAAAA,EAAgB,OAAS,OAAM,EACd1C,EAAoB,QAAQ,CAAGC,EAAmB,QAAQ,CAE3F,IAAI,AACf,CACA,SAASuC,CAAO,CAAE,CAGd,OAAQA,EAAQ,QAAQ,CAAC,IAAI,CAAC,GAAG,GAAK,IAAI,CAAC,KAAK,AACpD,CACA,WAAY,CACR,MAAO,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,AAC3C,CACA,MAAO,CACH,MAAO,CAAC,IAAI,CAAC,GAAG,CAAC,AACrB,CACA,QAAS,CAIL,OAHK,IAAI,CAAC,OAAO,EACb,KAAI,CAAC,OAAO,CAAGb,EAAqB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,KAAK,CAAE,IAAI,GAElE,IAAI,CAAC,OAAO,AACvB,CACJ,CACO,MAAMzB,EACT,OAAO,OAAOC,CAAG,CAAEsC,EAAU,IAAI,CAAE,CAC/B,IAAMC,EAAgBhE,EAAgB,GAAG,CAACyB,SAC1C,AAAI,AAAyB,WAAzB,OAAOuC,EACCA,EAAgB1C,EAAoB,QAAQ,CAAGC,EAAmB,QAAQ,CAE/E,IAAIC,EAAkBC,EAAKsC,EACtC,CACA,YAAYtC,CAAG,CAAEsC,CAAO,CAAE,CACtB,IAAI,CAAC,GAAG,CAAGtC,EACX,IAAI,CAAC,OAAO,CAAGsC,EACf,IAAI,CAAC,IAAI,CAAG,CAChB,CACA,IAAIF,CAAK,CAAE,QACP,AAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,CACjB,IAAI,CAAC,IAAI,CAAGA,EAAM,IAAI,CAE1BI,AA6qBf,SAAcC,CAAI,CAAEC,CAAI,SACpB,AAAID,EAAOC,EACA,IAEPD,CAAAA,EAAOC,CAAG,CAIlB,EArrBoB,IAAI,CAAC,GAAG,CAAEN,EAAM,GAAG,CACnC,CACA,OAAOA,CAAK,CAAE,QACV,AAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,EAChB,IAAI,CAAC,GAAG,GAAKA,EAAM,GAAG,AAGtC,CACA,qBAAsB,CAClB,IAAMG,EAAgBhE,EAAgB,GAAG,CAAC,IAAI,CAAC,GAAG,QAClD,AAAI,AAAyB,WAAzB,OAAOgE,EACCA,EAAgB1C,EAAoB,QAAQ,CAAGC,EAAmB,QAAQ,CAE/E,IAAI,AACf,CACA,SAASuC,CAAO,CAAE,CACd,MAAQ,CAACA,EAAQ,QAAQ,CAAC,IAAI,CAAC,GAAG,CACtC,CACA,WAAY,CACR,MAAO,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,AACzB,CACA,MAAO,CACH,MAAO,CAAC,IAAI,CAAC,GAAG,CAAC,AACrB,CACA,QAAS,CAIL,OAHK,IAAI,CAAC,OAAO,EACb,KAAI,CAAC,OAAO,CAAGd,EAAsB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAE,IAAI,GAEvD,IAAI,CAAC,OAAO,AACvB,CACJ,CACA,SAASwB,EAAerF,CAAK,CAAEsF,CAAQ,EACnC,GAAI,AAAiB,UAAjB,OAAOtF,EAAoB,CAC3B,IAAMuF,EAAIC,WAAWxF,GAChByF,MAAMF,IACPvF,CAAAA,EAAQuF,CAAAA,CAEhB,OACA,AAAI,AAAiB,UAAjB,OAAOvF,GAAsB,AAAiB,UAAjB,OAAOA,EAC7BsF,EAAStF,GAEbmC,EAAoB,QAAQ,AACvC,CACO,MAAMsB,EACT,OAAO,OAAOnB,CAAG,CAAEoD,CAAM,CAAEd,EAAU,IAAI,CAAE,CACvC,OAAOS,EAAeK,EAAQ,AAAC1F,GAAU,IAAIyD,EAAsBnB,EAAKtC,EAAO4E,GACnF,CACA,YAAYtC,CAAG,CAAEtC,CAAK,CAAE4E,CAAO,CAAE,CAC7B,IAAI,CAAC,GAAG,CAAGtC,EACX,IAAI,CAAC,KAAK,CAAGtC,EACb,IAAI,CAAC,OAAO,CAAG4E,EACf,IAAI,CAAC,IAAI,CAAG,EAChB,CACA,IAAIF,CAAK,CAAE,QACP,AAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,CACjB,IAAI,CAAC,IAAI,CAAGA,EAAM,IAAI,CAE1BO,EAAK,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,KAAK,CAAEP,EAAM,GAAG,CAAEA,EAAM,KAAK,CAC5D,CACA,OAAOA,CAAK,CAAE,QACV,AAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,EAChB,IAAI,CAAC,GAAG,GAAKA,EAAM,GAAG,EAAI,IAAI,CAAC,KAAK,GAAKA,EAAM,KAAK,AAGpE,CACA,qBAAsB,CAClB,OAAO,IAAI,AACf,CACA,SAASC,CAAO,CAAE,OACd,AAA0B,UAAtB,OAAO,IAAI,CAAC,KAAK,EAGba,WAAWb,EAAQ,QAAQ,CAAC,IAAI,CAAC,GAAG,GAAK,IAAI,CAAC,KAAK,AAC/D,CACA,WAAY,CACR,MAAO,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,AACxC,CACA,MAAO,CACH,MAAO,CAAC,IAAI,CAAC,GAAG,CAAC,AACrB,CACA,QAAS,CAIL,OAHK,IAAI,CAAC,OAAO,EACb,KAAI,CAAC,OAAO,CAAGnB,EAA4B,MAAM,CAAC,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,KAAK,CAAE,IAAI,GAEzE,IAAI,CAAC,OAAO,AACvB,CACJ,CACO,MAAME,EACT,OAAO,OAAOpB,CAAG,CAAEoD,CAAM,CAAEd,EAAU,IAAI,CAAE,CACvC,OAAOS,EAAeK,EAAQ,AAAC1F,GAAU,IAAI0D,EAA4BpB,EAAKtC,EAAO4E,GACzF,CACA,YAAYtC,CAAG,CAAEtC,CAAK,CAAE4E,CAAO,CAAE,CAC7B,IAAI,CAAC,GAAG,CAAGtC,EACX,IAAI,CAAC,KAAK,CAAGtC,EACb,IAAI,CAAC,OAAO,CAAG4E,EACf,IAAI,CAAC,IAAI,CAAG,EAChB,CACA,IAAIF,CAAK,CAAE,QACP,AAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,CACjB,IAAI,CAAC,IAAI,CAAGA,EAAM,IAAI,CAE1BO,EAAK,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,KAAK,CAAEP,EAAM,GAAG,CAAEA,EAAM,KAAK,CAC5D,CACA,OAAOA,CAAK,CAAE,QACV,AAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,EAChB,IAAI,CAAC,GAAG,GAAKA,EAAM,GAAG,EAAI,IAAI,CAAC,KAAK,GAAKA,EAAM,KAAK,AAGpE,CACA,qBAAsB,CAClB,OAAO,IAAI,AACf,CACA,SAASC,CAAO,CAAE,OACd,AAA0B,UAAtB,OAAO,IAAI,CAAC,KAAK,EAGba,WAAWb,EAAQ,QAAQ,CAAC,IAAI,CAAC,GAAG,IAAM,IAAI,CAAC,KAAK,AAChE,CACA,WAAY,CACR,MAAO,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,AACzC,CACA,MAAO,CACH,MAAO,CAAC,IAAI,CAAC,GAAG,CAAC,AACrB,CACA,QAAS,CAIL,OAHK,IAAI,CAAC,OAAO,EACb,KAAI,CAAC,OAAO,CAAGpB,EAAsB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,KAAK,CAAE,IAAI,GAEnE,IAAI,CAAC,OAAO,AACvB,CACJ,CACO,MAAMA,EACT,OAAO,OAAOjB,CAAG,CAAEoD,CAAM,CAAEd,EAAU,IAAI,CAAE,CACvC,OAAOS,EAAeK,EAAQ,AAAC1F,GAAU,IAAIuD,EAAsBjB,EAAKtC,EAAO4E,GACnF,CACA,YAAYtC,CAAG,CAAEtC,CAAK,CAAE4E,CAAO,CAAE,CAC7B,IAAI,CAAC,GAAG,CAAGtC,EACX,IAAI,CAAC,KAAK,CAAGtC,EACb,IAAI,CAAC,OAAO,CAAG4E,EACf,IAAI,CAAC,IAAI,CAAG,EAChB,CACA,IAAIF,CAAK,CAAE,QACP,AAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,CACjB,IAAI,CAAC,IAAI,CAAGA,EAAM,IAAI,CAE1BO,EAAK,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,KAAK,CAAEP,EAAM,GAAG,CAAEA,EAAM,KAAK,CAC5D,CACA,OAAOA,CAAK,CAAE,QACV,AAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,EAChB,IAAI,CAAC,GAAG,GAAKA,EAAM,GAAG,EAAI,IAAI,CAAC,KAAK,GAAKA,EAAM,KAAK,AAGpE,CACA,qBAAsB,CAClB,OAAO,IAAI,AACf,CACA,SAASC,CAAO,CAAE,OACd,AAA0B,UAAtB,OAAO,IAAI,CAAC,KAAK,EAGba,WAAWb,EAAQ,QAAQ,CAAC,IAAI,CAAC,GAAG,GAAK,IAAI,CAAC,KAAK,AAC/D,CACA,WAAY,CACR,MAAO,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,AACxC,CACA,MAAO,CACH,MAAO,CAAC,IAAI,CAAC,GAAG,CAAC,AACrB,CACA,QAAS,CAIL,OAHK,IAAI,CAAC,OAAO,EACb,KAAI,CAAC,OAAO,CAAGjB,EAA4B,MAAM,CAAC,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,KAAK,CAAE,IAAI,GAEzE,IAAI,CAAC,OAAO,AACvB,CACJ,CACO,MAAMF,EACT,OAAO,OAAOlB,CAAG,CAAEoD,CAAM,CAAEd,EAAU,IAAI,CAAE,CACvC,OAAOS,EAAeK,EAAQ,AAAC1F,GAAU,IAAIwD,EAA4BlB,EAAKtC,EAAO4E,GACzF,CACA,YAAYtC,CAAG,CAAEtC,CAAK,CAAE4E,CAAO,CAAE,CAC7B,IAAI,CAAC,GAAG,CAAGtC,EACX,IAAI,CAAC,KAAK,CAAGtC,EACb,IAAI,CAAC,OAAO,CAAG4E,EACf,IAAI,CAAC,IAAI,CAAG,EAChB,CACA,IAAIF,CAAK,CAAE,QACP,AAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,CACjB,IAAI,CAAC,IAAI,CAAGA,EAAM,IAAI,CAE1BO,EAAK,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,KAAK,CAAEP,EAAM,GAAG,CAAEA,EAAM,KAAK,CAC5D,CACA,OAAOA,CAAK,CAAE,QACV,AAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,EAChB,IAAI,CAAC,GAAG,GAAKA,EAAM,GAAG,EAAI,IAAI,CAAC,KAAK,GAAKA,EAAM,KAAK,AAGpE,CACA,qBAAsB,CAClB,OAAO,IAAI,AACf,CACA,SAASC,CAAO,CAAE,OACd,AAA0B,UAAtB,OAAO,IAAI,CAAC,KAAK,EAGba,WAAWb,EAAQ,QAAQ,CAAC,IAAI,CAAC,GAAG,IAAM,IAAI,CAAC,KAAK,AAChE,CACA,WAAY,CACR,MAAO,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,AACzC,CACA,MAAO,CACH,MAAO,CAAC,IAAI,CAAC,GAAG,CAAC,AACrB,CACA,QAAS,CAIL,OAHK,IAAI,CAAC,OAAO,EACb,KAAI,CAAC,OAAO,CAAGlB,EAAsB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,KAAK,CAAE,IAAI,GAEnE,IAAI,CAAC,OAAO,AACvB,CACJ,CACO,MAAMb,EACT,OAAO,OAAON,CAAG,CAAEC,CAAM,CAAE,CACvB,OAAO,IAAIK,EAAoBN,EAAKC,EACxC,CACA,YAAYD,CAAG,CAAEC,CAAM,CAAE,CACrB,IAAI,CAAC,GAAG,CAAGD,EACX,IAAI,CAAC,MAAM,CAAGC,EACd,IAAI,CAAC,IAAI,CAAG,EACZ,IAAI,CAAC,OAAO,CAAG,IAEnB,CACA,IAAImC,CAAK,CAAE,CACP,GAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,CACxB,OAAO,IAAI,CAAC,IAAI,CAAGA,EAAM,IAAI,CAEjC,GAAI,IAAI,CAAC,GAAG,CAAGA,EAAM,GAAG,CACpB,OAAO,GAEX,GAAI,IAAI,CAAC,GAAG,CAAGA,EAAM,GAAG,CACpB,OAAO,EAEX,IAAMiB,EAAa,IAAI,CAAC,MAAM,CAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAG,GAChDC,EAAclB,EAAM,MAAM,CAAGA,EAAM,MAAM,CAAC,MAAM,CAAG,UACzD,AAAIiB,EAAaC,EACN,IAEPD,CAAAA,EAAaC,CAAU,CAI/B,CACA,OAAOlB,CAAK,CAAE,CACV,GAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,CAAE,CAC1B,IAAMiB,EAAa,IAAI,CAAC,MAAM,CAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAG,GAChDC,EAAclB,EAAM,MAAM,CAAGA,EAAM,MAAM,CAAC,MAAM,CAAG,GACzD,OAAQ,IAAI,CAAC,GAAG,GAAKA,EAAM,GAAG,EAAIiB,IAAeC,CACrD,CACA,MAAO,EACX,CACA,qBAAsB,CAClB,OAAO,IAAI,AACf,CACA,SAASjB,CAAO,CAAE,CACd,IAAM3E,EAAQ2E,EAAQ,QAAQ,CAAC,IAAI,CAAC,GAAG,EACvC,MAAO,MAAI,CAAC,MAAM,EAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC3E,EAC1C,CACA,WAAY,CACR,IAAMA,EAAQ,IAAI,CAAC,MAAM,CACnB,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAC7C,YACN,MAAO,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,EAAEA,EAAM,CAAC,AACpC,CACA,MAAO,CACH,MAAO,CAAC,IAAI,CAAC,GAAG,CAAC,AACrB,CACA,QAAS,CAIL,OAHK,IAAI,CAAC,OAAO,EACb,KAAI,CAAC,OAAO,CAAG6F,EAAuB,MAAM,CAAC,IAAI,GAE9C,IAAI,CAAC,OAAO,AACvB,CACJ,CACO,MAAMA,EACT,OAAO,OAAOC,CAAM,CAAE,CAClB,OAAO,IAAID,EAAuBC,EACtC,CACA,YAAYC,CAAO,CAAE,CACjB,IAAI,CAAC,OAAO,CAAGA,EACf,IAAI,CAAC,IAAI,CAAG,CAEhB,CACA,IAAIrB,CAAK,CAAE,QACP,AAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,CACjB,IAAI,CAAC,IAAI,CAAGA,EAAM,IAAI,CAE1B,IAAI,CAAC,OAAO,CAAC,GAAG,CAACA,EAAM,OAAO,CACzC,CACA,OAAOA,CAAK,CAAE,QACV,AAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,EACjB,IAAI,CAAC,OAAO,CAAC,MAAM,CAACA,EAAM,OAAO,CAGhD,CACA,qBAAsB,CAClB,OAAO,IAAI,AACf,CACA,SAASC,CAAO,CAAE,CACd,MAAO,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,CAACA,EAClC,CACA,WAAY,CACR,MAAO,CAAC,EAAE,EAAE,IAAI,CAAC,OAAO,CAAC,SAAS,GAAG,CAAC,CAAC,AAC3C,CACA,MAAO,CACH,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,EAC5B,CACA,QAAS,CACL,OAAO,IAAI,CAAC,OAAO,AACvB,CACJ,CAIA,SAASqB,EAA0BC,CAAG,EAElC,IAAIC,EAAS,KACb,IAAK,IAAIlD,EAAI,EAAGmD,EAAMF,EAAI,MAAM,CAAEjD,EAAImD,EAAKnD,IAAK,CAC5C,IAAMoD,EAAUH,CAAG,CAACjD,EAAE,CAAC,mBAAmB,GAC1C,GAAIiD,CAAG,CAACjD,EAAE,GAAKoD,GAGPF,AAAW,OAAXA,EAAiB,CACjBA,EAAS,EAAE,CACX,IAAK,IAAIG,EAAI,EAAGA,EAAIrD,EAAGqD,IACnBH,CAAM,CAACG,EAAE,CAAGJ,CAAG,CAACI,EAAE,AAE1B,CAEW,OAAXH,GACAA,CAAAA,CAAM,CAAClD,EAAE,CAAGoD,CAAM,CAE1B,QACA,AAAIF,AAAW,OAAXA,EACOD,EAEJC,CACX,CACO,MAAMhC,EACT,OAAO,OAAOoC,CAAK,CAAE1B,CAAO,CAAE2B,CAAmB,CAAE,CAC/C,OAAOrC,EAAkB,aAAa,CAACoC,EAAO1B,EAAS2B,EAC3D,CACA,YAAY3E,CAAI,CAAEgD,CAAO,CAAE,CACvB,IAAI,CAAC,IAAI,CAAGhD,EACZ,IAAI,CAAC,OAAO,CAAGgD,EACf,IAAI,CAAC,IAAI,CAAG,CAChB,CACA,IAAIF,CAAK,CAAE,CACP,GAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,CACxB,OAAO,IAAI,CAAC,IAAI,CAAGA,EAAM,IAAI,CAEjC,GAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAGA,EAAM,IAAI,CAAC,MAAM,CACpC,OAAO,GAEX,GAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAGA,EAAM,IAAI,CAAC,MAAM,CACpC,OAAO,EAEX,IAAK,IAAI1B,EAAI,EAAGmD,EAAM,IAAI,CAAC,IAAI,CAAC,MAAM,CAAEnD,EAAImD,EAAKnD,IAAK,CAClD,IAAMwD,EAAI,EAAI,IAAI,CAAC,IAAI,CAACxD,EAAE,CAAE0B,EAAM,IAAI,CAAC1B,EAAE,EACzC,GAAIwD,AAAM,IAANA,EACA,OAAOA,CAEf,CACA,OAAO,CACX,CACA,OAAO9B,CAAK,CAAE,CACV,GAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,CAAE,CAC1B,GAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAKA,EAAM,IAAI,CAAC,MAAM,CACtC,MAAO,GAEX,IAAK,IAAI1B,EAAI,EAAGmD,EAAM,IAAI,CAAC,IAAI,CAAC,MAAM,CAAEnD,EAAImD,EAAKnD,IAC7C,GAAI,CAAC,IAAI,CAAC,IAAI,CAACA,EAAE,CAAC,MAAM,CAAC0B,EAAM,IAAI,CAAC1B,EAAE,EAClC,MAAO,GAGf,MAAO,EACX,CACA,MAAO,EACX,CACA,qBAAsB,CAClB,IAAMyD,EAAUT,EAA0B,IAAI,CAAC,IAAI,SACnD,AAAIS,IAAY,IAAI,CAAC,IAAI,CAEd,IAAI,CAERvC,EAAkB,MAAM,CAACuC,EAAS,IAAI,CAAC,OAAO,CAAE,GAC3D,CACA,SAAS9B,CAAO,CAAE,CACd,IAAK,IAAI3B,EAAI,EAAGmD,EAAM,IAAI,CAAC,IAAI,CAAC,MAAM,CAAEnD,EAAImD,EAAKnD,IAC7C,GAAI,CAAC,IAAI,CAAC,IAAI,CAACA,EAAE,CAAC,QAAQ,CAAC2B,GACvB,MAAO,GAGf,MAAO,EACX,CACA,OAAO,cAAcsB,CAAG,CAAErB,CAAO,CAAE2B,CAAmB,CAAE,CACpD,IAAM3E,EAAO,EAAE,CACX8E,EAAU,GACd,IAAK,IAAM1E,KAAKiE,EACZ,GAAKjE,GAGL,GAAIA,AAAW,IAAXA,EAAE,IAAI,CAAsC,CAE5C0E,EAAU,GACV,QACJ,CACA,GAAI1E,AAAW,IAAXA,EAAE,IAAI,CAEN,OAAOG,EAAoB,QAAQ,CAEvC,GAAIH,AAAW,IAAXA,EAAE,IAAI,CAAqC,CAC3CJ,EAAK,IAAI,IAAII,EAAE,IAAI,EACnB,QACJ,CACAJ,EAAK,IAAI,CAACI,GAEd,GAAIJ,AAAgB,IAAhBA,EAAK,MAAM,EAAU8E,EACrB,OAAOtE,EAAmB,QAAQ,CAEtC,GAAIR,AAAgB,IAAhBA,EAAK,MAAM,EAGf,GAAIA,AAAgB,IAAhBA,EAAK,MAAM,CACX,OAAOA,CAAI,CAAC,EAAE,CAElBA,EAAK,IAAI,CAAC,GAEV,IAAK,IAAIoB,EAAI,EAAGA,EAAIpB,EAAK,MAAM,CAAEoB,IACzBpB,CAAI,CAACoB,EAAI,EAAE,CAAC,MAAM,CAACpB,CAAI,CAACoB,EAAE,IAC1BpB,EAAK,MAAM,CAACoB,EAAG,GACfA,KAGR,GAAIpB,AAAgB,IAAhBA,EAAK,MAAM,CACX,OAAOA,CAAI,CAAC,EAAE,CAIlB,KAAOA,EAAK,MAAM,CAAG,GAAG,CACpB,IAAM+E,EAAc/E,CAAI,CAACA,EAAK,MAAM,CAAG,EAAE,CACzC,GAAI+E,AAAqB,IAArBA,EAAY,IAAI,CAChB,MAGJ/E,EAAK,GAAG,GAER,IAAMgF,EAAsBhF,EAAK,GAAG,GAC9BiF,EAAcjF,AAAgB,IAAhBA,EAAK,MAAM,CAEzBkF,EAAgB3C,EAAiB,MAAM,CAACwC,EAAY,IAAI,CAAC,GAAG,CAACI,GAAM7C,EAAkB,MAAM,CAAC,CAAC6C,EAAIH,EAAoB,CAAE,KAAML,IAAuB,KAAMM,GAC5JC,IACAlF,EAAK,IAAI,CAACkF,GACVlF,EAAK,IAAI,CAAC,GAElB,CACA,GAAIA,AAAgB,IAAhBA,EAAK,MAAM,CACX,OAAOA,CAAI,CAAC,EAAE,CAGlB,GAAI2E,EAAqB,CACrB,IAAK,IAAIvD,EAAI,EAAGA,EAAIpB,EAAK,MAAM,CAAEoB,IAC7B,IAAK,IAAIqD,EAAIrD,EAAI,EAAGqD,EAAIzE,EAAK,MAAM,CAAEyE,IACjC,GAAIzE,CAAI,CAACoB,EAAE,CAAC,MAAM,GAAG,MAAM,CAACpB,CAAI,CAACyE,EAAE,EAE/B,OAAOlE,EAAoB,QAAQ,CAI/C,GAAIP,AAAgB,IAAhBA,EAAK,MAAM,CACX,OAAOA,CAAI,CAAC,EAAE,AAEtB,CACA,OAAO,IAAIsC,EAAkBtC,EAAMgD,GACvC,CACA,WAAY,CACR,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC5C,GAAKA,EAAE,SAAS,IAAI,IAAI,CAAC,OAClD,CACA,MAAO,CACH,IAAMgF,EAAS,EAAE,CACjB,IAAK,IAAMpF,KAAQ,IAAI,CAAC,IAAI,CACxBoF,EAAO,IAAI,IAAIpF,EAAK,IAAI,IAE5B,OAAOoF,CACX,CACA,QAAS,CACL,GAAI,CAAC,IAAI,CAAC,OAAO,CAAE,CACf,IAAMA,EAAS,EAAE,CACjB,IAAK,IAAMpF,KAAQ,IAAI,CAAC,IAAI,CACxBoF,EAAO,IAAI,CAACpF,EAAK,MAAM,GAE3B,KAAI,CAAC,OAAO,CAAGuC,EAAiB,MAAM,CAAC6C,EAAQ,IAAI,CAAE,GACzD,CACA,OAAO,IAAI,CAAC,OAAO,AACvB,CACJ,CACO,MAAM7C,EACT,OAAO,OAAOmC,CAAK,CAAE1B,CAAO,CAAE2B,CAAmB,CAAE,CAC/C,OAAOpC,EAAiB,aAAa,CAACmC,EAAO1B,EAAS2B,EAC1D,CACA,YAAY3E,CAAI,CAAEgD,CAAO,CAAE,CACvB,IAAI,CAAC,IAAI,CAAGhD,EACZ,IAAI,CAAC,OAAO,CAAGgD,EACf,IAAI,CAAC,IAAI,CAAG,CAChB,CACA,IAAIF,CAAK,CAAE,CACP,GAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,CACxB,OAAO,IAAI,CAAC,IAAI,CAAGA,EAAM,IAAI,CAEjC,GAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAGA,EAAM,IAAI,CAAC,MAAM,CACpC,OAAO,GAEX,GAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAGA,EAAM,IAAI,CAAC,MAAM,CACpC,OAAO,EAEX,IAAK,IAAI1B,EAAI,EAAGmD,EAAM,IAAI,CAAC,IAAI,CAAC,MAAM,CAAEnD,EAAImD,EAAKnD,IAAK,CAClD,IAAMwD,EAAI,EAAI,IAAI,CAAC,IAAI,CAACxD,EAAE,CAAE0B,EAAM,IAAI,CAAC1B,EAAE,EACzC,GAAIwD,AAAM,IAANA,EACA,OAAOA,CAEf,CACA,OAAO,CACX,CACA,OAAO9B,CAAK,CAAE,CACV,GAAIA,EAAM,IAAI,GAAK,IAAI,CAAC,IAAI,CAAE,CAC1B,GAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAKA,EAAM,IAAI,CAAC,MAAM,CACtC,MAAO,GAEX,IAAK,IAAI1B,EAAI,EAAGmD,EAAM,IAAI,CAAC,IAAI,CAAC,MAAM,CAAEnD,EAAImD,EAAKnD,IAC7C,GAAI,CAAC,IAAI,CAAC,IAAI,CAACA,EAAE,CAAC,MAAM,CAAC0B,EAAM,IAAI,CAAC1B,EAAE,EAClC,MAAO,GAGf,MAAO,EACX,CACA,MAAO,EACX,CACA,qBAAsB,CAClB,IAAMyD,EAAUT,EAA0B,IAAI,CAAC,IAAI,SACnD,AAAIS,IAAY,IAAI,CAAC,IAAI,CAEd,IAAI,CAERtC,EAAiB,MAAM,CAACsC,EAAS,IAAI,CAAC,OAAO,CAAE,GAC1D,CACA,SAAS9B,CAAO,CAAE,CACd,IAAK,IAAI3B,EAAI,EAAGmD,EAAM,IAAI,CAAC,IAAI,CAAC,MAAM,CAAEnD,EAAImD,EAAKnD,IAC7C,GAAI,IAAI,CAAC,IAAI,CAACA,EAAE,CAAC,QAAQ,CAAC2B,GACtB,MAAO,GAGf,MAAO,EACX,CACA,OAAO,cAAcsB,CAAG,CAAErB,CAAO,CAAE2B,CAAmB,CAAE,CACpD,IAAI3E,EAAO,EAAE,CACTqF,EAAW,GACf,GAAIhB,EAAK,CACL,IAAK,IAAIjD,EAAI,EAAGmD,EAAMF,EAAI,MAAM,CAAEjD,EAAImD,EAAKnD,IAAK,CAC5C,IAAMhB,EAAIiE,CAAG,CAACjD,EAAE,CAChB,GAAKhB,GAGL,GAAIA,AAAW,IAAXA,EAAE,IAAI,CAAuC,CAE7CiF,EAAW,GACX,QACJ,CACA,GAAIjF,AAAW,IAAXA,EAAE,IAAI,CAEN,OAAOI,EAAmB,QAAQ,CAEtC,GAAIJ,AAAW,IAAXA,EAAE,IAAI,CAAoC,CAC1CJ,EAAOA,EAAK,MAAM,CAACI,EAAE,IAAI,EACzB,QACJ,CACAJ,EAAK,IAAI,CAACI,GACd,CACA,GAAIJ,AAAgB,IAAhBA,EAAK,MAAM,EAAUqF,EACrB,OAAO9E,EAAoB,QAAQ,CAEvCP,EAAK,IAAI,CAAC,EACd,CACA,GAAIA,AAAgB,IAAhBA,EAAK,MAAM,EAGf,GAAIA,AAAgB,IAAhBA,EAAK,MAAM,CACX,OAAOA,CAAI,CAAC,EAAE,CAGlB,IAAK,IAAIoB,EAAI,EAAGA,EAAIpB,EAAK,MAAM,CAAEoB,IACzBpB,CAAI,CAACoB,EAAI,EAAE,CAAC,MAAM,CAACpB,CAAI,CAACoB,EAAE,IAC1BpB,EAAK,MAAM,CAACoB,EAAG,GACfA,KAGR,GAAIpB,AAAgB,IAAhBA,EAAK,MAAM,CACX,OAAOA,CAAI,CAAC,EAAE,CAGlB,GAAI2E,EAAqB,CACrB,IAAK,IAAIvD,EAAI,EAAGA,EAAIpB,EAAK,MAAM,CAAEoB,IAC7B,IAAK,IAAIqD,EAAIrD,EAAI,EAAGqD,EAAIzE,EAAK,MAAM,CAAEyE,IACjC,GAAIzE,CAAI,CAACoB,EAAE,CAAC,MAAM,GAAG,MAAM,CAACpB,CAAI,CAACyE,EAAE,EAE/B,OAAOjE,EAAmB,QAAQ,CAI9C,GAAIR,AAAgB,IAAhBA,EAAK,MAAM,CACX,OAAOA,CAAI,CAAC,EAAE,AAEtB,CACA,OAAO,IAAIuC,EAAiBvC,EAAMgD,GACtC,CACA,WAAY,CACR,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC5C,GAAKA,EAAE,SAAS,IAAI,IAAI,CAAC,OAClD,CACA,MAAO,CACH,IAAMgF,EAAS,EAAE,CACjB,IAAK,IAAMpF,KAAQ,IAAI,CAAC,IAAI,CACxBoF,EAAO,IAAI,IAAIpF,EAAK,IAAI,IAE5B,OAAOoF,CACX,CACA,QAAS,CACL,GAAI,CAAC,IAAI,CAAC,OAAO,CAAE,CACf,IAAMA,EAAS,EAAE,CACjB,IAAK,IAAMpF,KAAQ,IAAI,CAAC,IAAI,CACxBoF,EAAO,IAAI,CAACpF,EAAK,MAAM,IAI3B,KAAOoF,EAAO,MAAM,CAAG,GAAG,CACtB,IAAME,EAAOF,EAAO,KAAK,GACnBG,EAAQH,EAAO,KAAK,GACpBI,EAAM,EAAE,CACd,IAAK,IAAMC,KAAQC,EAAaJ,GAC5B,IAAK,IAAMjF,KAASqF,EAAaH,GAC7BC,EAAI,IAAI,CAAClD,EAAkB,MAAM,CAAC,CAACmD,EAAMpF,EAAM,CAAE,KAAM,KAG/D+E,EAAO,OAAO,CAAC7C,EAAiB,MAAM,CAACiD,EAAK,KAAM,IACtD,CACA,IAAI,CAAC,OAAO,CAAGjD,EAAiB,MAAM,CAAC6C,EAAQ,IAAI,CAAE,GACzD,CACA,OAAO,IAAI,CAAC,OAAO,AACvB,CACJ,CACO,MAAMO,UAAsB1D,EAC/B,MAAO,CAAE,IAAI,CAAC,KAAK,CAAG,EAAE,AAAE,CAAC,AAC3B,OAAO,KAAM,CACT,OAAO0D,EAAc,KAAK,CAAC,MAAM,EACrC,CACA,YAAYjF,CAAG,CAAEkF,CAAY,CAAEC,CAAU,CAAE,CACvC,KAAK,CAACnF,EAAK,MACX,IAAI,CAAC,aAAa,CAAGkF,EAEjB,AAAsB,UAAtB,OAAOC,EACPF,EAAc,KAAK,CAAC,IAAI,CAAC,CAAE,GAAGE,CAAU,CAAEnF,IAAAA,CAAI,GAE1B,KAAfmF,GACLF,EAAc,KAAK,CAAC,IAAI,CAAC,CAAEjF,IAAAA,EAAK,YAAamF,EAAY,KAAMD,MAAAA,EAAsD,OAAOA,EAAezF,KAAAA,CAAU,EAE7J,CACA,OAAO2F,CAAM,CAAE,CACX,OAAOA,EAAO,SAAS,CAAC,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,aAAa,CACxD,CACA,SAASA,CAAM,CAAE,CACb,OAAOA,EAAO,kBAAkB,CAAC,IAAI,CAAC,GAAG,CAC7C,CACA,WAAY,CACR,OAAO,IAAI,CAAC,MAAM,EACtB,CACA,UAAU1H,CAAK,CAAE,CACb,OAAO8D,EAAqB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAE9D,EACjD,CACJ,CACO,IAAM2H,EAAqB,SAAgB,qBAClD,SAAS7C,EAAKC,CAAI,CAAEC,CAAI,SACpB,AAAID,EAAOC,EACA,IAEPD,CAAAA,EAAOC,CAAG,CAIlB,CACA,SAASC,EAAKF,CAAI,CAAE6C,CAAM,CAAE5C,CAAI,CAAE6C,CAAM,SACpC,AAAI9C,EAAOC,EACA,GAEPD,EAAOC,EACA,EAEP4C,EAASC,EACF,IAEPD,CAAAA,EAASC,CAAK,CAItB,CA2CA,SAASzI,EAAoBF,CAAC,CAAEC,CAAC,EAC7B,IAAI2I,EAAS,EACTC,EAAS,EACb,KAAOD,EAAS5I,EAAE,MAAM,EAAI6I,EAAS5I,EAAE,MAAM,EAAE,CAC3C,IAAM6I,EAAM9I,CAAC,CAAC4I,EAAO,CAAC,GAAG,CAAC3I,CAAC,CAAC4I,EAAO,EACnC,GAAIC,EAAM,EAEN,MAAO,EAEM,KAARA,GACLF,IAIAC,GAER,CACA,OAAQD,IAAW5I,EAAE,MAAM,AAC/B,CACA,SAASoI,EAAaW,CAAI,SACtB,AAAIA,AAAc,IAAdA,EAAK,IAAI,CACFA,EAAK,IAAI,CAEb,CAACA,EAAK,AACjB,C,4BErgDWC,EACAA,E,oCACPA,CADOA,EAQRA,GAAUA,CAAAA,EAAQ,CAAC,IAPZ,UAAU,CAAG,IAAInI,IACvBmI,EAAM,SAAS,CAAG,aAClBA,EAAM,eAAe,CAAG,mBAIxBA,EAAM,sBAAsB,CAH5B,SAAgCC,CAAI,EAChC,OAAOA,CAAI,CAACD,EAAM,eAAe,CAAC,EAAI,EAAE,AAC5C,EAGG,IAAME,EAAwBC,EAAgB,wBAa9C,SAASA,EAAgBC,CAAS,EACrC,GAAIJ,EAAM,UAAU,CAAC,GAAG,CAACI,GACrB,OAAOJ,EAAM,UAAU,CAAC,GAAG,CAACI,GAEhC,IAAMC,EAAK,SAAUb,CAAM,CAAEpF,CAAG,CAAEkG,CAAK,EACnC,GAAIC,AAAqB,GAArBA,UAAU,MAAM,CAChB,MAAM,AAAIhH,MAAM,mEAjBpBiG,CAmB2BA,CAnBrB,CAACQ,EAAM,SAAS,CAAC,GAmBIR,EAlB3BA,AAkB2BA,CAlBrB,CAACQ,EAAM,eAAe,CAAC,CAAC,IAAI,CAAC,CAAEK,GAkBdA,EAlBkBC,MAkBNA,CAlBY,IAG/Cd,AAe2BA,CAfrB,CAACQ,EAAM,eAAe,CAAC,CAAG,CAAC,CAAEK,GAeZA,EAfgBC,MAeJA,CAfU,EAAE,CAC/Cd,AAc2BA,CAdrB,CAACQ,EAAM,SAAS,CAAC,CAcIR,EAC/B,EAGA,OAFAa,EAAG,QAAQ,CAAG,IAAMD,EACpBJ,EAAM,UAAU,CAAC,GAAG,CAACI,EAAWC,GACzBA,CACX,C,yECnCWG,EADAA,E,iCADJ,IAAMC,EAAc,G,SAAA,IAAgB,aAGvCD,EADOA,EAORA,GAAaA,CAAAA,EAAW,CAAC,GANhB,CAACA,EAAS,GAAM,CAAG,EAAE,CAAG,MAChCA,CAAQ,CAACA,EAAS,KAAQ,CAAG,EAAE,CAAG,QAClCA,CAAQ,CAACA,EAAS,KAAQ,CAAG,EAAE,CAAG,QAClCA,CAAQ,CAACA,EAAS,IAAO,CAAG,EAAE,CAAG,OACjCA,CAAQ,CAACA,EAAS,OAAU,CAAG,EAAE,CAAG,UACpCA,CAAQ,CAACA,EAAS,KAAQ,CAAG,EAAE,CAAG,QAE/B,IAAME,EAAoBF,EAAS,IAAI,AACvC,OAAMG,UAAuB,IAAU,CAC1C,aAAc,CACV,KAAK,IAAIJ,WACT,IAAI,CAAC,KAAK,CAAGG,EACb,IAAI,CAAC,oBAAoB,CAAG,IAAI,CAAC,SAAS,CAAC,IAAI,IAAO,EACtD,IAAI,CAAC,mBAAmB,CAAG,IAAI,CAAC,oBAAoB,CAAC,KAAK,AAC9D,CACA,SAASE,CAAK,CAAE,CACR,IAAI,CAAC,KAAK,GAAKA,IACf,IAAI,CAAC,KAAK,CAAGA,EACb,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAEjD,CACA,UAAW,CACP,OAAO,IAAI,CAAC,KAAK,AACrB,CACA,cAAcA,CAAK,CAAE,CACjB,OAAO,IAAI,CAAC,KAAK,GAAKJ,EAAS,GAAG,EAAI,IAAI,CAAC,KAAK,EAAII,CACxD,CACJ,CACO,MAAMC,UAAsBF,EAC/B,YAAYG,EAAWJ,CAAiB,CAAEK,EAAY,EAAI,CAAE,CACxD,KAAK,GACL,IAAI,CAAC,SAAS,CAAGA,EACjB,IAAI,CAAC,QAAQ,CAACD,EAClB,CACA,MAAMrF,CAAO,CAAE,GAAGuF,CAAI,CAAE,CAChB,IAAI,CAAC,aAAa,CAACR,EAAS,KAAK,IAC7B,IAAI,CAAC,SAAS,CACdS,QAAQ,GAAG,CAAC,UAAW,cAAexF,KAAYuF,GAGlDC,QAAQ,GAAG,CAACxF,KAAYuF,GAGpC,CACA,MAAMvF,CAAO,CAAE,GAAGuF,CAAI,CAAE,CAChB,IAAI,CAAC,aAAa,CAACR,EAAS,KAAK,IAC7B,IAAI,CAAC,SAAS,CACdS,QAAQ,GAAG,CAAC,UAAW,gCAAiCxF,KAAYuF,GAGpEC,QAAQ,GAAG,CAACxF,KAAYuF,GAGpC,CACA,KAAKvF,CAAO,CAAE,GAAGuF,CAAI,CAAE,CACf,IAAI,CAAC,aAAa,CAACR,EAAS,IAAI,IAC5B,IAAI,CAAC,SAAS,CACdS,QAAQ,GAAG,CAAC,UAAW,cAAexF,KAAYuF,GAGlDC,QAAQ,GAAG,CAACxF,KAAYuF,GAGpC,CACA,KAAKvF,CAAO,CAAE,GAAGuF,CAAI,CAAE,CACf,IAAI,CAAC,aAAa,CAACR,EAAS,OAAO,IAC/B,IAAI,CAAC,SAAS,CACdS,QAAQ,GAAG,CAAC,UAAW,cAAexF,KAAYuF,GAGlDC,QAAQ,GAAG,CAACxF,KAAYuF,GAGpC,CACA,MAAMvF,CAAO,CAAE,GAAGuF,CAAI,CAAE,CAChB,IAAI,CAAC,aAAa,CAACR,EAAS,KAAK,IAC7B,IAAI,CAAC,SAAS,CACdS,QAAQ,GAAG,CAAC,UAAW,cAAexF,KAAYuF,GAGlDC,QAAQ,KAAK,CAACxF,KAAYuF,GAGtC,CACJ,CACO,MAAME,UAAwBP,EACjC,YAAYQ,CAAO,CAAE,CACjB,KAAK,GACL,IAAI,CAAC,OAAO,CAAGA,EACXA,EAAQ,MAAM,EACd,IAAI,CAAC,QAAQ,CAACA,CAAO,CAAC,EAAE,CAAC,QAAQ,GAEzC,CACA,SAASP,CAAK,CAAE,CACZ,IAAK,IAAMQ,KAAU,IAAI,CAAC,OAAO,CAC7BA,EAAO,QAAQ,CAACR,GAEpB,KAAK,CAAC,SAASA,EACnB,CACA,MAAMnF,CAAO,CAAE,GAAGuF,CAAI,CAAE,CACpB,IAAK,IAAMI,KAAU,IAAI,CAAC,OAAO,CAC7BA,EAAO,KAAK,CAAC3F,KAAYuF,EAEjC,CACA,MAAMvF,CAAO,CAAE,GAAGuF,CAAI,CAAE,CACpB,IAAK,IAAMI,KAAU,IAAI,CAAC,OAAO,CAC7BA,EAAO,KAAK,CAAC3F,KAAYuF,EAEjC,CACA,KAAKvF,CAAO,CAAE,GAAGuF,CAAI,CAAE,CACnB,IAAK,IAAMI,KAAU,IAAI,CAAC,OAAO,CAC7BA,EAAO,IAAI,CAAC3F,KAAYuF,EAEhC,CACA,KAAKvF,CAAO,CAAE,GAAGuF,CAAI,CAAE,CACnB,IAAK,IAAMI,KAAU,IAAI,CAAC,OAAO,CAC7BA,EAAO,IAAI,CAAC3F,KAAYuF,EAEhC,CACA,MAAMvF,CAAO,CAAE,GAAGuF,CAAI,CAAE,CACpB,IAAK,IAAMI,KAAU,IAAI,CAAC,OAAO,CAC7BA,EAAO,KAAK,CAAC3F,KAAYuF,EAEjC,CACA,SAAU,CACN,IAAK,IAAMI,KAAU,IAAI,CAAC,OAAO,CAC7BA,EAAO,OAAO,GAElB,KAAK,CAAC,SACV,CACJ,CAYiC,IAAI,IAAa,CAAC,WAAYC,AAXxD,SAA0BP,CAAQ,EACrC,OAAQA,GACJ,KAAKN,EAAS,KAAK,CAAE,MAAO,OAC5B,MAAKA,EAAS,KAAK,CAAE,MAAO,OAC5B,MAAKA,EAAS,IAAI,CAAE,MAAO,MAC3B,MAAKA,EAAS,OAAO,CAAE,MAAO,MAC9B,MAAKA,EAAS,KAAK,CAAE,MAAO,OAC5B,MAAKA,EAAS,GAAG,CAAE,MAAO,KAC9B,CACJ,EAEgFA,EAAS,IAAI,E"}