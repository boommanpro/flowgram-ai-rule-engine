{"version":3,"file":"4316.js","sources":["webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/base/common/glob.js"],"sourcesContent":["import { isThenable } from './async.js';\nimport { isEqualOrParent } from './extpath.js';\nimport { LRUCache } from './map.js';\nimport { basename, extname, posix, sep } from './path.js';\nimport { isLinux } from './platform.js';\nimport { escapeRegExpCharacters, ltrim } from './strings.js';\nexport const GLOBSTAR = '**';\nexport const GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\nfunction starsToRegExp(starCount, isLastPattern) {\n    switch (starCount) {\n        case 0:\n            return '';\n        case 1:\n            return `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n        default:\n            // Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern\n            //           in which case also matches (Path Sep followed by Path Val)\n            // Group is non capturing because we don't need to capture at all (?:...)\n            // Overall we use non-greedy matching because it could be that we match too much\n            return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;\n    }\n}\nexport function splitGlobAware(pattern, splitChar) {\n    if (!pattern) {\n        return [];\n    }\n    const segments = [];\n    let inBraces = false;\n    let inBrackets = false;\n    let curVal = '';\n    for (const char of pattern) {\n        switch (char) {\n            case splitChar:\n                if (!inBraces && !inBrackets) {\n                    segments.push(curVal);\n                    curVal = '';\n                    continue;\n                }\n                break;\n            case '{':\n                inBraces = true;\n                break;\n            case '}':\n                inBraces = false;\n                break;\n            case '[':\n                inBrackets = true;\n                break;\n            case ']':\n                inBrackets = false;\n                break;\n        }\n        curVal += char;\n    }\n    // Tail\n    if (curVal) {\n        segments.push(curVal);\n    }\n    return segments;\n}\nfunction parseRegExp(pattern) {\n    if (!pattern) {\n        return '';\n    }\n    let regEx = '';\n    // Split up into segments for each slash found\n    const segments = splitGlobAware(pattern, GLOB_SPLIT);\n    // Special case where we only have globstars\n    if (segments.every(segment => segment === GLOBSTAR)) {\n        regEx = '.*';\n    }\n    // Build regex over segments\n    else {\n        let previousSegmentWasGlobStar = false;\n        segments.forEach((segment, index) => {\n            // Treat globstar specially\n            if (segment === GLOBSTAR) {\n                // if we have more than one globstar after another, just ignore it\n                if (previousSegmentWasGlobStar) {\n                    return;\n                }\n                regEx += starsToRegExp(2, index === segments.length - 1);\n            }\n            // Anything else, not globstar\n            else {\n                // States\n                let inBraces = false;\n                let braceVal = '';\n                let inBrackets = false;\n                let bracketVal = '';\n                for (const char of segment) {\n                    // Support brace expansion\n                    if (char !== '}' && inBraces) {\n                        braceVal += char;\n                        continue;\n                    }\n                    // Support brackets\n                    if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n                        let res;\n                        // range operator\n                        if (char === '-') {\n                            res = char;\n                        }\n                        // negation operator (only valid on first index in bracket)\n                        else if ((char === '^' || char === '!') && !bracketVal) {\n                            res = '^';\n                        }\n                        // glob split matching is not allowed within character ranges\n                        // see http://man7.org/linux/man-pages/man7/glob.7.html\n                        else if (char === GLOB_SPLIT) {\n                            res = '';\n                        }\n                        // anything else gets escaped\n                        else {\n                            res = escapeRegExpCharacters(char);\n                        }\n                        bracketVal += res;\n                        continue;\n                    }\n                    switch (char) {\n                        case '{':\n                            inBraces = true;\n                            continue;\n                        case '[':\n                            inBrackets = true;\n                            continue;\n                        case '}': {\n                            const choices = splitGlobAware(braceVal, ',');\n                            // Converts {foo,bar} => [foo|bar]\n                            const braceRegExp = `(?:${choices.map(choice => parseRegExp(choice)).join('|')})`;\n                            regEx += braceRegExp;\n                            inBraces = false;\n                            braceVal = '';\n                            break;\n                        }\n                        case ']': {\n                            regEx += ('[' + bracketVal + ']');\n                            inBrackets = false;\n                            bracketVal = '';\n                            break;\n                        }\n                        case '?':\n                            regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n                            continue;\n                        case '*':\n                            regEx += starsToRegExp(1);\n                            continue;\n                        default:\n                            regEx += escapeRegExpCharacters(char);\n                    }\n                }\n                // Tail: Add the slash we had split on if there is more to\n                // come and the remaining pattern is not a globstar\n                // For example if pattern: some/**/*.js we want the \"/\" after\n                // some to be included in the RegEx to prevent a folder called\n                // \"something\" to match as well.\n                if (index < segments.length - 1 && // more segments to come after this\n                    (segments[index + 1] !== GLOBSTAR || // next segment is not **, or...\n                        index + 2 < segments.length // ...next segment is ** but there is more segments after that\n                    )) {\n                    regEx += PATH_REGEX;\n                }\n            }\n            // update globstar state\n            previousSegmentWasGlobStar = (segment === GLOBSTAR);\n        });\n    }\n    return regEx;\n}\n// regexes to check for trivial glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\nconst T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\nconst CACHE = new LRUCache(10000); // bounded to 10000 elements\nconst FALSE = function () {\n    return false;\n};\nconst NULL = function () {\n    return null;\n};\nfunction parsePattern(arg1, options) {\n    if (!arg1) {\n        return NULL;\n    }\n    // Handle relative patterns\n    let pattern;\n    if (typeof arg1 !== 'string') {\n        pattern = arg1.pattern;\n    }\n    else {\n        pattern = arg1;\n    }\n    // Whitespace trimming\n    pattern = pattern.trim();\n    // Check cache\n    const patternKey = `${pattern}_${!!options.trimForExclusions}`;\n    let parsedPattern = CACHE.get(patternKey);\n    if (parsedPattern) {\n        return wrapRelativePattern(parsedPattern, arg1);\n    }\n    // Check for Trivials\n    let match;\n    if (T1.test(pattern)) {\n        parsedPattern = trivia1(pattern.substr(4), pattern); // common pattern: **/*.txt just need endsWith check\n    }\n    else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\n        parsedPattern = trivia2(match[1], pattern);\n    }\n    else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n        parsedPattern = trivia3(pattern, options);\n    }\n    else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\n        parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n    }\n    else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\n        parsedPattern = trivia4and5(match[1], pattern, false);\n    }\n    // Otherwise convert to pattern\n    else {\n        parsedPattern = toRegExp(pattern);\n    }\n    // Cache\n    CACHE.set(patternKey, parsedPattern);\n    return wrapRelativePattern(parsedPattern, arg1);\n}\nfunction wrapRelativePattern(parsedPattern, arg2) {\n    if (typeof arg2 === 'string') {\n        return parsedPattern;\n    }\n    const wrappedPattern = function (path, basename) {\n        if (!isEqualOrParent(path, arg2.base, !isLinux)) {\n            // skip glob matching if `base` is not a parent of `path`\n            return null;\n        }\n        // Given we have checked `base` being a parent of `path`,\n        // we can now remove the `base` portion of the `path`\n        // and only match on the remaining path components\n        // For that we try to extract the portion of the `path`\n        // that comes after the `base` portion. We have to account\n        // for the fact that `base` might end in a path separator\n        // (https://github.com/microsoft/vscode/issues/162498)\n        return parsedPattern(ltrim(path.substr(arg2.base.length), sep), basename);\n    };\n    // Make sure to preserve associated metadata\n    wrappedPattern.allBasenames = parsedPattern.allBasenames;\n    wrappedPattern.allPaths = parsedPattern.allPaths;\n    wrappedPattern.basenames = parsedPattern.basenames;\n    wrappedPattern.patterns = parsedPattern.patterns;\n    return wrappedPattern;\n}\nfunction trimForExclusions(pattern, options) {\n    return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n// common pattern: **/*.txt just need endsWith check\nfunction trivia1(base, pattern) {\n    return function (path, basename) {\n        return typeof path === 'string' && path.endsWith(base) ? pattern : null;\n    };\n}\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base, pattern) {\n    const slashBase = `/${base}`;\n    const backslashBase = `\\\\${base}`;\n    const parsedPattern = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (basename) {\n            return basename === base ? pattern : null;\n        }\n        return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;\n    };\n    const basenames = [base];\n    parsedPattern.basenames = basenames;\n    parsedPattern.patterns = [pattern];\n    parsedPattern.allBasenames = basenames;\n    return parsedPattern;\n}\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern, options) {\n    const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1)\n        .split(',')\n        .map(pattern => parsePattern(pattern, options))\n        .filter(pattern => pattern !== NULL), pattern);\n    const patternsLength = parsedPatterns.length;\n    if (!patternsLength) {\n        return NULL;\n    }\n    if (patternsLength === 1) {\n        return parsedPatterns[0];\n    }\n    const parsedPattern = function (path, basename) {\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            if (parsedPatterns[i](path, basename)) {\n                return pattern;\n            }\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        parsedPattern.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        parsedPattern.allPaths = allPaths;\n    }\n    return parsedPattern;\n}\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath, pattern, matchPathEnds) {\n    const usingPosixSep = sep === posix.sep;\n    const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n    const nativePathEnd = sep + nativePath;\n    const targetPathEnd = posix.sep + targetPath;\n    let parsedPattern;\n    if (matchPathEnds) {\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && ((path === nativePath || path.endsWith(nativePathEnd)) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;\n        };\n    }\n    else {\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && (path === nativePath || (!usingPosixSep && path === targetPath)) ? pattern : null;\n        };\n    }\n    parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n    return parsedPattern;\n}\nfunction toRegExp(pattern) {\n    try {\n        const regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n        return function (path) {\n            regExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n            return typeof path === 'string' && regExp.test(path) ? pattern : null;\n        };\n    }\n    catch (error) {\n        return NULL;\n    }\n}\nexport function match(arg1, path, hasSibling) {\n    if (!arg1 || typeof path !== 'string') {\n        return false;\n    }\n    return parse(arg1)(path, undefined, hasSibling);\n}\nexport function parse(arg1, options = {}) {\n    if (!arg1) {\n        return FALSE;\n    }\n    // Glob with String\n    if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n        const parsedPattern = parsePattern(arg1, options);\n        if (parsedPattern === NULL) {\n            return FALSE;\n        }\n        const resultPattern = function (path, basename) {\n            return !!parsedPattern(path, basename);\n        };\n        if (parsedPattern.allBasenames) {\n            resultPattern.allBasenames = parsedPattern.allBasenames;\n        }\n        if (parsedPattern.allPaths) {\n            resultPattern.allPaths = parsedPattern.allPaths;\n        }\n        return resultPattern;\n    }\n    // Glob with Expression\n    return parsedExpression(arg1, options);\n}\nexport function isRelativePattern(obj) {\n    const rp = obj;\n    if (!rp) {\n        return false;\n    }\n    return typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\nfunction parsedExpression(expression, options) {\n    const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n        .map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n        .filter(pattern => pattern !== NULL));\n    const patternsLength = parsedPatterns.length;\n    if (!patternsLength) {\n        return NULL;\n    }\n    if (!parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings)) {\n        if (patternsLength === 1) {\n            return parsedPatterns[0];\n        }\n        const resultExpression = function (path, basename) {\n            let resultPromises = undefined;\n            for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n                const result = parsedPatterns[i](path, basename);\n                if (typeof result === 'string') {\n                    return result; // immediately return as soon as the first expression matches\n                }\n                // If the result is a promise, we have to keep it for\n                // later processing and await the result properly.\n                if (isThenable(result)) {\n                    if (!resultPromises) {\n                        resultPromises = [];\n                    }\n                    resultPromises.push(result);\n                }\n            }\n            // With result promises, we have to loop over each and\n            // await the result before we can return any result.\n            if (resultPromises) {\n                return (async () => {\n                    for (const resultPromise of resultPromises) {\n                        const result = await resultPromise;\n                        if (typeof result === 'string') {\n                            return result;\n                        }\n                    }\n                    return null;\n                })();\n            }\n            return null;\n        };\n        const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n        if (withBasenames) {\n            resultExpression.allBasenames = withBasenames.allBasenames;\n        }\n        const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n        if (allPaths.length) {\n            resultExpression.allPaths = allPaths;\n        }\n        return resultExpression;\n    }\n    const resultExpression = function (path, base, hasSibling) {\n        let name = undefined;\n        let resultPromises = undefined;\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            // Pattern matches path\n            const parsedPattern = parsedPatterns[i];\n            if (parsedPattern.requiresSiblings && hasSibling) {\n                if (!base) {\n                    base = basename(path);\n                }\n                if (!name) {\n                    name = base.substr(0, base.length - extname(path).length);\n                }\n            }\n            const result = parsedPattern(path, base, name, hasSibling);\n            if (typeof result === 'string') {\n                return result; // immediately return as soon as the first expression matches\n            }\n            // If the result is a promise, we have to keep it for\n            // later processing and await the result properly.\n            if (isThenable(result)) {\n                if (!resultPromises) {\n                    resultPromises = [];\n                }\n                resultPromises.push(result);\n            }\n        }\n        // With result promises, we have to loop over each and\n        // await the result before we can return any result.\n        if (resultPromises) {\n            return (async () => {\n                for (const resultPromise of resultPromises) {\n                    const result = await resultPromise;\n                    if (typeof result === 'string') {\n                        return result;\n                    }\n                }\n                return null;\n            })();\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        resultExpression.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        resultExpression.allPaths = allPaths;\n    }\n    return resultExpression;\n}\nfunction parseExpressionPattern(pattern, value, options) {\n    if (value === false) {\n        return NULL; // pattern is disabled\n    }\n    const parsedPattern = parsePattern(pattern, options);\n    if (parsedPattern === NULL) {\n        return NULL;\n    }\n    // Expression Pattern is <boolean>\n    if (typeof value === 'boolean') {\n        return parsedPattern;\n    }\n    // Expression Pattern is <SiblingClause>\n    if (value) {\n        const when = value.when;\n        if (typeof when === 'string') {\n            const result = (path, basename, name, hasSibling) => {\n                if (!hasSibling || !parsedPattern(path, basename)) {\n                    return null;\n                }\n                const clausePattern = when.replace('$(basename)', () => name);\n                const matched = hasSibling(clausePattern);\n                return isThenable(matched) ?\n                    matched.then(match => match ? pattern : null) :\n                    matched ? pattern : null;\n            };\n            result.requiresSiblings = true;\n            return result;\n        }\n    }\n    // Expression is anything\n    return parsedPattern;\n}\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);\n    if (basenamePatterns.length < 2) {\n        return parsedPatterns;\n    }\n    const basenames = basenamePatterns.reduce((all, current) => {\n        const basenames = current.basenames;\n        return basenames ? all.concat(basenames) : all;\n    }, []);\n    let patterns;\n    if (result) {\n        patterns = [];\n        for (let i = 0, n = basenames.length; i < n; i++) {\n            patterns.push(result);\n        }\n    }\n    else {\n        patterns = basenamePatterns.reduce((all, current) => {\n            const patterns = current.patterns;\n            return patterns ? all.concat(patterns) : all;\n        }, []);\n    }\n    const aggregate = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (!basename) {\n            let i;\n            for (i = path.length; i > 0; i--) {\n                const ch = path.charCodeAt(i - 1);\n                if (ch === 47 /* CharCode.Slash */ || ch === 92 /* CharCode.Backslash */) {\n                    break;\n                }\n            }\n            basename = path.substr(i);\n        }\n        const index = basenames.indexOf(basename);\n        return index !== -1 ? patterns[index] : null;\n    };\n    aggregate.basenames = basenames;\n    aggregate.patterns = patterns;\n    aggregate.allBasenames = basenames;\n    const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);\n    aggregatedPatterns.push(aggregate);\n    return aggregatedPatterns;\n}\n"],"names":["PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","isLastPattern","splitGlobAware","pattern","splitChar","segments","inBraces","inBrackets","curVal","char","T1","T2","T3","T3_2","T4","T5","CACHE","FALSE","NULL","parsePattern","arg1","options","base","match","patternKey","parsedPattern","path","basename","trimForExclusions","trivia2","slashBase","backslashBase","basenames","trivia3","parsedPatterns","aggregateBasenameMatches","patternsLength","i","n","withBasenames","allPaths","all","current","trivia4and5","toRegExp","regExp","RegExp","parseRegExp","regEx","segment","previousSegmentWasGlobStar","index","braceVal","bracketVal","res","choices","braceRegExp","choice","error","wrapRelativePattern","arg2","wrappedPattern","targetPath","matchPathEnds","usingPosixSep","nativePath","nativePathEnd","targetPathEnd","hasSibling","parse","undefined","obj","rp","resultPattern","parsedExpression","expression","Object","parseExpressionPattern","value","when","result","name","matched","resultExpression","resultPromises","resultPromise","patterns","basenamePatterns","aggregate","ch","aggregatedPatterns"],"mappings":"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"}