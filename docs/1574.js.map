{"version":3,"file":"1574.js","sources":["webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/base/common/buffer.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/encodedTokenAttributes.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/language.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/electricCharacter.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentRules.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/onEnter.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/languageBracketsConfiguration.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/nullTokenize.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/tokenizationTextModelPart.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/textModelBracketPairs.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/fixedArray.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokens.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/tokens.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/treeSitterTokens.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensEditing.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensStore.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseTokensStore.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/textModelPart.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/utils.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/services/treeSitterParserService.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/textModelEvents.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/textModelGuides.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/platform/instantiation/common/descriptors.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/platform/instantiation/common/extensions.js","webpack://@flowgram.ai/demo-free-layout/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedo.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Lazy } from './lazy.js';\nconst hasBuffer = (typeof Buffer !== 'undefined');\nconst indexOfTable = new Lazy(() => new Uint8Array(256));\nlet textDecoder;\nexport class VSBuffer {\n    /**\n     * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n     * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n     * which is not transferrable.\n     */\n    static wrap(actual) {\n        if (hasBuffer && !(Buffer.isBuffer(actual))) {\n            // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n            // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n        }\n        return new VSBuffer(actual);\n    }\n    constructor(buffer) {\n        this.buffer = buffer;\n        this.byteLength = this.buffer.byteLength;\n    }\n    toString() {\n        if (hasBuffer) {\n            return this.buffer.toString();\n        }\n        else {\n            if (!textDecoder) {\n                textDecoder = new TextDecoder();\n            }\n            return textDecoder.decode(this.buffer);\n        }\n    }\n}\nexport function readUInt16LE(source, offset) {\n    return (((source[offset + 0] << 0) >>> 0) |\n        ((source[offset + 1] << 8) >>> 0));\n}\nexport function writeUInt16LE(destination, value, offset) {\n    destination[offset + 0] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 1] = (value & 0b11111111);\n}\nexport function readUInt32BE(source, offset) {\n    return (source[offset] * 2 ** 24\n        + source[offset + 1] * 2 ** 16\n        + source[offset + 2] * 2 ** 8\n        + source[offset + 3]);\n}\nexport function writeUInt32BE(destination, value, offset) {\n    destination[offset + 3] = value;\n    value = value >>> 8;\n    destination[offset + 2] = value;\n    value = value >>> 8;\n    destination[offset + 1] = value;\n    value = value >>> 8;\n    destination[offset] = value;\n}\nexport function readUInt8(source, offset) {\n    return source[offset];\n}\nexport function writeUInt8(destination, value, offset) {\n    destination[offset] = value;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n    static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {\n        if (codePoint === 9 /* CharCode.Tab */) {\n            return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        }\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n            return visibleColumn + 2;\n        }\n        return visibleColumn + 1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const textLen = Math.min(column - 1, lineContent.length);\n        const text = lineContent.substring(0, textLen);\n        const iterator = new strings.GraphemeIterator(text);\n        let result = 0;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n            iterator.nextGraphemeLength();\n            result = this._nextVisibleColumn(codePoint, result, tabSize);\n        }\n        return result;\n    }\n    /**\n     * Returns a column from a visible column.\n     * @see {@link CursorColumns}\n     */\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineContentLength = lineContent.length;\n        const iterator = new strings.GraphemeIterator(lineContent);\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n            iterator.nextGraphemeLength();\n            const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n            const afterColumn = iterator.offset + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineContentLength + 1;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return visibleColumn + indentSize - visibleColumn % indentSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return Math.max(0, column - 1 - (column - 1) % indentSize);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function countEOL(text) {\n    let eolCount = 0;\n    let firstLineLength = 0;\n    let lastLineStart = 0;\n    let eol = 0 /* StringEOL.Unknown */;\n    for (let i = 0, len = text.length; i < len; i++) {\n        const chr = text.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                eol |= 2 /* StringEOL.CRLF */;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                eol |= 3 /* StringEOL.Invalid */;\n            }\n            lastLineStart = i + 1;\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            // \\n... case\n            eol |= 1 /* StringEOL.LF */;\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            lastLineStart = i + 1;\n        }\n    }\n    if (eolCount === 0) {\n        firstLineLength = text.length;\n    }\n    return [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from './cursorColumns.js';\nfunction _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n    let spacesCnt = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str.charAt(i) === '\\t') {\n            spacesCnt = CursorColumns.nextIndentTabStop(spacesCnt, indentSize);\n        }\n        else {\n            spacesCnt++;\n        }\n    }\n    let result = '';\n    if (!insertSpaces) {\n        const tabsCnt = Math.floor(spacesCnt / indentSize);\n        spacesCnt = spacesCnt % indentSize;\n        for (let i = 0; i < tabsCnt; i++) {\n            result += '\\t';\n        }\n    }\n    for (let i = 0; i < spacesCnt; i++) {\n        result += ' ';\n    }\n    return result;\n}\nexport function normalizeIndentation(str, indentSize, insertSpaces) {\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n    if (firstNonWhitespaceIndex === -1) {\n        firstNonWhitespaceIndex = str.length;\n    }\n    return _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport function decodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nexport class StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    /**\n     * Append a char code (<2^16)\n     */\n    appendCharCode(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    /**\n     * Append an ASCII char code (<2^8)\n     */\n    appendASCIICharCode(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as buffer from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\nfunction escapeNewLine(str) {\n    return (str\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r'));\n}\nexport class TextChange {\n    get oldLength() {\n        return this.oldText.length;\n    }\n    get oldEnd() {\n        return this.oldPosition + this.oldText.length;\n    }\n    get newLength() {\n        return this.newText.length;\n    }\n    get newEnd() {\n        return this.newPosition + this.newText.length;\n    }\n    constructor(oldPosition, oldText, newPosition, newText) {\n        this.oldPosition = oldPosition;\n        this.oldText = oldText;\n        this.newPosition = newPosition;\n        this.newText = newText;\n    }\n    toString() {\n        if (this.oldText.length === 0) {\n            return `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n        }\n        if (this.newText.length === 0) {\n            return `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n        }\n        return `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n    }\n    static _writeStringSize(str) {\n        return (4 + 2 * str.length);\n    }\n    static _writeString(b, str, offset) {\n        const len = str.length;\n        buffer.writeUInt32BE(b, len, offset);\n        offset += 4;\n        for (let i = 0; i < len; i++) {\n            buffer.writeUInt16LE(b, str.charCodeAt(i), offset);\n            offset += 2;\n        }\n        return offset;\n    }\n    static _readString(b, offset) {\n        const len = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        return decodeUTF16LE(b, offset, len);\n    }\n    writeSize() {\n        return (+4 // oldPosition\n            + 4 // newPosition\n            + TextChange._writeStringSize(this.oldText)\n            + TextChange._writeStringSize(this.newText));\n    }\n    write(b, offset) {\n        buffer.writeUInt32BE(b, this.oldPosition, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.newPosition, offset);\n        offset += 4;\n        offset = TextChange._writeString(b, this.oldText, offset);\n        offset = TextChange._writeString(b, this.newText, offset);\n        return offset;\n    }\n    static read(b, offset, dest) {\n        const oldPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const newPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const oldText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(oldText);\n        const newText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(newText);\n        dest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n        return offset;\n    }\n}\nexport function compressConsecutiveTextChanges(prevEdits, currEdits) {\n    if (prevEdits === null || prevEdits.length === 0) {\n        return currEdits;\n    }\n    const compressor = new TextChangeCompressor(prevEdits, currEdits);\n    return compressor.compress();\n}\nclass TextChangeCompressor {\n    constructor(prevEdits, currEdits) {\n        this._prevEdits = prevEdits;\n        this._currEdits = currEdits;\n        this._result = [];\n        this._resultLen = 0;\n        this._prevLen = this._prevEdits.length;\n        this._prevDeltaOffset = 0;\n        this._currLen = this._currEdits.length;\n        this._currDeltaOffset = 0;\n    }\n    compress() {\n        let prevIndex = 0;\n        let currIndex = 0;\n        let prevEdit = this._getPrev(prevIndex);\n        let currEdit = this._getCurr(currIndex);\n        while (prevIndex < this._prevLen || currIndex < this._currLen) {\n            if (prevEdit === null) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (currEdit === null) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldEnd <= prevEdit.newPosition) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (prevEdit.newEnd <= currEdit.oldPosition) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldPosition < prevEdit.newPosition) {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n                this._acceptCurr(e1);\n                currEdit = e2;\n                continue;\n            }\n            if (prevEdit.newPosition < currEdit.oldPosition) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n                this._acceptPrev(e1);\n                prevEdit = e2;\n                continue;\n            }\n            // At this point, currEdit.oldPosition === prevEdit.newPosition\n            let mergePrev;\n            let mergeCurr;\n            if (currEdit.oldEnd === prevEdit.newEnd) {\n                mergePrev = prevEdit;\n                mergeCurr = currEdit;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = this._getCurr(++currIndex);\n            }\n            else if (currEdit.oldEnd < prevEdit.newEnd) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n                mergePrev = e1;\n                mergeCurr = currEdit;\n                prevEdit = e2;\n                currEdit = this._getCurr(++currIndex);\n            }\n            else {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n                mergePrev = prevEdit;\n                mergeCurr = e1;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = e2;\n            }\n            this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);\n            this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n            this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n        }\n        const merged = TextChangeCompressor._merge(this._result);\n        const cleaned = TextChangeCompressor._removeNoOps(merged);\n        return cleaned;\n    }\n    _acceptCurr(currEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n    }\n    _getCurr(currIndex) {\n        return (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n    }\n    _acceptPrev(prevEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n    }\n    _getPrev(prevIndex) {\n        return (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n    }\n    static _rebaseCurr(prevDeltaOffset, currEdit) {\n        return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);\n    }\n    static _rebasePrev(currDeltaOffset, prevEdit) {\n        return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);\n    }\n    static _splitPrev(edit, offset) {\n        const preText = edit.newText.substr(0, offset);\n        const postText = edit.newText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),\n            new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText)\n        ];\n    }\n    static _splitCurr(edit, offset) {\n        const preText = edit.oldText.substr(0, offset);\n        const postText = edit.oldText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),\n            new TextChange(edit.oldPosition + offset, postText, edit.newEnd, '')\n        ];\n    }\n    static _merge(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        let prev = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            const curr = edits[i];\n            if (prev.oldEnd === curr.oldPosition) {\n                // Merge into `prev`\n                prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);\n            }\n            else {\n                result[resultLen++] = prev;\n                prev = curr;\n            }\n        }\n        result[resultLen++] = prev;\n        return result;\n    }\n    static _removeNoOps(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0; i < edits.length; i++) {\n            const edit = edits[i];\n            if (edit.oldText === edit.newText) {\n                continue;\n            }\n            result[resultLen++] = edit;\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const EDITOR_MODEL_DEFAULTS = {\n    tabSize: 4,\n    indentSize: 4,\n    insertSpaces: true,\n    detectIndentation: true,\n    trimAutoWhitespace: true,\n    largeFileOptimizations: true,\n    bracketPairColorizationOptions: {\n        enabled: true,\n        independentColorPoolPerBracketType: false,\n    },\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n */\nexport class TokenMetadata {\n    static getLanguageId(metadata) {\n        return (metadata & 255 /* MetadataConsts.LANGUAGEID_MASK */) >>> 0 /* MetadataConsts.LANGUAGEID_OFFSET */;\n    }\n    static getTokenType(metadata) {\n        return (metadata & 768 /* MetadataConsts.TOKEN_TYPE_MASK */) >>> 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */;\n    }\n    static containsBalancedBrackets(metadata) {\n        return (metadata & 1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */) !== 0;\n    }\n    static getFontStyle(metadata) {\n        return (metadata & 30720 /* MetadataConsts.FONT_STYLE_MASK */) >>> 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n    }\n    static getForeground(metadata) {\n        return (metadata & 16744448 /* MetadataConsts.FOREGROUND_MASK */) >>> 15 /* MetadataConsts.FOREGROUND_OFFSET */;\n    }\n    static getBackground(metadata) {\n        return (metadata & 4278190080 /* MetadataConsts.BACKGROUND_MASK */) >>> 24 /* MetadataConsts.BACKGROUND_OFFSET */;\n    }\n    static getClassNameFromMetadata(metadata) {\n        const foreground = this.getForeground(metadata);\n        let className = 'mtk' + foreground;\n        const fontStyle = this.getFontStyle(metadata);\n        if (fontStyle & 1 /* FontStyle.Italic */) {\n            className += ' mtki';\n        }\n        if (fontStyle & 2 /* FontStyle.Bold */) {\n            className += ' mtkb';\n        }\n        if (fontStyle & 4 /* FontStyle.Underline */) {\n            className += ' mtku';\n        }\n        if (fontStyle & 8 /* FontStyle.Strikethrough */) {\n            className += ' mtks';\n        }\n        return className;\n    }\n    static getInlineStyleFromMetadata(metadata, colorMap) {\n        const foreground = this.getForeground(metadata);\n        const fontStyle = this.getFontStyle(metadata);\n        let result = `color: ${colorMap[foreground]};`;\n        if (fontStyle & 1 /* FontStyle.Italic */) {\n            result += 'font-style: italic;';\n        }\n        if (fontStyle & 2 /* FontStyle.Bold */) {\n            result += 'font-weight: bold;';\n        }\n        let textDecoration = '';\n        if (fontStyle & 4 /* FontStyle.Underline */) {\n            textDecoration += ' underline';\n        }\n        if (fontStyle & 8 /* FontStyle.Strikethrough */) {\n            textDecoration += ' line-through';\n        }\n        if (textDecoration) {\n            result += `text-decoration:${textDecoration};`;\n        }\n        return result;\n    }\n    static getPresentationFromMetadata(metadata) {\n        const foreground = this.getForeground(metadata);\n        const fontStyle = this.getFontStyle(metadata);\n        return {\n            foreground: foreground,\n            italic: Boolean(fontStyle & 1 /* FontStyle.Italic */),\n            bold: Boolean(fontStyle & 2 /* FontStyle.Bold */),\n            underline: Boolean(fontStyle & 4 /* FontStyle.Underline */),\n            strikethrough: Boolean(fontStyle & 8 /* FontStyle.Strikethrough */),\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ILanguageService = createDecorator('languageService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport var IndentAction;\n(function (IndentAction) {\n    /**\n     * Insert new line and copy the previous line's indentation.\n     */\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n    /**\n     * Insert new line and indent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n    /**\n     * Insert two new lines:\n     *  - the first one indented which will hold the cursor\n     *  - the second one at the same indentation level\n     */\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n    /**\n     * Insert new line and outdent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\n/**\n * @internal\n */\nexport class StandardAutoClosingPairConditional {\n    constructor(source) {\n        this._neutralCharacter = null;\n        this._neutralCharacterSearched = false;\n        this.open = source.open;\n        this.close = source.close;\n        // initially allowed in all tokens\n        this._inString = true;\n        this._inComment = true;\n        this._inRegEx = true;\n        if (Array.isArray(source.notIn)) {\n            for (let i = 0, len = source.notIn.length; i < len; i++) {\n                const notIn = source.notIn[i];\n                switch (notIn) {\n                    case 'string':\n                        this._inString = false;\n                        break;\n                    case 'comment':\n                        this._inComment = false;\n                        break;\n                    case 'regex':\n                        this._inRegEx = false;\n                        break;\n                }\n            }\n        }\n    }\n    isOK(standardToken) {\n        switch (standardToken) {\n            case 0 /* StandardTokenType.Other */:\n                return true;\n            case 1 /* StandardTokenType.Comment */:\n                return this._inComment;\n            case 2 /* StandardTokenType.String */:\n                return this._inString;\n            case 3 /* StandardTokenType.RegEx */:\n                return this._inRegEx;\n        }\n    }\n    shouldAutoClose(context, column) {\n        // Always complete on empty line\n        if (context.getTokenCount() === 0) {\n            return true;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 2);\n        const standardTokenType = context.getStandardTokenType(tokenIndex);\n        return this.isOK(standardTokenType);\n    }\n    _findNeutralCharacterInRange(fromCharCode, toCharCode) {\n        for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {\n            const character = String.fromCharCode(charCode);\n            if (!this.open.includes(character) && !this.close.includes(character)) {\n                return character;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close\n     */\n    findNeutralCharacter() {\n        if (!this._neutralCharacterSearched) {\n            this._neutralCharacterSearched = true;\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(48 /* CharCode.Digit0 */, 57 /* CharCode.Digit9 */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(97 /* CharCode.a */, 122 /* CharCode.z */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(65 /* CharCode.A */, 90 /* CharCode.Z */);\n            }\n        }\n        return this._neutralCharacter;\n    }\n}\n/**\n * @internal\n */\nexport class AutoClosingPairs {\n    constructor(autoClosingPairs) {\n        this.autoClosingPairsOpenByStart = new Map();\n        this.autoClosingPairsOpenByEnd = new Map();\n        this.autoClosingPairsCloseByStart = new Map();\n        this.autoClosingPairsCloseByEnd = new Map();\n        this.autoClosingPairsCloseSingleChar = new Map();\n        for (const pair of autoClosingPairs) {\n            appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\n            appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\n            appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\n            appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\n            if (pair.close.length === 1 && pair.open.length === 1) {\n                appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\n            }\n        }\n    }\n}\nfunction appendEntry(target, key, value) {\n    if (target.has(key)) {\n        target.get(key).push(value);\n    }\n    else {\n        target.set(key, [value]);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { StandardAutoClosingPairConditional } from '../languageConfiguration.js';\nexport class CharacterPairSupport {\n    static { this.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = ';:.,=}])> \\n\\t'; }\n    static { this.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = '\\'\"`;:.,=}])> \\n\\t'; }\n    constructor(config) {\n        if (config.autoClosingPairs) {\n            this._autoClosingPairs = config.autoClosingPairs.map(el => new StandardAutoClosingPairConditional(el));\n        }\n        else if (config.brackets) {\n            this._autoClosingPairs = config.brackets.map(b => new StandardAutoClosingPairConditional({ open: b[0], close: b[1] }));\n        }\n        else {\n            this._autoClosingPairs = [];\n        }\n        if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {\n            const docComment = config.__electricCharacterSupport.docComment;\n            // IDocComment is legacy, only partially supported\n            this._autoClosingPairs.push(new StandardAutoClosingPairConditional({ open: docComment.open, close: docComment.close || '' }));\n        }\n        this._autoCloseBeforeForQuotes = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES;\n        this._autoCloseBeforeForBrackets = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS;\n        this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;\n    }\n    getAutoClosingPairs() {\n        return this._autoClosingPairs;\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return (forQuotes ? this._autoCloseBeforeForQuotes : this._autoCloseBeforeForBrackets);\n    }\n    getSurroundingPairs() {\n        return this._surroundingPairs;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { distinct } from '../../../../base/common/arrays.js';\nimport { ignoreBracketsInToken } from '../supports.js';\nimport { BracketsUtils } from './richEditBrackets.js';\nexport class BracketElectricCharacterSupport {\n    constructor(richEditBrackets) {\n        this._richEditBrackets = richEditBrackets;\n    }\n    getElectricCharacters() {\n        const result = [];\n        if (this._richEditBrackets) {\n            for (const bracket of this._richEditBrackets.brackets) {\n                for (const close of bracket.close) {\n                    const lastChar = close.charAt(close.length - 1);\n                    result.push(lastChar);\n                }\n            }\n        }\n        return distinct(result);\n    }\n    onElectricCharacter(character, context, column) {\n        if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {\n            return null;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 1);\n        if (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {\n            return null;\n        }\n        const reversedBracketRegex = this._richEditBrackets.reversedRegex;\n        const text = context.getLineContent().substring(0, column - 1) + character;\n        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, 1, text, 0, text.length);\n        if (!r) {\n            return null;\n        }\n        const bracketText = text.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        const isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];\n        if (isOpen) {\n            return null;\n        }\n        const textBeforeBracket = context.getActualLineContentBefore(r.startColumn - 1);\n        if (!/^\\s*$/.test(textBeforeBracket)) {\n            // There is other text on the line before the bracket\n            return null;\n        }\n        return {\n            matchOpenBracket: bracketText\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction resetGlobalRegex(reg) {\n    if (reg.global) {\n        reg.lastIndex = 0;\n    }\n    return true;\n}\nexport class IndentRulesSupport {\n    constructor(indentationRules) {\n        this._indentationRules = indentationRules;\n    }\n    shouldIncrease(text) {\n        if (this._indentationRules) {\n            if (this._indentationRules.increaseIndentPattern && resetGlobalRegex(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(text)) {\n                return true;\n            }\n            // if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {\n            // \treturn true;\n            // }\n        }\n        return false;\n    }\n    shouldDecrease(text) {\n        if (this._indentationRules && this._indentationRules.decreaseIndentPattern && resetGlobalRegex(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIndentNextLine(text) {\n        if (this._indentationRules && this._indentationRules.indentNextLinePattern && resetGlobalRegex(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIgnore(text) {\n        // the text matches `unIndentedLinePattern`\n        if (this._indentationRules && this._indentationRules.unIndentedLinePattern && resetGlobalRegex(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    getIndentMetadata(text) {\n        let ret = 0;\n        if (this.shouldIncrease(text)) {\n            ret += 1 /* IndentConsts.INCREASE_MASK */;\n        }\n        if (this.shouldDecrease(text)) {\n            ret += 2 /* IndentConsts.DECREASE_MASK */;\n        }\n        if (this.shouldIndentNextLine(text)) {\n            ret += 4 /* IndentConsts.INDENT_NEXTLINE_MASK */;\n        }\n        if (this.shouldIgnore(text)) {\n            ret += 8 /* IndentConsts.UNINDENT_MASK */;\n        }\n        return ret;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { IndentAction } from '../languageConfiguration.js';\nexport class OnEnterSupport {\n    constructor(opts) {\n        opts = opts || {};\n        opts.brackets = opts.brackets || [\n            ['(', ')'],\n            ['{', '}'],\n            ['[', ']']\n        ];\n        this._brackets = [];\n        opts.brackets.forEach((bracket) => {\n            const openRegExp = OnEnterSupport._createOpenBracketRegExp(bracket[0]);\n            const closeRegExp = OnEnterSupport._createCloseBracketRegExp(bracket[1]);\n            if (openRegExp && closeRegExp) {\n                this._brackets.push({\n                    open: bracket[0],\n                    openRegExp: openRegExp,\n                    close: bracket[1],\n                    closeRegExp: closeRegExp,\n                });\n            }\n        });\n        this._regExpRules = opts.onEnterRules || [];\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        // (1): `regExpRules`\n        if (autoIndent >= 3 /* EditorAutoIndentStrategy.Advanced */) {\n            for (let i = 0, len = this._regExpRules.length; i < len; i++) {\n                const rule = this._regExpRules[i];\n                const regResult = [{\n                        reg: rule.beforeText,\n                        text: beforeEnterText\n                    }, {\n                        reg: rule.afterText,\n                        text: afterEnterText\n                    }, {\n                        reg: rule.previousLineText,\n                        text: previousLineText\n                    }].every((obj) => {\n                    if (!obj.reg) {\n                        return true;\n                    }\n                    obj.reg.lastIndex = 0; // To disable the effect of the \"g\" flag.\n                    return obj.reg.test(obj.text);\n                });\n                if (regResult) {\n                    return rule.action;\n                }\n            }\n        }\n        // (2): Special indent-outdent\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {\n                        return { indentAction: IndentAction.IndentOutdent };\n                    }\n                }\n            }\n        }\n        // (4): Open bracket based logic\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText)) {\n                        return { indentAction: IndentAction.Indent };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    static _createOpenBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(0))) {\n            str = '\\\\b' + str;\n        }\n        str += '\\\\s*$';\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _createCloseBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(str.length - 1))) {\n            str = str + '\\\\b';\n        }\n        str = '^\\\\s*' + str;\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _safeRegExp(def) {\n        try {\n            return new RegExp(def);\n        }\n        catch (err) {\n            onUnexpectedError(err);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CachedFunction } from '../../../../base/common/cache.js';\nimport { createBracketOrRegExp } from './richEditBrackets.js';\n/**\n * Captures all bracket related configurations for a single language.\n * Immutable.\n*/\nexport class LanguageBracketsConfiguration {\n    constructor(languageId, config) {\n        this.languageId = languageId;\n        const bracketPairs = config.brackets ? filterValidBrackets(config.brackets) : [];\n        const openingBracketInfos = new CachedFunction((bracket) => {\n            const closing = new Set();\n            return {\n                info: new OpeningBracketKind(this, bracket, closing),\n                closing,\n            };\n        });\n        const closingBracketInfos = new CachedFunction((bracket) => {\n            const opening = new Set();\n            const openingColorized = new Set();\n            return {\n                info: new ClosingBracketKind(this, bracket, opening, openingColorized),\n                opening,\n                openingColorized,\n            };\n        });\n        for (const [open, close] of bracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.opening.add(opening.info);\n        }\n        // Treat colorized brackets as brackets, and mark them as colorized.\n        const colorizedBracketPairs = config.colorizedBracketPairs\n            ? filterValidBrackets(config.colorizedBracketPairs)\n            // If not configured: Take all brackets except `<` ... `>`\n            // Many languages set < ... > as bracket pair, even though they also use it as comparison operator.\n            // This leads to problems when colorizing this bracket, so we exclude it if not explicitly configured otherwise.\n            // https://github.com/microsoft/vscode/issues/132476\n            : bracketPairs.filter((p) => !(p[0] === '<' && p[1] === '>'));\n        for (const [open, close] of colorizedBracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.openingColorized.add(opening.info);\n            closing.opening.add(opening.info);\n        }\n        this._openingBrackets = new Map([...openingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n        this._closingBrackets = new Map([...closingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get openingBrackets() {\n        return [...this._openingBrackets.values()];\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get closingBrackets() {\n        return [...this._closingBrackets.values()];\n    }\n    getOpeningBracketInfo(bracketText) {\n        return this._openingBrackets.get(bracketText);\n    }\n    getClosingBracketInfo(bracketText) {\n        return this._closingBrackets.get(bracketText);\n    }\n    getBracketInfo(bracketText) {\n        return this.getOpeningBracketInfo(bracketText) || this.getClosingBracketInfo(bracketText);\n    }\n    getBracketRegExp(options) {\n        const brackets = Array.from([...this._openingBrackets.keys(), ...this._closingBrackets.keys()]);\n        return createBracketOrRegExp(brackets, options);\n    }\n}\nfunction filterValidBrackets(bracketPairs) {\n    return bracketPairs.filter(([open, close]) => open !== '' && close !== '');\n}\nexport class BracketKindBase {\n    constructor(config, bracketText) {\n        this.config = config;\n        this.bracketText = bracketText;\n    }\n    get languageId() {\n        return this.config.languageId;\n    }\n}\nexport class OpeningBracketKind extends BracketKindBase {\n    constructor(config, bracketText, openedBrackets) {\n        super(config, bracketText);\n        this.openedBrackets = openedBrackets;\n        this.isOpeningBracket = true;\n    }\n}\nexport class ClosingBracketKind extends BracketKindBase {\n    constructor(config, bracketText, \n    /**\n     * Non empty array of all opening brackets this bracket closes.\n    */\n    openingBrackets, openingColorizedBrackets) {\n        super(config, bracketText);\n        this.openingBrackets = openingBrackets;\n        this.openingColorizedBrackets = openingColorizedBrackets;\n        this.isOpeningBracket = false;\n    }\n    /**\n     * Checks if this bracket closes the given other bracket.\n     * If the bracket infos come from different configurations, this method will return false.\n    */\n    closes(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingBrackets.has(other);\n    }\n    closesColorized(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingColorizedBrackets.has(other);\n    }\n    getOpeningBrackets() {\n        return [...this.openingBrackets];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../core/wordHelper.js';\nimport { AutoClosingPairs } from './languageConfiguration.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ILanguageService } from './language.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { PLAINTEXT_LANGUAGE_ID } from './modesRegistry.js';\nimport { LanguageBracketsConfiguration } from './supports/languageBracketsConfiguration.js';\nexport class LanguageConfigurationServiceChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n    affects(languageId) {\n        return !this.languageId ? true : this.languageId === languageId;\n    }\n}\nexport const ILanguageConfigurationService = createDecorator('languageConfigurationService');\nlet LanguageConfigurationService = class LanguageConfigurationService extends Disposable {\n    constructor(configurationService, languageService) {\n        super();\n        this.configurationService = configurationService;\n        this.languageService = languageService;\n        this._registry = this._register(new LanguageConfigurationRegistry());\n        this.onDidChangeEmitter = this._register(new Emitter());\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.configurations = new Map();\n        const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));\n        this._register(this.configurationService.onDidChangeConfiguration((e) => {\n            const globalConfigChanged = e.change.keys.some((k) => languageConfigKeys.has(k));\n            const localConfigChanged = e.change.overrides\n                .filter(([overrideLangName, keys]) => keys.some((k) => languageConfigKeys.has(k)))\n                .map(([overrideLangName]) => overrideLangName);\n            if (globalConfigChanged) {\n                this.configurations.clear();\n                this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(undefined));\n            }\n            else {\n                for (const languageId of localConfigChanged) {\n                    if (this.languageService.isRegisteredLanguageId(languageId)) {\n                        this.configurations.delete(languageId);\n                        this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));\n                    }\n                }\n            }\n        }));\n        this._register(this._registry.onDidChange((e) => {\n            this.configurations.delete(e.languageId);\n            this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));\n        }));\n    }\n    register(languageId, configuration, priority) {\n        return this._registry.register(languageId, configuration, priority);\n    }\n    getLanguageConfiguration(languageId) {\n        let result = this.configurations.get(languageId);\n        if (!result) {\n            result = computeConfig(languageId, this._registry, this.configurationService, this.languageService);\n            this.configurations.set(languageId, result);\n        }\n        return result;\n    }\n};\nLanguageConfigurationService = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ILanguageService)\n], LanguageConfigurationService);\nexport { LanguageConfigurationService };\nfunction computeConfig(languageId, registry, configurationService, languageService) {\n    let languageConfig = registry.getLanguageConfiguration(languageId);\n    if (!languageConfig) {\n        if (!languageService.isRegisteredLanguageId(languageId)) {\n            // this happens for the null language, which can be returned by monarch.\n            // Instead of throwing an error, we just return a default config.\n            return new ResolvedLanguageConfiguration(languageId, {});\n        }\n        languageConfig = new ResolvedLanguageConfiguration(languageId, {});\n    }\n    const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);\n    const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);\n    const config = new ResolvedLanguageConfiguration(languageConfig.languageId, data);\n    return config;\n}\nconst customizedLanguageConfigKeys = {\n    brackets: 'editor.language.brackets',\n    colorizedBracketPairs: 'editor.language.colorizedBracketPairs'\n};\nfunction getCustomizedLanguageConfig(languageId, configurationService) {\n    const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, {\n        overrideIdentifier: languageId,\n    });\n    const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, {\n        overrideIdentifier: languageId,\n    });\n    return {\n        brackets: validateBracketPairs(brackets),\n        colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs),\n    };\n}\nfunction validateBracketPairs(data) {\n    if (!Array.isArray(data)) {\n        return undefined;\n    }\n    return data.map(pair => {\n        if (!Array.isArray(pair) || pair.length !== 2) {\n            return undefined;\n        }\n        return [pair[0], pair[1]];\n    }).filter((p) => !!p);\n}\nexport function getIndentationAtPosition(model, lineNumber, column) {\n    const lineText = model.getLineContent(lineNumber);\n    let indentation = strings.getLeadingWhitespace(lineText);\n    if (indentation.length > column - 1) {\n        indentation = indentation.substring(0, column - 1);\n    }\n    return indentation;\n}\nclass ComposedLanguageConfiguration {\n    constructor(languageId) {\n        this.languageId = languageId;\n        this._resolved = null;\n        this._entries = [];\n        this._order = 0;\n        this._resolved = null;\n    }\n    register(configuration, priority) {\n        const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);\n        this._entries.push(entry);\n        this._resolved = null;\n        return toDisposable(() => {\n            for (let i = 0; i < this._entries.length; i++) {\n                if (this._entries[i] === entry) {\n                    this._entries.splice(i, 1);\n                    this._resolved = null;\n                    break;\n                }\n            }\n        });\n    }\n    getResolvedConfiguration() {\n        if (!this._resolved) {\n            const config = this._resolve();\n            if (config) {\n                this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);\n            }\n        }\n        return this._resolved;\n    }\n    _resolve() {\n        if (this._entries.length === 0) {\n            return null;\n        }\n        this._entries.sort(LanguageConfigurationContribution.cmp);\n        return combineLanguageConfigurations(this._entries.map(e => e.configuration));\n    }\n}\nfunction combineLanguageConfigurations(configs) {\n    let result = {\n        comments: undefined,\n        brackets: undefined,\n        wordPattern: undefined,\n        indentationRules: undefined,\n        onEnterRules: undefined,\n        autoClosingPairs: undefined,\n        surroundingPairs: undefined,\n        autoCloseBefore: undefined,\n        folding: undefined,\n        colorizedBracketPairs: undefined,\n        __electricCharacterSupport: undefined,\n    };\n    for (const entry of configs) {\n        result = {\n            comments: entry.comments || result.comments,\n            brackets: entry.brackets || result.brackets,\n            wordPattern: entry.wordPattern || result.wordPattern,\n            indentationRules: entry.indentationRules || result.indentationRules,\n            onEnterRules: entry.onEnterRules || result.onEnterRules,\n            autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,\n            surroundingPairs: entry.surroundingPairs || result.surroundingPairs,\n            autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,\n            folding: entry.folding || result.folding,\n            colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,\n            __electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport,\n        };\n    }\n    return result;\n}\nclass LanguageConfigurationContribution {\n    constructor(configuration, priority, order) {\n        this.configuration = configuration;\n        this.priority = priority;\n        this.order = order;\n    }\n    static cmp(a, b) {\n        if (a.priority === b.priority) {\n            // higher order last\n            return a.order - b.order;\n        }\n        // higher priority last\n        return a.priority - b.priority;\n    }\n}\nexport class LanguageConfigurationChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n}\nexport class LanguageConfigurationRegistry extends Disposable {\n    constructor() {\n        super();\n        this._entries = new Map();\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        this._register(this.register(PLAINTEXT_LANGUAGE_ID, {\n            brackets: [\n                ['(', ')'],\n                ['[', ']'],\n                ['{', '}'],\n            ],\n            surroundingPairs: [\n                { open: '{', close: '}' },\n                { open: '[', close: ']' },\n                { open: '(', close: ')' },\n                { open: '<', close: '>' },\n                { open: '\\\"', close: '\\\"' },\n                { open: '\\'', close: '\\'' },\n                { open: '`', close: '`' },\n            ],\n            colorizedBracketPairs: [],\n            folding: {\n                offSide: true\n            }\n        }, 0));\n    }\n    /**\n     * @param priority Use a higher number for higher priority\n     */\n    register(languageId, configuration, priority = 0) {\n        let entries = this._entries.get(languageId);\n        if (!entries) {\n            entries = new ComposedLanguageConfiguration(languageId);\n            this._entries.set(languageId, entries);\n        }\n        const disposable = entries.register(configuration, priority);\n        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        return toDisposable(() => {\n            disposable.dispose();\n            this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        });\n    }\n    getLanguageConfiguration(languageId) {\n        const entries = this._entries.get(languageId);\n        return entries?.getResolvedConfiguration() || null;\n    }\n}\n/**\n * Immutable.\n*/\nexport class ResolvedLanguageConfiguration {\n    constructor(languageId, underlyingConfig) {\n        this.languageId = languageId;\n        this.underlyingConfig = underlyingConfig;\n        this._brackets = null;\n        this._electricCharacter = null;\n        this._onEnterSupport =\n            this.underlyingConfig.brackets ||\n                this.underlyingConfig.indentationRules ||\n                this.underlyingConfig.onEnterRules\n                ? new OnEnterSupport(this.underlyingConfig)\n                : null;\n        this.comments = ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);\n        this.characterPair = new CharacterPairSupport(this.underlyingConfig);\n        this.wordDefinition = this.underlyingConfig.wordPattern || DEFAULT_WORD_REGEXP;\n        this.indentationRules = this.underlyingConfig.indentationRules;\n        if (this.underlyingConfig.indentationRules) {\n            this.indentRulesSupport = new IndentRulesSupport(this.underlyingConfig.indentationRules);\n        }\n        else {\n            this.indentRulesSupport = null;\n        }\n        this.foldingRules = this.underlyingConfig.folding || {};\n        this.bracketsNew = new LanguageBracketsConfiguration(languageId, this.underlyingConfig);\n    }\n    getWordDefinition() {\n        return ensureValidWordDefinition(this.wordDefinition);\n    }\n    get brackets() {\n        if (!this._brackets && this.underlyingConfig.brackets) {\n            this._brackets = new RichEditBrackets(this.languageId, this.underlyingConfig.brackets);\n        }\n        return this._brackets;\n    }\n    get electricCharacter() {\n        if (!this._electricCharacter) {\n            this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n        }\n        return this._electricCharacter;\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        if (!this._onEnterSupport) {\n            return null;\n        }\n        return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    }\n    getAutoClosingPairs() {\n        return new AutoClosingPairs(this.characterPair.getAutoClosingPairs());\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return this.characterPair.getAutoCloseBeforeSet(forQuotes);\n    }\n    getSurroundingPairs() {\n        return this.characterPair.getSurroundingPairs();\n    }\n    static _handleComments(conf) {\n        const commentRule = conf.comments;\n        if (!commentRule) {\n            return null;\n        }\n        // comment configuration\n        const comments = {};\n        if (commentRule.lineComment) {\n            comments.lineCommentToken = commentRule.lineComment;\n        }\n        if (commentRule.blockComment) {\n            const [blockStart, blockEnd] = commentRule.blockComment;\n            comments.blockCommentStartToken = blockStart;\n            comments.blockCommentEndToken = blockEnd;\n        }\n        return comments;\n    }\n}\nregisterSingleton(ILanguageConfigurationService, LanguageConfigurationService, 1 /* InstantiationType.Delayed */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Token, TokenizationResult, EncodedTokenizationResult } from '../languages.js';\nexport const NullState = new class {\n    clone() {\n        return this;\n    }\n    equals(other) {\n        return (this === other);\n    }\n};\nexport function nullTokenize(languageId, state) {\n    return new TokenizationResult([new Token(0, '', languageId)], state);\n}\nexport function nullTokenizeEncoded(languageId, state) {\n    const tokens = new Uint32Array(2);\n    tokens[0] = 0;\n    tokens[1] = ((languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    return new EncodedTokenizationResult(tokens, state === null ? NullState : state);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function createScopedLineTokens(context, offset) {\n    const tokenCount = context.getCount();\n    const tokenIndex = context.findTokenIndexAtOffset(offset);\n    const desiredLanguageId = context.getLanguageId(tokenIndex);\n    let lastTokenIndex = tokenIndex;\n    while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {\n        lastTokenIndex++;\n    }\n    let firstTokenIndex = tokenIndex;\n    while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {\n        firstTokenIndex--;\n    }\n    return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));\n}\nexport class ScopedLineTokens {\n    constructor(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {\n        this._scopedLineTokensBrand = undefined;\n        this._actual = actual;\n        this.languageId = languageId;\n        this._firstTokenIndex = firstTokenIndex;\n        this._lastTokenIndex = lastTokenIndex;\n        this.firstCharOffset = firstCharOffset;\n        this._lastCharOffset = lastCharOffset;\n        this.languageIdCodec = actual.languageIdCodec;\n    }\n    getLineContent() {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);\n    }\n    getLineLength() {\n        return this._lastCharOffset - this.firstCharOffset;\n    }\n    getActualLineContentBefore(offset) {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(0, this.firstCharOffset + offset);\n    }\n    getTokenCount() {\n        return this._lastTokenIndex - this._firstTokenIndex;\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);\n    }\n    toIViewLineTokens() {\n        return this._actual.sliceAndInflate(this.firstCharOffset, this._lastCharOffset, 0);\n    }\n}\nexport function ignoreBracketsInToken(standardTokenType) {\n    return (standardTokenType & 3 /* IgnoreBracketsInTokens.value */) !== 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n    constructor(languageId, index, open, close, forwardRegex, reversedRegex) {\n        this._richEditBracketBrand = undefined;\n        this.languageId = languageId;\n        this.index = index;\n        this.open = open;\n        this.close = close;\n        this.forwardRegex = forwardRegex;\n        this.reversedRegex = reversedRegex;\n        this._openSet = RichEditBracket._toSet(this.open);\n        this._closeSet = RichEditBracket._toSet(this.close);\n    }\n    /**\n     * Check if the provided `text` is an open bracket in this group.\n     */\n    isOpen(text) {\n        return this._openSet.has(text);\n    }\n    /**\n     * Check if the provided `text` is a close bracket in this group.\n     */\n    isClose(text) {\n        return this._closeSet.has(text);\n    }\n    static _toSet(arr) {\n        const result = new Set();\n        for (const element of arr) {\n            result.add(element);\n        }\n        return result;\n    }\n}\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets) {\n    const N = brackets.length;\n    brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n    const group = [];\n    for (let i = 0; i < N; i++) {\n        group[i] = i;\n    }\n    const areOverlapping = (a, b) => {\n        const [aOpen, aClose] = a;\n        const [bOpen, bClose] = b;\n        return (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\n    };\n    const mergeGroups = (g1, g2) => {\n        const newG = Math.min(g1, g2);\n        const oldG = Math.max(g1, g2);\n        for (let i = 0; i < N; i++) {\n            if (group[i] === oldG) {\n                group[i] = newG;\n            }\n        }\n    };\n    // group together brackets that have the same open or the same close sequence\n    for (let i = 0; i < N; i++) {\n        const a = brackets[i];\n        for (let j = i + 1; j < N; j++) {\n            const b = brackets[j];\n            if (areOverlapping(a, b)) {\n                mergeGroups(group[i], group[j]);\n            }\n        }\n    }\n    const result = [];\n    for (let g = 0; g < N; g++) {\n        const currentOpen = [];\n        const currentClose = [];\n        for (let i = 0; i < N; i++) {\n            if (group[i] === g) {\n                const [open, close] = brackets[i];\n                currentOpen.push(open);\n                currentClose.push(close);\n            }\n        }\n        if (currentOpen.length > 0) {\n            result.push({\n                open: currentOpen,\n                close: currentClose\n            });\n        }\n    }\n    return result;\n}\nexport class RichEditBrackets {\n    constructor(languageId, _brackets) {\n        this._richEditBracketsBrand = undefined;\n        const brackets = groupFuzzyBrackets(_brackets);\n        this.brackets = brackets.map((b, index) => {\n            return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n        });\n        this.forwardRegex = getRegexForBrackets(this.brackets);\n        this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n        this.textIsBracket = {};\n        this.textIsOpenBracket = {};\n        this.maxBracketLength = 0;\n        for (const bracket of this.brackets) {\n            for (const open of bracket.open) {\n                this.textIsBracket[open] = bracket;\n                this.textIsOpenBracket[open] = true;\n                this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n            }\n            for (const close of bracket.close) {\n                this.textIsBracket[close] = bracket;\n                this.textIsOpenBracket[close] = false;\n                this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n            }\n        }\n    }\n}\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n    for (let i = 0, len = brackets.length; i < len; i++) {\n        if (i === currentIndex) {\n            continue;\n        }\n        const bracket = brackets[i];\n        for (const open of bracket.open) {\n            if (open.indexOf(str) >= 0) {\n                dest.push(open);\n            }\n        }\n        for (const close of bracket.close) {\n            if (close.indexOf(str) >= 0) {\n                dest.push(close);\n            }\n        }\n    }\n}\nfunction lengthcmp(a, b) {\n    return a.length - b.length;\n}\nfunction unique(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const result = [];\n    const seen = new Set();\n    for (const element of arr) {\n        if (seen.has(element)) {\n            continue;\n        }\n        result.push(element);\n        seen.add(element);\n    }\n    return result;\n}\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction prepareBracketForRegExp(str) {\n    // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n    const insertWordBoundaries = (/^[\\w ]+$/.test(str));\n    str = strings.escapeRegExpCharacters(str);\n    return (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n}\nexport function createBracketOrRegExp(pieces, options) {\n    const regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n    return strings.createRegExp(regexStr, true, options);\n}\nconst toReversedString = (function () {\n    function reverse(str) {\n        // create a Uint16Array and then use a TextDecoder to create a string\n        const arr = new Uint16Array(str.length);\n        let offset = 0;\n        for (let i = str.length - 1; i >= 0; i--) {\n            arr[offset++] = str.charCodeAt(i);\n        }\n        return stringBuilder.getPlatformTextDecoder().decode(arr);\n    }\n    let lastInput = null;\n    let lastOutput = null;\n    return function toReversedString(str) {\n        if (lastInput !== str) {\n            lastInput = str;\n            lastOutput = reverse(lastInput);\n        }\n        return lastOutput;\n    };\n})();\nexport class BracketsUtils {\n    static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n        const m = reversedText.match(reversedBracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = reversedText.length - (m.index || 0);\n        const matchLength = m[0].length;\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n    }\n    static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n        const reversedLineText = toReversedString(lineText);\n        const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n    }\n    static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n        const m = text.match(bracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = m.index || 0;\n        const matchLength = m[0].length;\n        if (matchLength === 0) {\n            return null;\n        }\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n    }\n    static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        const substr = lineText.substring(startOffset, endOffset);\n        return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n/**\n * The base implementation for all AST nodes.\n*/\nclass BaseAstNode {\n    /**\n     * The length of the entire node, which should equal the sum of lengths of all children.\n    */\n    get length() {\n        return this._length;\n    }\n    constructor(length) {\n        this._length = length;\n    }\n}\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n    static create(openingBracket, child, closingBracket) {\n        let length = openingBracket.length;\n        if (child) {\n            length = lengthAdd(length, child.length);\n        }\n        if (closingBracket) {\n            length = lengthAdd(length, closingBracket.length);\n        }\n        return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 2 /* AstNodeKind.Pair */;\n    }\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 3;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this.openingBracket;\n            case 1: return this.child;\n            case 2: return this.closingBracket;\n        }\n        throw new Error('Invalid child index');\n    }\n    /**\n     * Avoid using this property, it allocates an array!\n    */\n    get children() {\n        const result = [];\n        result.push(this.openingBracket);\n        if (this.child) {\n            result.push(this.child);\n        }\n        if (this.closingBracket) {\n            result.push(this.closingBracket);\n        }\n        return result;\n    }\n    constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {\n        super(length);\n        this.openingBracket = openingBracket;\n        this.child = child;\n        this.closingBracket = closingBracket;\n        this.missingOpeningBracketIds = missingOpeningBracketIds;\n    }\n    canBeReused(openBracketIds) {\n        if (this.closingBracket === null) {\n            // Unclosed pair ast nodes only\n            // end at the end of the document\n            // or when a parent node is closed.\n            // This could be improved:\n            // Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n            return false;\n        }\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        return true;\n    }\n    deepClone() {\n        return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class ListAstNode extends BaseAstNode {\n    /**\n     * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n    */\n    static create23(item1, item2, item3, immutable = false) {\n        let length = item1.length;\n        let missingBracketIds = item1.missingOpeningBracketIds;\n        if (item1.listHeight !== item2.listHeight) {\n            throw new Error('Invalid list heights');\n        }\n        length = lengthAdd(length, item2.length);\n        missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n        if (item3) {\n            if (item1.listHeight !== item3.listHeight) {\n                throw new Error('Invalid list heights');\n            }\n            length = lengthAdd(length, item3.length);\n            missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n        }\n        return immutable\n            ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n            : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n    }\n    static getEmpty() {\n        return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 4 /* AstNodeKind.List */;\n    }\n    get missingOpeningBracketIds() {\n        return this._missingOpeningBracketIds;\n    }\n    /**\n     * Use ListAstNode.create.\n    */\n    constructor(length, listHeight, _missingOpeningBracketIds) {\n        super(length);\n        this.listHeight = listHeight;\n        this._missingOpeningBracketIds = _missingOpeningBracketIds;\n        this.cachedMinIndentation = -1;\n    }\n    throwIfImmutable() {\n        // NOOP\n    }\n    makeLastElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const lastChild = this.getChild(childCount - 1);\n        const mutable = lastChild.kind === 4 /* AstNodeKind.List */ ? lastChild.toMutable() : lastChild;\n        if (lastChild !== mutable) {\n            this.setChild(childCount - 1, mutable);\n        }\n        return mutable;\n    }\n    makeFirstElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const firstChild = this.getChild(0);\n        const mutable = firstChild.kind === 4 /* AstNodeKind.List */ ? firstChild.toMutable() : firstChild;\n        if (firstChild !== mutable) {\n            this.setChild(0, mutable);\n        }\n        return mutable;\n    }\n    canBeReused(openBracketIds) {\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        if (this.childrenLength === 0) {\n            // Don't reuse empty lists.\n            return false;\n        }\n        let lastChild = this;\n        while (lastChild.kind === 4 /* AstNodeKind.List */) {\n            const lastLength = lastChild.childrenLength;\n            if (lastLength === 0) {\n                // Empty lists should never be contained in other lists.\n                throw new BugIndicatingError();\n            }\n            lastChild = lastChild.getChild(lastLength - 1);\n        }\n        return lastChild.canBeReused(openBracketIds);\n    }\n    handleChildrenChanged() {\n        this.throwIfImmutable();\n        const count = this.childrenLength;\n        let length = this.getChild(0).length;\n        let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;\n        for (let i = 1; i < count; i++) {\n            const child = this.getChild(i);\n            length = lengthAdd(length, child.length);\n            unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n        }\n        this._length = length;\n        this._missingOpeningBracketIds = unopenedBrackets;\n        this.cachedMinIndentation = -1;\n    }\n    computeMinIndentation(offset, textModel) {\n        if (this.cachedMinIndentation !== -1) {\n            return this.cachedMinIndentation;\n        }\n        let minIndentation = Number.MAX_SAFE_INTEGER;\n        let childOffset = offset;\n        for (let i = 0; i < this.childrenLength; i++) {\n            const child = this.getChild(i);\n            if (child) {\n                minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n                childOffset = lengthAdd(childOffset, child.length);\n            }\n        }\n        this.cachedMinIndentation = minIndentation;\n        return minIndentation;\n    }\n}\nclass TwoThreeListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._item3 !== null ? 3 : 2;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this._item1;\n            case 1: return this._item2;\n            case 2: return this._item3;\n        }\n        throw new Error('Invalid child index');\n    }\n    setChild(idx, node) {\n        switch (idx) {\n            case 0:\n                this._item1 = node;\n                return;\n            case 1:\n                this._item2 = node;\n                return;\n            case 2:\n                this._item3 = node;\n                return;\n        }\n        throw new Error('Invalid child index');\n    }\n    get children() {\n        return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n    }\n    get item1() {\n        return this._item1;\n    }\n    get item2() {\n        return this._item2;\n    }\n    get item3() {\n        return this._item3;\n    }\n    constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._item1 = _item1;\n        this._item2 = _item2;\n        this._item3 = _item3;\n    }\n    deepClone() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot append to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = node;\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    prependChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot prepend to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = this._item2;\n        this._item2 = this._item1;\n        this._item1 = node;\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item1;\n        this._item1 = this._item2;\n        this._item2 = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n    toMutable() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._children.length;\n    }\n    getChild(idx) {\n        return this._children[idx];\n    }\n    setChild(idx, child) {\n        this._children[idx] = child;\n    }\n    get children() {\n        return this._children;\n    }\n    constructor(length, listHeight, _children, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._children = _children;\n    }\n    deepClone() {\n        const children = new Array(this._children.length);\n        for (let i = 0; i < this._children.length; i++) {\n            children[i] = this._children[i].deepClone();\n        }\n        return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.push(node);\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        this.throwIfImmutable();\n        const item = this._children.pop();\n        this.handleChildrenChanged();\n        return item;\n    }\n    prependChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.unshift(node);\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        this.throwIfImmutable();\n        const item = this._children.shift();\n        this.handleChildrenChanged();\n        return item;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n    toMutable() {\n        return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\nconst emptyArray = [];\nclass ImmutableLeafAstNode extends BaseAstNode {\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 0;\n    }\n    getChild(idx) {\n        return null;\n    }\n    get children() {\n        return emptyArray;\n    }\n    deepClone() {\n        return this;\n    }\n}\nexport class TextAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 0 /* AstNodeKind.Text */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    canBeReused(_openedBracketIds) {\n        return true;\n    }\n    computeMinIndentation(offset, textModel) {\n        const start = lengthToObj(offset);\n        // Text ast nodes don't have partial indentation (ensured by the tokenizer).\n        // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n        const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n        const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n        let result = Number.MAX_SAFE_INTEGER;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n            const lineContent = textModel.getLineContent(lineNumber);\n            if (firstNonWsColumn === 0) {\n                continue;\n            }\n            const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);\n            result = Math.min(result, visibleColumn);\n        }\n        return result;\n    }\n}\nexport class BracketAstNode extends ImmutableLeafAstNode {\n    static create(length, bracketInfo, bracketIds) {\n        const node = new BracketAstNode(length, bracketInfo, bracketIds);\n        return node;\n    }\n    get kind() {\n        return 1 /* AstNodeKind.Bracket */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    constructor(length, bracketInfo, \n    /**\n     * In case of a opening bracket, this is the id of the opening bracket.\n     * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n    */\n    bracketIds) {\n        super(length);\n        this.bracketInfo = bracketInfo;\n        this.bracketIds = bracketIds;\n    }\n    get text() {\n        return this.bracketInfo.bracketText;\n    }\n    get languageId() {\n        return this.bracketInfo.languageId;\n    }\n    canBeReused(_openedBracketIds) {\n        // These nodes could be reused,\n        // but not in a general way.\n        // Their parent may be reused.\n        return false;\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 3 /* AstNodeKind.UnexpectedClosingBracket */;\n    }\n    constructor(closingBrackets, length) {\n        super(length);\n        this.missingOpeningBracketIds = closingBrackets;\n    }\n    canBeReused(openedBracketIds) {\n        return !openedBracketIds.intersects(this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../core/range.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthOfString, lengthToObj, positionToLength, toLength } from './length.js';\nexport class TextEditInfo {\n    static fromModelContentChanges(changes) {\n        // Must be sorted in ascending order\n        const edits = changes.map(c => {\n            const range = Range.lift(c.range);\n            return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n        }).reverse();\n        return edits;\n    }\n    constructor(startOffset, endOffset, newLength) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.newLength = newLength;\n    }\n    toString() {\n        return `[${lengthToObj(this.startOffset)}...${lengthToObj(this.endOffset)}) -> ${lengthToObj(this.newLength)}`;\n    }\n}\nexport class BeforeEditPositionMapper {\n    /**\n     * @param edits Must be sorted by offset in ascending order.\n    */\n    constructor(edits) {\n        this.nextEditIdx = 0;\n        this.deltaOldToNewLineCount = 0;\n        this.deltaOldToNewColumnCount = 0;\n        this.deltaLineIdxInOld = -1;\n        this.edits = edits.map(edit => TextEditInfoCache.from(edit));\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getOffsetBeforeChange(offset) {\n        this.adjustNextEdit(offset);\n        return this.translateCurToOld(offset);\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n     * Returns null if there is no edit anymore.\n    */\n    getDistanceToNextChange(offset) {\n        this.adjustNextEdit(offset);\n        const nextEdit = this.edits[this.nextEditIdx];\n        const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : null;\n        if (nextChangeOffset === null) {\n            return null;\n        }\n        return lengthDiffNonNegative(offset, nextChangeOffset);\n    }\n    translateOldToCur(oldOffsetObj) {\n        if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n        }\n    }\n    translateCurToOld(newOffset) {\n        const offsetObj = lengthToObj(newOffset);\n        if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n        }\n    }\n    adjustNextEdit(offset) {\n        while (this.nextEditIdx < this.edits.length) {\n            const nextEdit = this.edits[this.nextEditIdx];\n            // After applying the edit, what is its end offset (considering all previous edits)?\n            const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n            if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n                // We are after the edit, skip it\n                this.nextEditIdx++;\n                const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n                // Before applying the edit, what is its end offset (considering all previous edits)?\n                const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n                const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n                this.deltaOldToNewLineCount += lineDelta;\n                const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n                const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n                this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n                this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n            }\n            else {\n                // We are in or before the edit.\n                break;\n            }\n        }\n    }\n}\nclass TextEditInfoCache {\n    static from(edit) {\n        return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n    }\n    constructor(startOffset, endOffset, textLength) {\n        this.endOffsetBeforeObj = lengthToObj(endOffset);\n        this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n        this.offsetObj = lengthToObj(startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { Token } from './tokenizer.js';\nexport class BracketTokens {\n    static createFromLanguage(configuration, denseKeyProvider) {\n        function getId(bracketInfo) {\n            return denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);\n        }\n        const map = new Map();\n        for (const openingBracket of configuration.bracketsNew.openingBrackets) {\n            const length = toLength(0, openingBracket.bracketText.length);\n            const openingTextId = getId(openingBracket);\n            const bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n            map.set(openingBracket.bracketText, new Token(length, 1 /* TokenKind.OpeningBracket */, openingTextId, bracketIds, BracketAstNode.create(length, openingBracket, bracketIds)));\n        }\n        for (const closingBracket of configuration.bracketsNew.closingBrackets) {\n            const length = toLength(0, closingBracket.bracketText.length);\n            let bracketIds = SmallImmutableSet.getEmpty();\n            const closingBrackets = closingBracket.getOpeningBrackets();\n            for (const bracket of closingBrackets) {\n                bracketIds = bracketIds.add(getId(bracket), identityKeyProvider);\n            }\n            map.set(closingBracket.bracketText, new Token(length, 2 /* TokenKind.ClosingBracket */, getId(closingBrackets[0]), bracketIds, BracketAstNode.create(length, closingBracket, bracketIds)));\n        }\n        return new BracketTokens(map);\n    }\n    constructor(map) {\n        this.map = map;\n        this.hasRegExp = false;\n        this._regExpGlobal = null;\n    }\n    getRegExpStr() {\n        if (this.isEmpty) {\n            return null;\n        }\n        else {\n            const keys = [...this.map.keys()];\n            keys.sort();\n            keys.reverse();\n            return keys.map(k => prepareBracketForRegExp(k)).join('|');\n        }\n    }\n    /**\n     * Returns null if there is no such regexp (because there are no brackets).\n    */\n    get regExpGlobal() {\n        if (!this.hasRegExp) {\n            const regExpStr = this.getRegExpStr();\n            this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;\n            this.hasRegExp = true;\n        }\n        return this._regExpGlobal;\n    }\n    getToken(value) {\n        return this.map.get(value.toLowerCase());\n    }\n    findClosingTokenText(openingBracketIds) {\n        for (const [closingText, info] of this.map) {\n            if (info.kind === 2 /* TokenKind.ClosingBracket */ && info.bracketIds.intersects(openingBracketIds)) {\n                return closingText;\n            }\n        }\n        return undefined;\n    }\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\nfunction prepareBracketForRegExp(str) {\n    let escaped = escapeRegExpCharacters(str);\n    // These bracket pair delimiters start or end with letters\n    // see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440\n    if (/^[\\w ]+/.test(str)) {\n        escaped = `\\\\b${escaped}`;\n    }\n    if (/[\\w ]+$/.test(str)) {\n        escaped = `${escaped}\\\\b`;\n    }\n    return escaped;\n}\nexport class LanguageAgnosticBracketTokens {\n    constructor(denseKeyProvider, getLanguageConfiguration) {\n        this.denseKeyProvider = denseKeyProvider;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.languageIdToBracketTokens = new Map();\n    }\n    didLanguageChange(languageId) {\n        // Report a change whenever the language configuration updates.\n        return this.languageIdToBracketTokens.has(languageId);\n    }\n    getSingleLanguageBracketTokens(languageId) {\n        let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n        if (!singleLanguageBracketTokens) {\n            singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n            this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n        }\n        return singleLanguageBracketTokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../../../base/common/arrays.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthEquals, lengthIsZero, lengthToObj, lengthZero, sumLengths } from './length.js';\nexport function combineTextEditInfos(textEditInfoFirst, textEditInfoSecond) {\n    if (textEditInfoFirst.length === 0) {\n        return textEditInfoSecond;\n    }\n    if (textEditInfoSecond.length === 0) {\n        return textEditInfoFirst;\n    }\n    // s0: State before any edits\n    const s0ToS1Map = new ArrayQueue(toLengthMapping(textEditInfoFirst));\n    // s1: State after first edit, but before second edit\n    const s1ToS2Map = toLengthMapping(textEditInfoSecond);\n    s1ToS2Map.push({ modified: false, lengthBefore: undefined, lengthAfter: undefined }); // Copy everything from old to new\n    // s2: State after both edits\n    let curItem = s0ToS1Map.dequeue();\n    /**\n     * @param s1Length Use undefined for length \"infinity\"\n     */\n    function nextS0ToS1MapWithS1LengthOf(s1Length) {\n        if (s1Length === undefined) {\n            const arr = s0ToS1Map.takeWhile(v => true) || [];\n            if (curItem) {\n                arr.unshift(curItem);\n            }\n            return arr;\n        }\n        const result = [];\n        while (curItem && !lengthIsZero(s1Length)) {\n            const [item, remainingItem] = curItem.splitAt(s1Length);\n            result.push(item);\n            s1Length = lengthDiffNonNegative(item.lengthAfter, s1Length);\n            curItem = remainingItem ?? s0ToS1Map.dequeue();\n        }\n        if (!lengthIsZero(s1Length)) {\n            result.push(new LengthMapping(false, s1Length, s1Length));\n        }\n        return result;\n    }\n    const result = [];\n    function pushEdit(startOffset, endOffset, newLength) {\n        if (result.length > 0 && lengthEquals(result[result.length - 1].endOffset, startOffset)) {\n            const lastResult = result[result.length - 1];\n            result[result.length - 1] = new TextEditInfo(lastResult.startOffset, endOffset, lengthAdd(lastResult.newLength, newLength));\n        }\n        else {\n            result.push({ startOffset, endOffset, newLength });\n        }\n    }\n    let s0offset = lengthZero;\n    for (const s1ToS2 of s1ToS2Map) {\n        const s0ToS1Map = nextS0ToS1MapWithS1LengthOf(s1ToS2.lengthBefore);\n        if (s1ToS2.modified) {\n            const s0Length = sumLengths(s0ToS1Map, s => s.lengthBefore);\n            const s0EndOffset = lengthAdd(s0offset, s0Length);\n            pushEdit(s0offset, s0EndOffset, s1ToS2.lengthAfter);\n            s0offset = s0EndOffset;\n        }\n        else {\n            for (const s1 of s0ToS1Map) {\n                const s0startOffset = s0offset;\n                s0offset = lengthAdd(s0offset, s1.lengthBefore);\n                if (s1.modified) {\n                    pushEdit(s0startOffset, s0offset, s1.lengthAfter);\n                }\n            }\n        }\n    }\n    return result;\n}\nclass LengthMapping {\n    constructor(\n    /**\n     * If false, length before and length after equal.\n     */\n    modified, lengthBefore, lengthAfter) {\n        this.modified = modified;\n        this.lengthBefore = lengthBefore;\n        this.lengthAfter = lengthAfter;\n    }\n    splitAt(lengthAfter) {\n        const remainingLengthAfter = lengthDiffNonNegative(lengthAfter, this.lengthAfter);\n        if (lengthEquals(remainingLengthAfter, lengthZero)) {\n            return [this, undefined];\n        }\n        else if (this.modified) {\n            return [\n                new LengthMapping(this.modified, this.lengthBefore, lengthAfter),\n                new LengthMapping(this.modified, lengthZero, remainingLengthAfter)\n            ];\n        }\n        else {\n            return [\n                new LengthMapping(this.modified, lengthAfter, lengthAfter),\n                new LengthMapping(this.modified, remainingLengthAfter, remainingLengthAfter)\n            ];\n        }\n    }\n    toString() {\n        return `${this.modified ? 'M' : 'U'}:${lengthToObj(this.lengthBefore)} -> ${lengthToObj(this.lengthAfter)}`;\n    }\n}\nfunction toLengthMapping(textEditInfos) {\n    const result = [];\n    let lastOffset = lengthZero;\n    for (const textEditInfo of textEditInfos) {\n        const spaceLength = lengthDiffNonNegative(lastOffset, textEditInfo.startOffset);\n        if (!lengthIsZero(spaceLength)) {\n            result.push(new LengthMapping(false, spaceLength, spaceLength));\n        }\n        const lengthBefore = lengthDiffNonNegative(textEditInfo.startOffset, textEditInfo.endOffset);\n        result.push(new LengthMapping(true, lengthBefore, textEditInfo.newLength));\n        lastOffset = textEditInfo.endOffset;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { Range } from '../../../core/range.js';\nimport { TextLength } from '../../../core/textLength.js';\n/**\n * The end must be greater than or equal to the start.\n*/\nexport function lengthDiff(startLineCount, startColumnCount, endLineCount, endColumnCount) {\n    return (startLineCount !== endLineCount)\n        ? toLength(endLineCount - startLineCount, endColumnCount)\n        : toLength(0, endColumnCount - startColumnCount);\n}\nexport const lengthZero = 0;\nexport function lengthIsZero(length) {\n    return length === 0;\n}\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n */\n///*\nconst factor = 2 ** 26;\n/*/\nconst factor = 1000000;\n// */\nexport function toLength(lineCount, columnCount) {\n    // llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n    //       line count (26 bits)    column count (26 bits)\n    // If there is no overflow (all values/sums below 2^26 = 67108864),\n    // we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n    return (lineCount * factor + columnCount);\n}\nexport function lengthToObj(length) {\n    const l = length;\n    const lineCount = Math.floor(l / factor);\n    const columnCount = l - lineCount * factor;\n    return new TextLength(lineCount, columnCount);\n}\nexport function lengthGetLineCount(length) {\n    return Math.floor(length / factor);\n}\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n*/\nexport function lengthGetColumnCountIfZeroLineCount(length) {\n    return length;\n}\nexport function lengthAdd(l1, l2) {\n    let r = l1 + l2;\n    if (l2 >= factor) {\n        r = r - (l1 % factor);\n    }\n    return r;\n}\nexport function sumLengths(items, lengthFn) {\n    return items.reduce((a, b) => lengthAdd(a, lengthFn(b)), lengthZero);\n}\nexport function lengthEquals(length1, length2) {\n    return length1 === length2;\n}\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\nexport function lengthDiffNonNegative(length1, length2) {\n    const l1 = length1;\n    const l2 = length2;\n    const diff = l2 - l1;\n    if (diff <= 0) {\n        // line-count of length1 is higher than line-count of length2\n        // or they are equal and column-count of length1 is higher than column-count of length2\n        return lengthZero;\n    }\n    const lineCount1 = Math.floor(l1 / factor);\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    if (lineCount1 === lineCount2) {\n        const colCount1 = l1 - lineCount1 * factor;\n        return toLength(0, colCount2 - colCount1);\n    }\n    else {\n        return toLength(lineCount2 - lineCount1, colCount2);\n    }\n}\nexport function lengthLessThan(length1, length2) {\n    // First, compare line counts, then column counts.\n    return length1 < length2;\n}\nexport function lengthLessThanEqual(length1, length2) {\n    return length1 <= length2;\n}\nexport function lengthGreaterThanEqual(length1, length2) {\n    return length1 >= length2;\n}\nexport function positionToLength(position) {\n    return toLength(position.lineNumber - 1, position.column - 1);\n}\nexport function lengthsToRange(lengthStart, lengthEnd) {\n    const l = lengthStart;\n    const lineCount = Math.floor(l / factor);\n    const colCount = l - lineCount * factor;\n    const l2 = lengthEnd;\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    return new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);\n}\nexport function lengthOfString(str) {\n    const lines = splitLines(str);\n    return toLength(lines.length - 1, lines[lines.length - 1].length);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ListAstNode } from './ast.js';\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\nexport function concat23Trees(items) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let i = 0;\n    /**\n     * Reads nodes of same height and concatenates them to a single node.\n    */\n    function readNode() {\n        if (i >= items.length) {\n            return null;\n        }\n        const start = i;\n        const height = items[start].listHeight;\n        i++;\n        while (i < items.length && items[i].listHeight === height) {\n            i++;\n        }\n        if (i - start >= 2) {\n            return concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n        }\n        else {\n            return items[start];\n        }\n    }\n    // The items might not have the same height.\n    // We merge all items by using a binary concat operator.\n    let first = readNode(); // There must be a first item\n    let second = readNode();\n    if (!second) {\n        return first;\n    }\n    for (let item = readNode(); item; item = readNode()) {\n        // Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n        if (heightDiff(first, second) <= heightDiff(second, item)) {\n            first = concat(first, second);\n            second = item;\n        }\n        else {\n            second = concat(second, item);\n        }\n    }\n    const result = concat(first, second);\n    return result;\n}\nexport function concat23TreesOfSameHeight(items, createImmutableLists = false) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let length = items.length;\n    // All trees have same height, just create parent nodes.\n    while (length > 3) {\n        const newLength = length >> 1;\n        for (let i = 0; i < newLength; i++) {\n            const j = i << 1;\n            items[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n        }\n        length = newLength;\n    }\n    return ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\nfunction heightDiff(node1, node2) {\n    return Math.abs(node1.listHeight - node2.listHeight);\n}\nfunction concat(node1, node2) {\n    if (node1.listHeight === node2.listHeight) {\n        return ListAstNode.create23(node1, node2, null, false);\n    }\n    else if (node1.listHeight > node2.listHeight) {\n        // node1 is the tree we want to insert into\n        return append(node1, node2);\n    }\n    else {\n        return prepend(node2, node1);\n    }\n}\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction append(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    let nodeToAppendOfCorrectHeight;\n    while (true) {\n        // assert nodeToInsert.listHeight <= curNode.listHeight\n        if (nodeToAppend.listHeight === curNode.listHeight) {\n            nodeToAppendOfCorrectHeight = nodeToAppend;\n            break;\n        }\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenLength <= 3\n        curNode = curNode.makeLastElementMutable();\n    }\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToAppendOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild(), nodeToAppendOfCorrectHeight, null, false);\n            }\n            else {\n                parent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n                nodeToAppendOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToAppendOfCorrectHeight) {\n        return ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n    }\n    else {\n        return list;\n    }\n}\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction prepend(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    // assert nodeToInsert.listHeight <= curNode.listHeight\n    while (nodeToAppend.listHeight !== curNode.listHeight) {\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenFast.length <= 3\n        curNode = curNode.makeFirstElementMutable();\n    }\n    let nodeToPrependOfCorrectHeight = nodeToAppend;\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToPrependOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild(), null, false);\n            }\n            else {\n                parent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n                nodeToPrependOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToPrependOfCorrectHeight) {\n        return ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n    }\n    else {\n        return list;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthZero, lengthLessThan } from './length.js';\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n    constructor(node) {\n        this.lastOffset = lengthZero;\n        this.nextNodes = [node];\n        this.offsets = [lengthZero];\n        this.idxs = [];\n    }\n    /**\n     * Returns the longest node at `offset` that satisfies the predicate.\n     * @param offset must be greater than or equal to the last offset this method has been called with!\n    */\n    readLongestNodeAt(offset, predicate) {\n        if (lengthLessThan(offset, this.lastOffset)) {\n            throw new Error('Invalid offset');\n        }\n        this.lastOffset = offset;\n        // Find the longest node of all those that are closest to the current offset.\n        while (true) {\n            const curNode = lastOrUndefined(this.nextNodes);\n            if (!curNode) {\n                return undefined;\n            }\n            const curNodeOffset = lastOrUndefined(this.offsets);\n            if (lengthLessThan(offset, curNodeOffset)) {\n                // The next best node is not here yet.\n                // The reader must advance before a cached node is hit.\n                return undefined;\n            }\n            if (lengthLessThan(curNodeOffset, offset)) {\n                // The reader is ahead of the current node.\n                if (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n                    // The reader is after the end of the current node.\n                    this.nextNodeAfterCurrent();\n                }\n                else {\n                    // The reader is somewhere in the current node.\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    if (nextChildIdx !== -1) {\n                        // Go to the first child and repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                    else {\n                        // We don't have children\n                        this.nextNodeAfterCurrent();\n                    }\n                }\n            }\n            else {\n                // readerOffsetBeforeChange === curNodeOffset\n                if (predicate(curNode)) {\n                    this.nextNodeAfterCurrent();\n                    return curNode;\n                }\n                else {\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    // look for shorter node\n                    if (nextChildIdx === -1) {\n                        // There is no shorter node.\n                        this.nextNodeAfterCurrent();\n                        return undefined;\n                    }\n                    else {\n                        // Descend into first child & repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                }\n            }\n        }\n    }\n    // Navigates to the longest node that continues after the current node.\n    nextNodeAfterCurrent() {\n        while (true) {\n            const currentOffset = lastOrUndefined(this.offsets);\n            const currentNode = lastOrUndefined(this.nextNodes);\n            this.nextNodes.pop();\n            this.offsets.pop();\n            if (this.idxs.length === 0) {\n                // We just popped the root node, there is no next node.\n                break;\n            }\n            // Parent is not undefined, because idxs is not empty\n            const parent = lastOrUndefined(this.nextNodes);\n            const nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n            if (nextChildIdx !== -1) {\n                this.nextNodes.push(parent.getChild(nextChildIdx));\n                this.offsets.push(lengthAdd(currentOffset, currentNode.length));\n                this.idxs[this.idxs.length - 1] = nextChildIdx;\n                break;\n            }\n            else {\n                this.idxs.pop();\n            }\n            // We fully consumed the parent.\n            // Current node is now parent, so call nextNodeAfterCurrent again\n        }\n    }\n}\nfunction getNextChildIdx(node, curIdx = -1) {\n    while (true) {\n        curIdx++;\n        if (curIdx >= node.childrenLength) {\n            return -1;\n        }\n        if (node.getChild(curIdx)) {\n            return curIdx;\n        }\n    }\n}\nfunction lastOrUndefined(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { InvalidBracketAstNode, ListAstNode, PairAstNode, TextAstNode } from './ast.js';\nimport { BeforeEditPositionMapper } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {\n    const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n    return parser.parseDocument();\n}\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n    constructor(tokenizer, edits, oldNode, createImmutableLists) {\n        this.tokenizer = tokenizer;\n        this.createImmutableLists = createImmutableLists;\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        if (oldNode && createImmutableLists) {\n            throw new Error('Not supported');\n        }\n        this.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n        this.positionMapper = new BeforeEditPositionMapper(edits);\n    }\n    parseDocument() {\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        let result = this.parseList(SmallImmutableSet.getEmpty(), 0);\n        if (!result) {\n            result = ListAstNode.getEmpty();\n        }\n        return result;\n    }\n    parseList(openedBracketIds, level) {\n        const items = [];\n        while (true) {\n            let child = this.tryReadChildFromCache(openedBracketIds);\n            if (!child) {\n                const token = this.tokenizer.peek();\n                if (!token ||\n                    (token.kind === 2 /* TokenKind.ClosingBracket */ &&\n                        token.bracketIds.intersects(openedBracketIds))) {\n                    break;\n                }\n                child = this.parseChild(openedBracketIds, level + 1);\n            }\n            if (child.kind === 4 /* AstNodeKind.List */ && child.childrenLength === 0) {\n                continue;\n            }\n            items.push(child);\n        }\n        // When there is no oldNodeReader, all items are created from scratch and must have the same height.\n        const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n        return result;\n    }\n    tryReadChildFromCache(openedBracketIds) {\n        if (this.oldNodeReader) {\n            const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n            if (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {\n                const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n                    // The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.\n                    // If there is no edit anymore, we can re-use the node in any case.\n                    if (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {\n                        // Either the node contains edited text or touches edited text.\n                        // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n                        return false;\n                    }\n                    const canBeReused = curNode.canBeReused(openedBracketIds);\n                    return canBeReused;\n                });\n                if (cachedNode) {\n                    this._itemsFromCache++;\n                    this.tokenizer.skip(cachedNode.length);\n                    return cachedNode;\n                }\n            }\n        }\n        return undefined;\n    }\n    parseChild(openedBracketIds, level) {\n        this._itemsConstructed++;\n        const token = this.tokenizer.read();\n        switch (token.kind) {\n            case 2 /* TokenKind.ClosingBracket */:\n                return new InvalidBracketAstNode(token.bracketIds, token.length);\n            case 0 /* TokenKind.Text */:\n                return token.astNode;\n            case 1 /* TokenKind.OpeningBracket */: {\n                if (level > 300) {\n                    // To prevent stack overflows\n                    return new TextAstNode(token.length);\n                }\n                const set = openedBracketIds.merge(token.bracketIds);\n                const child = this.parseList(set, level + 1);\n                const nextToken = this.tokenizer.peek();\n                if (nextToken &&\n                    nextToken.kind === 2 /* TokenKind.ClosingBracket */ &&\n                    (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {\n                    this.tokenizer.read();\n                    return PairAstNode.create(token.astNode, child, nextToken.astNode);\n                }\n                else {\n                    return PairAstNode.create(token.astNode, child, null);\n                }\n            }\n            default:\n                throw new Error('unexpected');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst emptyArr = [];\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nexport class SmallImmutableSet {\n    static { this.cache = new Array(129); }\n    static create(items, additionalItems) {\n        if (items <= 128 && additionalItems.length === 0) {\n            // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n            let cached = SmallImmutableSet.cache[items];\n            if (!cached) {\n                cached = new SmallImmutableSet(items, additionalItems);\n                SmallImmutableSet.cache[items] = cached;\n            }\n            return cached;\n        }\n        return new SmallImmutableSet(items, additionalItems);\n    }\n    static { this.empty = SmallImmutableSet.create(0, emptyArr); }\n    static getEmpty() {\n        return this.empty;\n    }\n    constructor(items, additionalItems) {\n        this.items = items;\n        this.additionalItems = additionalItems;\n    }\n    add(value, keyProvider) {\n        const key = keyProvider.getKey(value);\n        let idx = key >> 5; // divided by 32\n        if (idx === 0) {\n            // fast path\n            const newItem = (1 << key) | this.items;\n            if (newItem === this.items) {\n                return this;\n            }\n            return SmallImmutableSet.create(newItem, this.additionalItems);\n        }\n        idx--;\n        const newItems = this.additionalItems.slice(0);\n        while (newItems.length < idx) {\n            newItems.push(0);\n        }\n        newItems[idx] |= 1 << (key & 31);\n        return SmallImmutableSet.create(this.items, newItems);\n    }\n    merge(other) {\n        const merged = this.items | other.items;\n        if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n            // fast path\n            if (merged === this.items) {\n                return this;\n            }\n            if (merged === other.items) {\n                return other;\n            }\n            return SmallImmutableSet.create(merged, emptyArr);\n        }\n        // This can be optimized, but it's not a common case\n        const newItems = [];\n        for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n            const item1 = this.additionalItems[i] || 0;\n            const item2 = other.additionalItems[i] || 0;\n            newItems.push(item1 | item2);\n        }\n        return SmallImmutableSet.create(merged, newItems);\n    }\n    intersects(other) {\n        if ((this.items & other.items) !== 0) {\n            return true;\n        }\n        for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n            if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexport const identityKeyProvider = {\n    getKey(value) {\n        return value;\n    }\n};\n/**\n * Assigns values a unique incrementing key.\n*/\nexport class DenseKeyProvider {\n    constructor() {\n        this.items = new Map();\n    }\n    getKey(value) {\n        let existing = this.items.get(value);\n        if (existing === undefined) {\n            existing = this.items.size;\n            this.items.set(value, existing);\n        }\n        return existing;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nexport class Token {\n    constructor(length, kind, \n    /**\n     * If this token is an opening bracket, this is the id of the opening bracket.\n     * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n     * Otherwise, it is -1.\n     */\n    bracketId, \n    /**\n     * If this token is an opening bracket, this just contains `bracketId`.\n     * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n     * Otherwise, it is empty.\n     */\n    bracketIds, astNode) {\n        this.length = length;\n        this.kind = kind;\n        this.bracketId = bracketId;\n        this.bracketIds = bracketIds;\n        this.astNode = astNode;\n    }\n}\nexport class TextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n        this._offset = lengthZero;\n        this.didPeek = false;\n        this.peeked = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n    }\n    skip(length) {\n        this.didPeek = false;\n        this._offset = lengthAdd(this._offset, length);\n        const obj = lengthToObj(this._offset);\n        this.reader.setPosition(obj.lineCount, obj.columnCount);\n    }\n    read() {\n        let token;\n        if (this.peeked) {\n            this.didPeek = false;\n            token = this.peeked;\n        }\n        else {\n            token = this.reader.read();\n        }\n        if (token) {\n            this._offset = lengthAdd(this._offset, token.length);\n        }\n        return token;\n    }\n    peek() {\n        if (!this.didPeek) {\n            this.peeked = this.reader.read();\n            this.didPeek = true;\n        }\n        return this.peeked;\n    }\n}\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.lineIdx = 0;\n        this.line = null;\n        this.lineCharOffset = 0;\n        this.lineTokens = null;\n        this.lineTokenOffset = 0;\n        /** Must be a zero line token. The end of the document cannot be peeked. */\n        this.peekedToken = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    setPosition(lineIdx, column) {\n        // We must not jump into a token!\n        if (lineIdx === this.lineIdx) {\n            this.lineCharOffset = column;\n            if (this.line !== null) {\n                this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n            }\n        }\n        else {\n            this.lineIdx = lineIdx;\n            this.lineCharOffset = column;\n            this.line = null;\n        }\n        this.peekedToken = null;\n    }\n    read() {\n        if (this.peekedToken) {\n            const token = this.peekedToken;\n            this.peekedToken = null;\n            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n            return token;\n        }\n        if (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n            // We are after the end\n            return null;\n        }\n        if (this.line === null) {\n            this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n            this.line = this.lineTokens.getLineContent();\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        const startLineIdx = this.lineIdx;\n        const startLineCharOffset = this.lineCharOffset;\n        // limits the length of text tokens.\n        // If text tokens get too long, incremental updates will be slow\n        let lengthHeuristic = 0;\n        while (true) {\n            const lineTokens = this.lineTokens;\n            const tokenCount = lineTokens.getCount();\n            let peekedBracketToken = null;\n            if (this.lineTokenOffset < tokenCount) {\n                const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n                while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n                    // Skip tokens that are identical.\n                    // Sometimes, (bracket) identifiers are split up into multiple tokens.\n                    this.lineTokenOffset++;\n                }\n                const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0 /* StandardTokenType.Other */;\n                const containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n                const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n                // Is there a bracket token next? Only consume text.\n                if (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n                    const languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n                    const text = this.line.substring(this.lineCharOffset, endOffset);\n                    const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n                    const regexp = brackets.regExpGlobal;\n                    if (regexp) {\n                        regexp.lastIndex = 0;\n                        const match = regexp.exec(text);\n                        if (match) {\n                            peekedBracketToken = brackets.getToken(match[0]);\n                            if (peekedBracketToken) {\n                                // Consume leading text of the token\n                                this.lineCharOffset += match.index;\n                            }\n                        }\n                    }\n                }\n                lengthHeuristic += endOffset - this.lineCharOffset;\n                if (peekedBracketToken) {\n                    // Don't skip the entire token, as a single token could contain multiple brackets.\n                    if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n                        // There is text before the bracket\n                        this.peekedToken = peekedBracketToken;\n                        break;\n                    }\n                    else {\n                        // Consume the peeked token\n                        this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n                        return peekedBracketToken;\n                    }\n                }\n                else {\n                    // Skip the entire token, as the token contains no brackets at all.\n                    this.lineTokenOffset++;\n                    this.lineCharOffset = endOffset;\n                }\n            }\n            else {\n                if (this.lineIdx === this.textBufferLineCount - 1) {\n                    break;\n                }\n                this.lineIdx++;\n                this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n                this.lineTokenOffset = 0;\n                this.line = this.lineTokens.getLineContent();\n                this.lineCharOffset = 0;\n                lengthHeuristic += 33; // max 1000/33 = 30 lines\n                // This limits the amount of work to recompute min-indentation\n                if (lengthHeuristic > 1000) {\n                    // only break (automatically) at the end of line.\n                    break;\n                }\n            }\n            if (lengthHeuristic > 1500) {\n                // Eventually break regardless of the line length so that\n                // very long lines do not cause bad performance.\n                // This effective limits max indentation to 500, as\n                // indentation is not computed across multiple text nodes.\n                break;\n            }\n        }\n        // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n        // unless the line is too long.\n        // Thus, the min indentation of the document is the minimum min indentation of every text node.\n        const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n        return new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n    }\n}\nexport class FastTokenizer {\n    constructor(text, brackets) {\n        this.text = text;\n        this._offset = lengthZero;\n        this.idx = 0;\n        const regExpStr = brackets.getRegExpStr();\n        const regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n        const tokens = [];\n        let match;\n        let curLineCount = 0;\n        let lastLineBreakOffset = 0;\n        let lastTokenEndOffset = 0;\n        let lastTokenEndLine = 0;\n        const smallTextTokens0Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens0Line.push(new Token(toLength(0, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n        }\n        const smallTextTokens1Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens1Line.push(new Token(toLength(1, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));\n        }\n        if (regexp) {\n            regexp.lastIndex = 0;\n            // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n            while ((match = regexp.exec(text)) !== null) {\n                const curOffset = match.index;\n                const value = match[0];\n                if (value === '\\n') {\n                    curLineCount++;\n                    lastLineBreakOffset = curOffset + 1;\n                }\n                else {\n                    if (lastTokenEndOffset !== curOffset) {\n                        let token;\n                        if (lastTokenEndLine === curLineCount) {\n                            const colCount = curOffset - lastTokenEndOffset;\n                            if (colCount < smallTextTokens0Line.length) {\n                                token = smallTextTokens0Line[colCount];\n                            }\n                            else {\n                                const length = toLength(0, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        else {\n                            const lineCount = curLineCount - lastTokenEndLine;\n                            const colCount = curOffset - lastLineBreakOffset;\n                            if (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n                                token = smallTextTokens1Line[colCount];\n                            }\n                            else {\n                                const length = toLength(lineCount, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        tokens.push(token);\n                    }\n                    // value is matched by regexp, so the token must exist\n                    tokens.push(brackets.getToken(value));\n                    lastTokenEndOffset = curOffset + value.length;\n                    lastTokenEndLine = curLineCount;\n                }\n            }\n        }\n        const offset = text.length;\n        if (lastTokenEndOffset !== offset) {\n            const length = (lastTokenEndLine === curLineCount)\n                ? toLength(0, offset - lastTokenEndOffset)\n                : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n            tokens.push(new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n        }\n        this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n        this.tokens = tokens;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read() {\n        return this.tokens[this.idx++] || null;\n    }\n    peek() {\n        return this.tokens[this.idx] || null;\n    }\n    skip(length) {\n        throw new NotSupportedError();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Selection } from '../core/selection.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { TextChange, compressConsecutiveTextChanges } from '../core/textChange.js';\nimport * as buffer from '../../../base/common/buffer.js';\nimport { basename } from '../../../base/common/resources.js';\nfunction uriGetComparisonKey(resource) {\n    return resource.toString();\n}\nexport class SingleModelEditStackData {\n    static create(model, beforeCursorState) {\n        const alternativeVersionId = model.getAlternativeVersionId();\n        const eol = getModelEOL(model);\n        return new SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);\n    }\n    constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {\n        this.beforeVersionId = beforeVersionId;\n        this.afterVersionId = afterVersionId;\n        this.beforeEOL = beforeEOL;\n        this.afterEOL = afterEOL;\n        this.beforeCursorState = beforeCursorState;\n        this.afterCursorState = afterCursorState;\n        this.changes = changes;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (textChanges.length > 0) {\n            this.changes = compressConsecutiveTextChanges(this.changes, textChanges);\n        }\n        this.afterEOL = afterEOL;\n        this.afterVersionId = afterVersionId;\n        this.afterCursorState = afterCursorState;\n    }\n    static _writeSelectionsSize(selections) {\n        return 4 + 4 * 4 * (selections ? selections.length : 0);\n    }\n    static _writeSelections(b, selections, offset) {\n        buffer.writeUInt32BE(b, (selections ? selections.length : 0), offset);\n        offset += 4;\n        if (selections) {\n            for (const selection of selections) {\n                buffer.writeUInt32BE(b, selection.selectionStartLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.selectionStartColumn, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionColumn, offset);\n                offset += 4;\n            }\n        }\n        return offset;\n    }\n    static _readSelections(b, offset, dest) {\n        const count = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        for (let i = 0; i < count; i++) {\n            const selectionStartLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const selectionStartColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            dest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));\n        }\n        return offset;\n    }\n    serialize() {\n        let necessarySize = (+4 // beforeVersionId\n            + 4 // afterVersionId\n            + 1 // beforeEOL\n            + 1 // afterEOL\n            + SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState)\n            + SingleModelEditStackData._writeSelectionsSize(this.afterCursorState)\n            + 4 // change count\n        );\n        for (const change of this.changes) {\n            necessarySize += change.writeSize();\n        }\n        const b = new Uint8Array(necessarySize);\n        let offset = 0;\n        buffer.writeUInt32BE(b, this.beforeVersionId, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.afterVersionId, offset);\n        offset += 4;\n        buffer.writeUInt8(b, this.beforeEOL, offset);\n        offset += 1;\n        buffer.writeUInt8(b, this.afterEOL, offset);\n        offset += 1;\n        offset = SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);\n        offset = SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);\n        buffer.writeUInt32BE(b, this.changes.length, offset);\n        offset += 4;\n        for (const change of this.changes) {\n            offset = change.write(b, offset);\n        }\n        return b.buffer;\n    }\n    static deserialize(source) {\n        const b = new Uint8Array(source);\n        let offset = 0;\n        const beforeVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const afterVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const beforeEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const afterEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const beforeCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, beforeCursorState);\n        const afterCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, afterCursorState);\n        const changeCount = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const changes = [];\n        for (let i = 0; i < changeCount; i++) {\n            offset = TextChange.read(b, offset, changes);\n        }\n        return new SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);\n    }\n}\nexport class SingleModelEditStackElement {\n    get type() {\n        return 0 /* UndoRedoElementType.Resource */;\n    }\n    get resource() {\n        if (URI.isUri(this.model)) {\n            return this.model;\n        }\n        return this.model.uri;\n    }\n    constructor(label, code, model, beforeCursorState) {\n        this.label = label;\n        this.code = code;\n        this.model = model;\n        this._data = SingleModelEditStackData.create(model, beforeCursorState);\n    }\n    toString() {\n        const data = (this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data));\n        return data.changes.map(change => change.toString()).join(', ');\n    }\n    matchesResource(resource) {\n        const uri = (URI.isUri(this.model) ? this.model : this.model.uri);\n        return (uri.toString() === resource.toString());\n    }\n    setModel(model) {\n        this.model = model;\n    }\n    canAppend(model) {\n        return (this.model === model && this._data instanceof SingleModelEditStackData);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n        }\n    }\n    close() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n    }\n    open() {\n        if (!(this._data instanceof SingleModelEditStackData)) {\n            this._data = SingleModelEditStackData.deserialize(this._data);\n        }\n    }\n    undo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);\n    }\n    redo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);\n    }\n    heapSize() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        return this._data.byteLength + 168 /*heap overhead*/;\n    }\n}\nexport class MultiModelEditStackElement {\n    get resources() {\n        return this._editStackElementsArr.map(editStackElement => editStackElement.resource);\n    }\n    constructor(label, code, editStackElements) {\n        this.label = label;\n        this.code = code;\n        this.type = 1 /* UndoRedoElementType.Workspace */;\n        this._isOpen = true;\n        this._editStackElementsArr = editStackElements.slice(0);\n        this._editStackElementsMap = new Map();\n        for (const editStackElement of this._editStackElementsArr) {\n            const key = uriGetComparisonKey(editStackElement.resource);\n            this._editStackElementsMap.set(key, editStackElement);\n        }\n        this._delegate = null;\n    }\n    prepareUndoRedo() {\n        if (this._delegate) {\n            return this._delegate.prepareUndoRedo(this);\n        }\n    }\n    matchesResource(resource) {\n        const key = uriGetComparisonKey(resource);\n        return (this._editStackElementsMap.has(key));\n    }\n    setModel(model) {\n        const key = uriGetComparisonKey(URI.isUri(model) ? model : model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            this._editStackElementsMap.get(key).setModel(model);\n        }\n    }\n    canAppend(model) {\n        if (!this._isOpen) {\n            return false;\n        }\n        const key = uriGetComparisonKey(model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.canAppend(model);\n        }\n        return false;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        const key = uriGetComparisonKey(model.uri);\n        const editStackElement = this._editStackElementsMap.get(key);\n        editStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n    }\n    close() {\n        this._isOpen = false;\n    }\n    open() {\n        // cannot reopen\n    }\n    undo() {\n        this._isOpen = false;\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.undo();\n        }\n    }\n    redo() {\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.redo();\n        }\n    }\n    heapSize(resource) {\n        const key = uriGetComparisonKey(resource);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.heapSize();\n        }\n        return 0;\n    }\n    split() {\n        return this._editStackElementsArr;\n    }\n    toString() {\n        const result = [];\n        for (const editStackElement of this._editStackElementsArr) {\n            result.push(`${basename(editStackElement.resource)}: ${editStackElement}`);\n        }\n        return `{${result.join(', ')}}`;\n    }\n}\nfunction getModelEOL(model) {\n    const eol = model.getEOL();\n    if (eol === '\\n') {\n        return 0 /* EndOfLineSequence.LF */;\n    }\n    else {\n        return 1 /* EndOfLineSequence.CRLF */;\n    }\n}\nexport function isEditStackElement(element) {\n    if (!element) {\n        return false;\n    }\n    return ((element instanceof SingleModelEditStackElement) || (element instanceof MultiModelEditStackElement));\n}\nexport class EditStack {\n    constructor(model, undoRedoService) {\n        this._model = model;\n        this._undoRedoService = undoRedoService;\n    }\n    pushStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.close();\n        }\n    }\n    popStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.open();\n        }\n    }\n    clear() {\n        this._undoRedoService.removeElements(this._model.uri);\n    }\n    _getOrCreateEditStackElement(beforeCursorState, group) {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {\n            return lastElement;\n        }\n        const newElement = new SingleModelEditStackElement(nls.localize('edit', \"Typing\"), 'undoredo.textBufferEdit', this._model, beforeCursorState);\n        this._undoRedoService.pushElement(newElement, group);\n        return newElement;\n    }\n    pushEOL(eol) {\n        const editStackElement = this._getOrCreateEditStackElement(null, undefined);\n        this._model.setEOL(eol);\n        editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);\n    }\n    pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group) {\n        const editStackElement = this._getOrCreateEditStackElement(beforeCursorState, group);\n        const inverseEditOperations = this._model.applyEdits(editOperations, true);\n        const afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);\n        const textChanges = inverseEditOperations.map((op, index) => ({ index: index, textChange: op.textChange }));\n        textChanges.sort((a, b) => {\n            if (a.textChange.oldPosition === b.textChange.oldPosition) {\n                return a.index - b.index;\n            }\n            return a.textChange.oldPosition - b.textChange.oldPosition;\n        });\n        editStackElement.append(this._model, textChanges.map(op => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);\n        return afterCursorState;\n    }\n    static _computeCursorState(cursorStateComputer, inverseEditOperations) {\n        try {\n            return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLast } from '../../../base/common/arraysFind.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nexport class GuidesTextModelPart extends TextModelPart {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n    }\n    getLanguageConfiguration(languageId) {\n        return this.languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    _computeIndentLevel(lineIndex) {\n        return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (lineNumber < 1 || lineNumber > lineCount) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_aboveContentLineIndent = -1;\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_belowContentLineIndent = -1;\n        const up_resolveIndents = (lineNumber) => {\n            if (up_aboveContentLineIndex !== -1 &&\n                (up_aboveContentLineIndex === -2 ||\n                    up_aboveContentLineIndex > lineNumber - 1)) {\n                up_aboveContentLineIndex = -1;\n                up_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_aboveContentLineIndex = lineIndex;\n                        up_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (up_belowContentLineIndex === -2) {\n                up_belowContentLineIndex = -1;\n                up_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_belowContentLineIndex = lineIndex;\n                        up_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_aboveContentLineIndent = -1;\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_belowContentLineIndent = -1;\n        const down_resolveIndents = (lineNumber) => {\n            if (down_aboveContentLineIndex === -2) {\n                down_aboveContentLineIndex = -1;\n                down_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_aboveContentLineIndex = lineIndex;\n                        down_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (down_belowContentLineIndex !== -1 &&\n                (down_belowContentLineIndex === -2 ||\n                    down_belowContentLineIndex < lineNumber - 1)) {\n                down_belowContentLineIndex = -1;\n                down_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_belowContentLineIndex = lineIndex;\n                        down_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let startLineNumber = 0;\n        let goUp = true;\n        let endLineNumber = 0;\n        let goDown = true;\n        let indent = 0;\n        let initialIndent = 0;\n        for (let distance = 0; goUp || goDown; distance++) {\n            const upLineNumber = lineNumber - distance;\n            const downLineNumber = lineNumber + distance;\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                goUp = false;\n            }\n            if (distance > 1 &&\n                (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                goDown = false;\n            }\n            if (distance > 50000) {\n                // stop processing\n                goUp = false;\n                goDown = false;\n            }\n            let upLineIndentLevel = -1;\n            if (goUp && upLineNumber >= 1) {\n                // compute indent level going up\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    up_belowContentLineIndex = upLineNumber - 1;\n                    up_belowContentLineIndent = currentIndent;\n                    upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    up_resolveIndents(upLineNumber);\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                }\n            }\n            let downLineIndentLevel = -1;\n            if (goDown && downLineNumber <= lineCount) {\n                // compute indent level going down\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    down_aboveContentLineIndex = downLineNumber - 1;\n                    down_aboveContentLineIndent = currentIndent;\n                    downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    down_resolveIndents(downLineNumber);\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                }\n            }\n            if (distance === 0) {\n                initialIndent = upLineIndentLevel;\n                continue;\n            }\n            if (distance === 1) {\n                if (downLineNumber <= lineCount &&\n                    downLineIndentLevel >= 0 &&\n                    initialIndent + 1 === downLineIndentLevel) {\n                    // This is the beginning of a scope, we have special handling here, since we want the\n                    // child scope indent to be active, not the parent scope\n                    goUp = false;\n                    startLineNumber = downLineNumber;\n                    endLineNumber = downLineNumber;\n                    indent = downLineIndentLevel;\n                    continue;\n                }\n                if (upLineNumber >= 1 &&\n                    upLineIndentLevel >= 0 &&\n                    upLineIndentLevel - 1 === initialIndent) {\n                    // This is the end of a scope, just like above\n                    goDown = false;\n                    startLineNumber = upLineNumber;\n                    endLineNumber = upLineNumber;\n                    indent = upLineIndentLevel;\n                    continue;\n                }\n                startLineNumber = lineNumber;\n                endLineNumber = lineNumber;\n                indent = initialIndent;\n                if (indent === 0) {\n                    // No need to continue\n                    return { startLineNumber, endLineNumber, indent };\n                }\n            }\n            if (goUp) {\n                if (upLineIndentLevel >= indent) {\n                    startLineNumber = upLineNumber;\n                }\n                else {\n                    goUp = false;\n                }\n            }\n            if (goDown) {\n                if (downLineIndentLevel >= indent) {\n                    endLineNumber = downLineNumber;\n                }\n                else {\n                    goDown = false;\n                }\n            }\n        }\n        return { startLineNumber, endLineNumber, indent };\n    }\n    getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n        const result = [];\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            result.push([]);\n        }\n        // If requested, this could be made configurable.\n        const includeSingleLinePairs = true;\n        const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber))).toArray();\n        let activeBracketPairRange = undefined;\n        if (activePosition && bracketPairs.length > 0) {\n            const bracketsContainingActivePosition = (startLineNumber <= activePosition.lineNumber &&\n                activePosition.lineNumber <= endLineNumber\n                // We don't need to query the brackets again if the cursor is in the viewport\n                ? bracketPairs\n                : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition)).toArray()).filter((bp) => Range.strictContainsPosition(bp.range, activePosition));\n            activeBracketPairRange = findLast(bracketsContainingActivePosition, (i) => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber)?.range;\n        }\n        const independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;\n        const colorProvider = new BracketPairGuidesClassNames();\n        for (const pair of bracketPairs) {\n            /*\n\n\n                    {\n                    |\n                    }\n\n                    {\n                    |\n                    ----}\n\n                ____{\n                |test\n                ----}\n\n                renderHorizontalEndLineAtTheBottom:\n                    {\n                    |\n                    |x}\n                    --\n                renderHorizontalEndLineAtTheBottom:\n                ____{\n                |test\n                | x }\n                ----\n            */\n            if (!pair.closingBracketRange) {\n                continue;\n            }\n            const isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);\n            if (!isActive && !options.includeInactive) {\n                continue;\n            }\n            const className = colorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) +\n                (options.highlightActive && isActive\n                    ? ' ' + colorProvider.activeClassName\n                    : '');\n            const start = pair.openingBracketRange.getStartPosition();\n            const end = pair.closingBracketRange.getStartPosition();\n            const horizontalGuides = options.horizontalGuides === HorizontalGuidesState.Enabled || (options.horizontalGuides === HorizontalGuidesState.EnabledForActive && isActive);\n            if (pair.range.startLineNumber === pair.range.endLineNumber) {\n                if (includeSingleLinePairs && horizontalGuides) {\n                    result[pair.range.startLineNumber - startLineNumber].push(new IndentGuide(-1, pair.openingBracketRange.getEndPosition().column, className, new IndentGuideHorizontalLine(false, end.column), -1, -1));\n                }\n                continue;\n            }\n            const endVisibleColumn = this.getVisibleColumnFromPosition(end);\n            const startVisibleColumn = this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition());\n            const guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);\n            let renderHorizontalEndLineAtTheBottom = false;\n            const firstNonWsIndex = strings.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));\n            const hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;\n            if (hasTextBeforeClosingBracket) {\n                renderHorizontalEndLineAtTheBottom = true;\n            }\n            const visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);\n            const visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);\n            const offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;\n            for (let l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {\n                result[l - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, null, l === start.lineNumber ? start.column : -1, l === end.lineNumber ? end.column : -1));\n            }\n            if (horizontalGuides) {\n                if (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {\n                    result[start.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(false, start.column), -1, -1));\n                }\n                if (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {\n                    result[end.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column), -1, -1));\n                }\n            }\n        }\n        for (const guides of result) {\n            guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n        }\n        return result;\n    }\n    getVisibleColumnFromPosition(position) {\n        return (CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\n            throw new Error('Illegal value for startLineNumber');\n        }\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\n            throw new Error('Illegal value for endLineNumber');\n        }\n        const options = this.textModel.getOptions();\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        const result = new Array(endLineNumber - startLineNumber + 1);\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let aboveContentLineIndent = -1;\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let belowContentLineIndent = -1;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const resultIndex = lineNumber - startLineNumber;\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\n            if (currentIndent >= 0) {\n                // This line has content (besides whitespace)\n                // Use the line's indent\n                aboveContentLineIndex = lineNumber - 1;\n                aboveContentLineIndent = currentIndent;\n                result[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n                continue;\n            }\n            if (aboveContentLineIndex === -2) {\n                aboveContentLineIndex = -1;\n                aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        aboveContentLineIndex = lineIndex;\n                        aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (belowContentLineIndex !== -1 &&\n                (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                belowContentLineIndex = -1;\n                belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        belowContentLineIndex = lineIndex;\n                        belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n        }\n        return result;\n    }\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n        const options = this.textModel.getOptions();\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n            // At the top or bottom of the file\n            return 0;\n        }\n        else if (aboveContentLineIndent < belowContentLineIndent) {\n            // we are inside the region above\n            return 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n        }\n        else if (aboveContentLineIndent === belowContentLineIndent) {\n            // we are in between two regions\n            return Math.ceil(belowContentLineIndent / options.indentSize);\n        }\n        else {\n            if (offSide) {\n                // same level as region below\n                return Math.ceil(belowContentLineIndent / options.indentSize);\n            }\n            else {\n                // we are inside the region that ends below\n                return 1 + Math.floor(belowContentLineIndent / options.indentSize);\n            }\n        }\n    }\n}\nexport class BracketPairGuidesClassNames {\n    constructor() {\n        this.activeClassName = 'indent-active';\n    }\n    getInlineClassName(nestingLevel, nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) {\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-indent-guide lvl-${level % 30}`;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TokenizationTextModelPart_1;\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { DisposableMap, DisposableStore, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { TokenizationRegistry, TreeSitterTokenizationRegistry } from '../languages.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { DefaultBackgroundTokenizer, TokenizerWithStateStoreAndTextModel, TrackingTokenizationStateStore } from './textModelTokens.js';\nimport { AbstractTokens, AttachedViewHandler } from './tokens.js';\nimport { TreeSitterTokens } from './treeSitterTokens.js';\nimport { ITreeSitterParserService } from '../services/treeSitterParserService.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nlet TokenizationTextModelPart = TokenizationTextModelPart_1 = class TokenizationTextModelPart extends TextModelPart {\n    constructor(_textModel, _bracketPairsTextModelPart, _languageId, _attachedViews, _languageService, _languageConfigurationService, _treeSitterService) {\n        super();\n        this._textModel = _textModel;\n        this._bracketPairsTextModelPart = _bracketPairsTextModelPart;\n        this._languageId = _languageId;\n        this._attachedViews = _attachedViews;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._treeSitterService = _treeSitterService;\n        this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n        this._onDidChangeLanguage = this._register(new Emitter());\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this._tokensDisposables = this._register(new DisposableStore());\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            if (e.affects(this._languageId)) {\n                this._onDidChangeLanguageConfiguration.fire({});\n            }\n        }));\n        // We just look at registry changes to determine whether to use tree sitter.\n        // This means that removing a language from the setting will not cause a switch to textmate and will require a reload.\n        // Adding a language to the setting will not need a reload, however.\n        this._register(Event.filter(TreeSitterTokenizationRegistry.onDidChange, (e) => e.changedLanguages.includes(this._languageId))(() => {\n            this.createPreferredTokenProvider();\n        }));\n        this.createPreferredTokenProvider();\n    }\n    createGrammarTokens() {\n        return this._register(new GrammarTokens(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));\n    }\n    createTreeSitterTokens() {\n        return this._register(new TreeSitterTokens(this._treeSitterService, this._languageService.languageIdCodec, this._textModel, () => this._languageId));\n    }\n    createTokens(useTreeSitter) {\n        const needsReset = this._tokens !== undefined;\n        this._tokens?.dispose();\n        this._tokens = useTreeSitter ? this.createTreeSitterTokens() : this.createGrammarTokens();\n        this._tokensDisposables.clear();\n        this._tokensDisposables.add(this._tokens.onDidChangeTokens(e => {\n            this._emitModelTokensChangedEvent(e);\n        }));\n        this._tokensDisposables.add(this._tokens.onDidChangeBackgroundTokenizationState(e => {\n            this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n        }));\n        if (needsReset) {\n            // We need to reset the tokenization, as the new token provider otherwise won't have a chance to provide tokens until some action happens in the editor.\n            this._tokens.resetTokenization();\n        }\n    }\n    createPreferredTokenProvider() {\n        if (TreeSitterTokenizationRegistry.get(this._languageId)) {\n            if (!(this._tokens instanceof TreeSitterTokens)) {\n                this.createTokens(true);\n            }\n        }\n        else {\n            if (!(this._tokens instanceof GrammarTokens)) {\n                this.createTokens(false);\n            }\n        }\n    }\n    handleLanguageConfigurationServiceChange(e) {\n        if (e.affects(this._languageId)) {\n            this._onDidChangeLanguageConfiguration.fire({});\n        }\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            this._semanticTokens.flush();\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(c.text);\n                this._semanticTokens.acceptEdit(c.range, eolCount, firstLineLength, lastLineLength, c.text.length > 0 ? c.text.charCodeAt(0) : 0 /* CharCode.Null */);\n            }\n        }\n        this._tokens.handleDidChangeContent(e);\n    }\n    handleDidChangeAttached() {\n        this._tokens.handleDidChangeAttached();\n    }\n    /**\n     * Includes grammar and semantic tokens.\n     */\n    getLineTokens(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        const syntacticTokens = this._tokens.getLineTokens(lineNumber);\n        return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n    }\n    _emitModelTokensChangedEvent(e) {\n        if (!this._textModel._isDisposing()) {\n            this._bracketPairsTextModelPart.handleDidChangeTokens(e);\n            this._onDidChangeTokens.fire(e);\n        }\n    }\n    // #region Grammar Tokens\n    validateLineNumber(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n    resetTokenization() {\n        this._tokens.resetTokenization();\n    }\n    get backgroundTokenizationState() {\n        return this._tokens.backgroundTokenizationState;\n    }\n    forceTokenization(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this._tokens.forceTokenization(lineNumber);\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this._tokens.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this._tokens.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this._tokens.tokenizeIfCheap(lineNumber);\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        return this._tokens.getTokenTypeIfInsertingCharacter(lineNumber, column, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        return this._tokens.tokenizeLineWithEdit(position, length, newText);\n    }\n    // #endregion\n    // #region Semantic Tokens\n    setSemanticTokens(tokens, isComplete) {\n        this._semanticTokens.set(tokens, isComplete);\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: tokens !== null,\n            ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }],\n        });\n    }\n    hasCompleteSemanticTokens() {\n        return this._semanticTokens.isComplete();\n    }\n    hasSomeSemanticTokens() {\n        return !this._semanticTokens.isEmpty();\n    }\n    setPartialSemanticTokens(range, tokens) {\n        if (this.hasCompleteSemanticTokens()) {\n            return;\n        }\n        const changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens));\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: true,\n            ranges: [\n                {\n                    fromLineNumber: changedRange.startLineNumber,\n                    toLineNumber: changedRange.endLineNumber,\n                },\n            ],\n        });\n    }\n    // #endregion\n    // #region Utility Methods\n    getWordAtPosition(_position) {\n        this.assertNotDisposed();\n        const position = this._textModel.validatePosition(_position);\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        // (1). First try checking right biased word\n        const [rbStartOffset, rbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex);\n        const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (rightBiasedWord &&\n            rightBiasedWord.startColumn <= _position.column &&\n            _position.column <= rightBiasedWord.endColumn) {\n            return rightBiasedWord;\n        }\n        // (2). Else, if we were at a language boundary, check the left biased word\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n            // edge case, where `position` sits between two tokens belonging to two different languages\n            const [lbStartOffset, lbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n            const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (leftBiasedWord &&\n                leftBiasedWord.startColumn <= _position.column &&\n                _position.column <= leftBiasedWord.endColumn) {\n                return leftBiasedWord;\n            }\n        }\n        return null;\n    }\n    getLanguageConfiguration(languageId) {\n        return this._languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\n        const languageId = lineTokens.getLanguageId(tokenIndex);\n        // go left until a different language is hit\n        let startOffset = 0;\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n            startOffset = lineTokens.getStartOffset(i);\n        }\n        // go right until a different language is hit\n        let endOffset = lineTokens.getLineContent().length;\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n            endOffset = lineTokens.getEndOffset(i);\n        }\n        return [startOffset, endOffset];\n    }\n    getWordUntilPosition(position) {\n        const wordAtPosition = this.getWordAtPosition(position);\n        if (!wordAtPosition) {\n            return { word: '', startColumn: position.column, endColumn: position.column, };\n        }\n        return {\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column,\n        };\n    }\n    // #endregion\n    // #region Language Id handling\n    getLanguageId() {\n        return this._languageId;\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    }\n    setLanguageId(languageId, source = 'api') {\n        if (this._languageId === languageId) {\n            // There's nothing to do\n            return;\n        }\n        const e = {\n            oldLanguage: this._languageId,\n            newLanguage: languageId,\n            source\n        };\n        this._languageId = languageId;\n        this._bracketPairsTextModelPart.handleDidChangeLanguage(e);\n        this._tokens.resetTokenization();\n        this.createPreferredTokenProvider();\n        this._onDidChangeLanguage.fire(e);\n        this._onDidChangeLanguageConfiguration.fire({});\n    }\n};\nTokenizationTextModelPart = TokenizationTextModelPart_1 = __decorate([\n    __param(4, ILanguageService),\n    __param(5, ILanguageConfigurationService),\n    __param(6, ITreeSitterParserService)\n], TokenizationTextModelPart);\nexport { TokenizationTextModelPart };\nclass GrammarTokens extends AbstractTokens {\n    constructor(languageIdCodec, textModel, getLanguageId, attachedViews) {\n        super(languageIdCodec, textModel, getLanguageId);\n        this._tokenizer = null;\n        this._defaultBackgroundTokenizer = null;\n        this._backgroundTokenizer = this._register(new MutableDisposable());\n        this._tokens = new ContiguousTokensStore(this._languageIdCodec);\n        this._debugBackgroundTokenizer = this._register(new MutableDisposable());\n        this._attachedViewStates = this._register(new DisposableMap());\n        this._register(TokenizationRegistry.onDidChange((e) => {\n            const languageId = this.getLanguageId();\n            if (e.changedLanguages.indexOf(languageId) === -1) {\n                return;\n            }\n            this.resetTokenization();\n        }));\n        this.resetTokenization();\n        this._register(attachedViews.onDidChangeVisibleRanges(({ view, state }) => {\n            if (state) {\n                let existing = this._attachedViewStates.get(view);\n                if (!existing) {\n                    existing = new AttachedViewHandler(() => this.refreshRanges(existing.lineRanges));\n                    this._attachedViewStates.set(view, existing);\n                }\n                existing.handleStateChange(state);\n            }\n            else {\n                this._attachedViewStates.deleteAndDispose(view);\n            }\n        }));\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        this._tokens.flush();\n        this._debugBackgroundTokens?.flush();\n        if (this._debugBackgroundStates) {\n            this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n        }\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        const initializeTokenization = () => {\n            if (this._textModel.isTooLargeForTokenization()) {\n                return [null, null];\n            }\n            const tokenizationSupport = TokenizationRegistry.get(this.getLanguageId());\n            if (!tokenizationSupport) {\n                return [null, null];\n            }\n            let initialState;\n            try {\n                initialState = tokenizationSupport.getInitialState();\n            }\n            catch (e) {\n                onUnexpectedError(e);\n                return [null, null];\n            }\n            return [tokenizationSupport, initialState];\n        };\n        const [tokenizationSupport, initialState] = initializeTokenization();\n        if (tokenizationSupport && initialState) {\n            this._tokenizer = new TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec);\n        }\n        else {\n            this._tokenizer = null;\n        }\n        this._backgroundTokenizer.clear();\n        this._defaultBackgroundTokenizer = null;\n        if (this._tokenizer) {\n            const b = {\n                setTokens: (tokens) => {\n                    this.setTokens(tokens);\n                },\n                backgroundTokenizationFinished: () => {\n                    if (this._backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n                        // We already did a full tokenization and don't go back to progressing.\n                        return;\n                    }\n                    const newState = 2 /* BackgroundTokenizationState.Completed */;\n                    this._backgroundTokenizationState = newState;\n                    this._onDidChangeBackgroundTokenizationState.fire();\n                },\n                setEndState: (lineNumber, state) => {\n                    if (!this._tokenizer) {\n                        return;\n                    }\n                    const firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();\n                    // Don't accept states for definitely valid states, the renderer is ahead of the worker!\n                    if (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {\n                        this._tokenizer?.store.setEndState(lineNumber, state);\n                    }\n                },\n            };\n            if (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) {\n                this._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);\n            }\n            if (!this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization()) {\n                this._backgroundTokenizer.value = this._defaultBackgroundTokenizer =\n                    new DefaultBackgroundTokenizer(this._tokenizer, b);\n                this._defaultBackgroundTokenizer.handleChanges();\n            }\n            if (tokenizationSupport?.backgroundTokenizerShouldOnlyVerifyTokens && tokenizationSupport.createBackgroundTokenizer) {\n                this._debugBackgroundTokens = new ContiguousTokensStore(this._languageIdCodec);\n                this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n                this._debugBackgroundTokenizer.clear();\n                this._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {\n                    setTokens: (tokens) => {\n                        this._debugBackgroundTokens?.setMultilineTokens(tokens, this._textModel);\n                    },\n                    backgroundTokenizationFinished() {\n                        // NO OP\n                    },\n                    setEndState: (lineNumber, state) => {\n                        this._debugBackgroundStates?.setEndState(lineNumber, state);\n                    },\n                });\n            }\n            else {\n                this._debugBackgroundTokens = undefined;\n                this._debugBackgroundStates = undefined;\n                this._debugBackgroundTokenizer.value = undefined;\n            }\n        }\n        this.refreshAllVisibleLineTokens();\n    }\n    handleDidChangeAttached() {\n        this._defaultBackgroundTokenizer?.handleChanges();\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength] = countEOL(c.text);\n                this._tokens.acceptEdit(c.range, eolCount, firstLineLength);\n                this._debugBackgroundTokens?.acceptEdit(c.range, eolCount, firstLineLength);\n            }\n            this._debugBackgroundStates?.acceptChanges(e.changes);\n            if (this._tokenizer) {\n                this._tokenizer.store.acceptChanges(e.changes);\n            }\n            this._defaultBackgroundTokenizer?.handleChanges();\n        }\n    }\n    setTokens(tokens) {\n        const { changes } = this._tokens.setMultilineTokens(tokens, this._textModel);\n        if (changes.length > 0) {\n            this._onDidChangeTokens.fire({ semanticTokensApplied: false, ranges: changes, });\n        }\n        return { changes: changes };\n    }\n    refreshAllVisibleLineTokens() {\n        const ranges = LineRange.joinMany([...this._attachedViewStates].map(([_, s]) => s.lineRanges));\n        this.refreshRanges(ranges);\n    }\n    refreshRanges(ranges) {\n        for (const range of ranges) {\n            this.refreshRange(range.startLineNumber, range.endLineNumberExclusive - 1);\n        }\n    }\n    refreshRange(startLineNumber, endLineNumber) {\n        if (!this._tokenizer) {\n            return;\n        }\n        startLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));\n        endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n        const builder = new ContiguousMultilineTokensBuilder();\n        const { heuristicTokens } = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber);\n        const changedTokens = this.setTokens(builder.finalize());\n        if (heuristicTokens) {\n            // We overrode tokens with heuristically computed ones.\n            // Because old states might get reused (thus stopping invalidation),\n            // we have to explicitly request the tokens for the changed ranges again.\n            for (const c of changedTokens.changes) {\n                this._backgroundTokenizer.value?.requestTokens(c.fromLineNumber, c.toLineNumber + 1);\n            }\n        }\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    forceTokenization(lineNumber) {\n        const builder = new ContiguousMultilineTokensBuilder();\n        this._tokenizer?.updateTokensUntilLine(builder, lineNumber);\n        this.setTokens(builder.finalize());\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.isCheapToTokenize(lineNumber);\n    }\n    getLineTokens(lineNumber) {\n        const lineText = this._textModel.getLineContent(lineNumber);\n        const result = this._tokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n        if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {\n            if (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {\n                const backgroundResult = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n                if (!result.equals(backgroundResult) && this._debugBackgroundTokenizer.value?.reportMismatchingTokens) {\n                    this._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);\n                }\n            }\n        }\n        return result;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        if (!this._tokenizer) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        this.forceTokenization(position.lineNumber);\n        return this._tokenizer.getTokenTypeIfInsertingCharacter(position, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        if (!this._tokenizer) {\n            return null;\n        }\n        const validatedPosition = this._textModel.validatePosition(position);\n        this.forceTokenization(validatedPosition.lineNumber);\n        return this._tokenizer.tokenizeLineWithEdit(validatedPosition, length, newText);\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TextModel_1;\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable, combinedDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { AttachedViews } from './tokens.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nexport function createTextBufferFactory(text) {\n    const builder = new PieceTreeTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexport function createTextBufferFactoryFromSnapshot(snapshot) {\n    const builder = new PieceTreeTextBufferBuilder();\n    let chunk;\n    while (typeof (chunk = snapshot.read()) === 'string') {\n        builder.acceptChunk(chunk);\n    }\n    return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n    let factory;\n    if (typeof value === 'string') {\n        factory = createTextBufferFactory(value);\n    }\n    else if (model.isITextSnapshot(value)) {\n        factory = createTextBufferFactoryFromSnapshot(value);\n    }\n    else {\n        factory = value;\n    }\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nconst LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        const result = [];\n        let resultCnt = 0;\n        let resultLength = 0;\n        do {\n            const tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nlet TextModel = class TextModel extends Disposable {\n    static { TextModel_1 = this; }\n    static { this._MODEL_SYNC_LIMIT = 50 * 1024 * 1024; } // 50 MB,  // used in tests\n    static { this.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; } // 20 MB;\n    static { this.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; } // 300K lines\n    static { this.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024; } // 256M characters, usually ~> 512MB memory usage\n    static { this.DEFAULT_CREATION_OPTIONS = {\n        isForSimpleWidget: false,\n        tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n        indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n        insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n        detectIndentation: false,\n        defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n        trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n        largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n        bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n    }; }\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: 'tabSize', // TODO@Alex: guess indentSize independent of tabSize\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL,\n                bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n            });\n        }\n        return new model.TextModelResolvedOptions(options);\n    }\n    get onDidChangeLanguage() { return this._tokenizationTextModelPart.onDidChangeLanguage; }\n    get onDidChangeLanguageConfiguration() { return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration; }\n    get onDidChangeTokens() { return this._tokenizationTextModelPart.onDidChangeTokens; }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContentOrInjectedText(listener) {\n        return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n    }\n    _isDisposing() { return this.__isDisposing; }\n    get tokenization() { return this._tokenizationTextModelPart; }\n    get bracketPairs() { return this._bracketPairs; }\n    get guides() { return this._guidesTextModelPart; }\n    constructor(source, languageIdOrSelection, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService, instantiationService) {\n        super();\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this.instantiationService = instantiationService;\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\n        this._onDidChangeAttached = this._register(new Emitter());\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\n        this._onDidChangeInjectedText = this._register(new Emitter());\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        this._languageSelectionListener = this._register(new MutableDisposable());\n        this._deltaDecorationCallCnt = 0;\n        this._attachedViews = new AttachedViews();\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        this._options = TextModel_1.resolveOptions(this._buffer, creationOptions);\n        const languageId = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        if (typeof languageIdOrSelection !== 'string') {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));\n        }\n        this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n        this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n        this._tokenizationTextModelPart = this.instantiationService.createInstance(TokenizationTextModelPart, this, this._bracketPairs, languageId, this._attachedViews);\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel_1.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel_1.LARGE_FILE_LINE_COUNT_THRESHOLD));\n            this._isTooLargeForHeapOperation = bufferTextLength > TextModel_1.LARGE_FILE_HEAP_OPERATION_THRESHOLD;\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n            this._isTooLargeForHeapOperation = false;\n        }\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel_1._MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this.__isDisposing = false;\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, this._undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._register(this._decorationProvider.onDidChange(() => {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }));\n        this._languageService.requestRichLanguageFeatures(languageId);\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            this._bracketPairs.handleLanguageConfigurationServiceChange(e);\n            this._tokenizationTextModelPart.handleLanguageConfigurationServiceChange(e);\n        }));\n    }\n    dispose() {\n        this.__isDisposing = true;\n        this._onWillDispose.fire();\n        this._tokenizationTextModelPart.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this.__isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n        this._bufferDisposable = Disposable.None;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new BugIndicatingError('Model is disposed!');\n        }\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        if (this.__isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._tokenizationTextModelPart.handleDidChangeContent(change);\n        this._bracketPairs.handleDidChangeContent(change);\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value) {\n        this._assertNotDisposed();\n        if (value === null || value === undefined) {\n            throw illegalArgument();\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush, isEolChange) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            isEolChange: isEolChange,\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true, false));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false, true));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        this._decorationsTree.ensureAllNodesHaveRanges(this);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        return this._attachedViews.attachView();\n    }\n    onBeforeDetached(view) {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        this._attachedViews.detachView(view);\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isTooLargeForHeapOperation() {\n        return this._isTooLargeForHeapOperation;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        const tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        const indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.originalIndentSize;\n        const insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        const trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        const bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n        const newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            bracketPairColorizationOptions,\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        const e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._bracketPairs.handleDidChangeOptions(e);\n        this._decorationProvider.handleDidChangeOptions(e);\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        const offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* model.EndOfLineSequence.LF */\n            : 1 /* model.EndOfLineSequence.CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        const candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null) {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            const incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    const sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    const trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits = false) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            // We do a first pass to update decorations\n            // because we want to read decorations in the second pass\n            // where we will emit content change events\n            // and we want to read the final decorations\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n            }\n            const rawContentChanges = [];\n            this._increaseVersionId();\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount] = countEOL(change.text);\n                this._onDidChangeDecorations.fire();\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n                const firstEditLineNumber = currentEditStartLineNumber;\n                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n                const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n                const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = currentEditStartLineNumber + j;\n                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    const injectedTexts = [];\n                    const newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const lineNumber = fromLineNumber + i;\n                        newLines[i] = this.getLineContent(lineNumber);\n                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                isEolChange: false,\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n        // This is called before the decoration changed event is fired.\n        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n            return;\n        }\n        const affectedLines = Array.from(affectedInjectedTextLines);\n        const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n        this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n    }\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        const changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._deltaDecorationCallCnt++;\n            if (this._deltaDecorationCallCnt > 1) {\n                console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n                onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n            }\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n            this._deltaDecorationCallCnt--;\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }], true)[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return this._decorationsTree.getNodeRange(this, node);\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false, onlyMarginDecorations = false) {\n        const lineCount = this.getLineCount();\n        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false, onlyMinimapDecorations = false, onlyMarginDecorations = false) {\n        const validatedRange = this.validateRange(range);\n        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));\n        return decorations;\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true, false);\n    }\n    getInjectedTextDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllInjectedText(this, ownerId);\n    }\n    _getInjectedTextInLine(lineNumber) {\n        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n        return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\n        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false, false);\n        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n        return result;\n    }\n    getAllMarginDecorations(ownerId = 0) {\n        return this._decorationsTree.getAll(this, ownerId, false, false, true);\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, onlyMarginDecorations);\n    }\n    getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        if (node.options.after) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n        }\n        if (node.options.before) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n    }\n    _changeDecorationOptionsImpl(decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (node.options.after || options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n        }\n        if (node.options.before || options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n        }\n        const movedInOverviewRuler = nodeWasInOverviewRuler !== nodeIsInOverviewRuler;\n        const changedWhetherInjectedText = isOptionsInjectedText(options) !== isNodeInjectedText(node);\n        if (movedInOverviewRuler || changedWhetherInjectedText) {\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations, suppressEvents = false) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        this._onDidChangeDecorations.beginDeferredEmit();\n        try {\n            const result = new Array(newDecorationsLen);\n            while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n                let node = null;\n                if (oldDecorationIndex < oldDecorationsLen) {\n                    // (1) get ourselves an old node\n                    do {\n                        node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                    } while (!node && oldDecorationIndex < oldDecorationsLen);\n                    // (2) remove the node from the tree (if it exists)\n                    if (node) {\n                        if (node.options.after) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n                        }\n                        if (node.options.before) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n                        }\n                        this._decorationsTree.delete(node);\n                        if (!suppressEvents) {\n                            this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                        }\n                    }\n                }\n                if (newDecorationIndex < newDecorationsLen) {\n                    // (3) create a new node if necessary\n                    if (!node) {\n                        const internalDecorationId = (++this._lastDecorationId);\n                        const decorationId = `${this._instanceId};${internalDecorationId}`;\n                        node = new IntervalNode(decorationId, 0, 0);\n                        this._decorations[decorationId] = node;\n                    }\n                    // (4) initialize node\n                    const newDecoration = newDecorations[newDecorationIndex];\n                    const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                    const options = _normalizeOptions(newDecoration.options);\n                    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                    node.ownerId = ownerId;\n                    node.reset(versionId, startOffset, endOffset, range);\n                    node.setOptions(options);\n                    if (node.options.after) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n                    }\n                    if (node.options.before) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n                    }\n                    if (!suppressEvents) {\n                        this._onDidChangeDecorations.checkAffectedAndFire(options);\n                    }\n                    this._decorationsTree.insert(node);\n                    result[newDecorationIndex] = node.id;\n                    newDecorationIndex++;\n                }\n                else {\n                    if (node) {\n                        delete this._decorations[node.id];\n                    }\n                }\n            }\n            return result;\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    //#endregion\n    //#region Tokenization\n    // TODO move them to the tokenization part.\n    getLanguageId() {\n        return this.tokenization.getLanguageId();\n    }\n    setLanguage(languageIdOrSelection, source) {\n        if (typeof languageIdOrSelection === 'string') {\n            this._languageSelectionListener.clear();\n            this._setLanguage(languageIdOrSelection, source);\n        }\n        else {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));\n            this._setLanguage(languageIdOrSelection.languageId, source);\n        }\n    }\n    _setLanguage(languageId, source) {\n        this.tokenization.setLanguageId(languageId, source);\n        this._languageService.requestRichLanguageFeatures(languageId);\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n    }\n    getWordAtPosition(position) {\n        return this._tokenizationTextModelPart.getWordAtPosition(position);\n    }\n    getWordUntilPosition(position) {\n        return this._tokenizationTextModelPart.getWordUntilPosition(position);\n    }\n    //#endregion\n    normalizePosition(position, affinity) {\n        return position;\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        // Columns start with 1.\n        return indentOfLine(this.getLineContent(lineNumber)) + 1;\n    }\n};\nTextModel = TextModel_1 = __decorate([\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService),\n    __param(7, IInstantiationService)\n], TextModel);\nexport { TextModel };\nexport function indentOfLine(line) {\n    let indent = 0;\n    for (const c of line) {\n        if (c === ' ' || c === '\\t') {\n            indent++;\n        }\n        else {\n            break;\n        }\n    }\n    return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\nfunction isOptionsInjectedText(options) {\n    return !!options.after || !!options.before;\n}\nfunction isNodeInjectedText(node) {\n    return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n        this._injectedTextDecorationsTree = new IntervalTree();\n    }\n    ensureAllNodesHaveRanges(host) {\n        this.getAll(host, 0, false, false, false);\n    }\n    _ensureNodesHaveRanges(host, nodes) {\n        for (const node of nodes) {\n            if (node.range === null) {\n                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        return r0.concat(r1).concat(r2);\n    }\n    getInjectedTextInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAllInjectedText(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId, onlyMarginDecorations) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            return r0.concat(r1).concat(r2);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n        return r0.concat(r1).concat(r2);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n        return r0.concat(r1).concat(r2);\n    }\n    insert(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.insert(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.delete(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    getNodeRange(host, node) {\n        const versionId = host.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    _resolveNode(node, cachedVersionId) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        const c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nexport class ModelDecorationGlyphMarginOptions {\n    constructor(options) {\n        this.position = options?.position ?? model.GlyphMarginLane.Center;\n        this.persistLane = options?.persistLane;\n    }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this.position = options.position;\n        this.sectionHeaderStyle = options.sectionHeaderStyle ?? null;\n        this.sectionHeaderText = options.sectionHeaderText ?? null;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nexport class ModelDecorationInjectedTextOptions {\n    static from(options) {\n        if (options instanceof ModelDecorationInjectedTextOptions) {\n            return options;\n        }\n        return new ModelDecorationInjectedTextOptions(options);\n    }\n    constructor(options) {\n        this.content = options.content || '';\n        this.inlineClassName = options.inlineClassName || null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.attachedData = options.attachedData || null;\n        this.cursorStops = options.cursorStops || null;\n    }\n}\nexport class ModelDecorationOptions {\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n    constructor(options) {\n        this.description = options.description;\n        this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n        this.blockDoesNotCollapse = options.blockDoesNotCollapse ?? null;\n        this.blockIsAfterEnd = options.blockIsAfterEnd ?? null;\n        this.blockPadding = options.blockPadding ?? null;\n        this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.shouldFillLineOnLineBreak = options.shouldFillLineOnLineBreak ?? null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.lineNumberHoverMessage = options.lineNumberHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.lineNumberClassName = options.lineNumberClassName ? cleanClassName(options.lineNumberClassName) : null;\n        this.linesDecorationsTooltip = options.linesDecorationsTooltip ? strings.htmlAttributeEncodeValue(options.linesDecorationsTooltip) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n        this.hideInCommentTokens = options.hideInCommentTokens ?? false;\n        this.hideInStringTokens = options.hideInStringTokens ?? false;\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nclass DidChangeDecorationsEmitter extends Disposable {\n    constructor(handleBeforeFire) {\n        super();\n        this.handleBeforeFire = handleBeforeFire;\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._affectedInjectedTextLines = null;\n        this._deferredCnt = 0;\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._affectsLineNumber = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFireDeferred) {\n                this.doFire();\n            }\n            this._affectedInjectedTextLines?.clear();\n            this._affectedInjectedTextLines = null;\n        }\n    }\n    recordLineAffectedByInjectedText(lineNumber) {\n        if (!this._affectedInjectedTextLines) {\n            this._affectedInjectedTextLines = new Set();\n        }\n        this._affectedInjectedTextLines.add(lineNumber);\n    }\n    checkAffectedAndFire(options) {\n        this._affectsMinimap ||= !!options.minimap?.position;\n        this._affectsOverviewRuler ||= !!options.overviewRuler?.color;\n        this._affectsGlyphMargin ||= !!options.glyphMarginClassName;\n        this._affectsLineNumber ||= !!options.lineNumberClassName;\n        this.tryFire();\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._affectsGlyphMargin = true;\n        this.tryFire();\n    }\n    tryFire() {\n        if (this._deferredCnt === 0) {\n            this.doFire();\n        }\n        else {\n            this._shouldFireDeferred = true;\n        }\n    }\n    doFire() {\n        this.handleBeforeFire(this._affectedInjectedTextLines);\n        const event = {\n            affectsMinimap: this._affectsMinimap,\n            affectsOverviewRuler: this._affectsOverviewRuler,\n            affectsGlyphMargin: this._affectsGlyphMargin,\n            affectsLineNumber: this._affectsLineNumber,\n        };\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._actual.fire(event);\n    }\n}\n//#endregion\nclass DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class BracketInfo {\n    constructor(range, \n    /** 0-based level */\n    nestingLevel, nestingLevelOfEqualBracketType, isInvalid) {\n        this.range = range;\n        this.nestingLevel = nestingLevel;\n        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;\n        this.isInvalid = isInvalid;\n    }\n}\nexport class BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /** 0-based */\n    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode) {\n        this.range = range;\n        this.openingBracketRange = openingBracketRange;\n        this.closingBracketRange = closingBracketRange;\n        this.nestingLevel = nestingLevel;\n        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;\n        this.bracketPairNode = bracketPairNode;\n    }\n    get openingBracketInfo() {\n        return this.bracketPairNode.openingBracket.bracketInfo;\n    }\n}\nexport class BracketPairWithMinIndentationInfo extends BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /**\n     * 0-based\n    */\n    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode, \n    /**\n     * -1 if not requested, otherwise the size of the minimum indentation in the bracket pair in terms of visible columns.\n    */\n    minVisibleColumnIndentation) {\n        super(range, openingBracketRange, closingBracketRange, nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode);\n        this.minVisibleColumnIndentation = minVisibleColumnIndentation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from '../../../textModelBracketPairs.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThan, lengthLessThanEqual, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nimport { CallbackIterable } from '../../../../../base/common/arrays.js';\nimport { combineTextEditInfos } from './combineTextEditInfos.js';\nexport class BracketPairsTree extends Disposable {\n    didLanguageChange(languageId) {\n        return this.brackets.didLanguageChange(languageId);\n    }\n    constructor(textModel, getLanguageConfiguration) {\n        super();\n        this.textModel = textModel;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.didChangeEmitter = new Emitter();\n        this.denseKeyProvider = new DenseKeyProvider();\n        this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n        this.onDidChange = this.didChangeEmitter.event;\n        this.queuedTextEditsForInitialAstWithoutTokens = [];\n        this.queuedTextEdits = [];\n        if (!textModel.tokenization.hasTokens) {\n            const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n            const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n            this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n        else if (textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            // Skip the initial ast, as there is no flickering.\n            // Directly create the tree with token information.\n            this.initialAstWithoutTokens = undefined;\n            this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n        }\n        else {\n            // We missed some token changes already, so we cannot use the fast tokenizer + delta increments\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n    }\n    //#region TextModel events\n    handleDidChangeBackgroundTokenizationState() {\n        if (this.textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            const wasUndefined = this.initialAstWithoutTokens === undefined;\n            // Clear the initial tree as we can use the tree with token information now.\n            this.initialAstWithoutTokens = undefined;\n            if (!wasUndefined) {\n                this.didChangeEmitter.fire();\n            }\n        }\n    }\n    handleDidChangeTokens({ ranges }) {\n        const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n        this.handleEdits(edits, true);\n        if (!this.initialAstWithoutTokens) {\n            this.didChangeEmitter.fire();\n        }\n    }\n    handleContentChanged(change) {\n        const edits = TextEditInfo.fromModelContentChanges(change.changes);\n        this.handleEdits(edits, false);\n    }\n    handleEdits(edits, tokenChange) {\n        // Lazily queue the edits and only apply them when the tree is accessed.\n        const result = combineTextEditInfos(this.queuedTextEdits, edits);\n        this.queuedTextEdits = result;\n        if (this.initialAstWithoutTokens && !tokenChange) {\n            this.queuedTextEditsForInitialAstWithoutTokens = combineTextEditInfos(this.queuedTextEditsForInitialAstWithoutTokens, edits);\n        }\n    }\n    //#endregion\n    flushQueue() {\n        if (this.queuedTextEdits.length > 0) {\n            this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false);\n            this.queuedTextEdits = [];\n        }\n        if (this.queuedTextEditsForInitialAstWithoutTokens.length > 0) {\n            if (this.initialAstWithoutTokens) {\n                this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false);\n            }\n            this.queuedTextEditsForInitialAstWithoutTokens = [];\n        }\n    }\n    /**\n     * @pure (only if isPure = true)\n    */\n    parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n        // Is much faster if `isPure = false`.\n        const isPure = false;\n        const previousAstClone = isPure ? previousAst?.deepClone() : previousAst;\n        const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n        const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n        return result;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets) {\n        this.flushQueue();\n        const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n        const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            collectBrackets(node, lengthZero, node.length, startOffset, endOffset, cb, 0, 0, new Map(), onlyColorizedBrackets);\n        });\n    }\n    getBracketPairsInRange(range, includeMinIndentation) {\n        this.flushQueue();\n        const startLength = positionToLength(range.getStartPosition());\n        const endLength = positionToLength(range.getEndPosition());\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            const context = new CollectBracketPairsContext(cb, includeMinIndentation, this.textModel);\n            collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n        });\n    }\n    getFirstBracketAfter(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n    }\n    getFirstBracketBefore(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n    }\n}\nfunction getFirstBracketBefore(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        const lengths = [];\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            lengths.push({ nodeOffsetStart, nodeOffsetEnd });\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        for (let i = lengths.length - 1; i >= 0; i--) {\n            const { nodeOffsetStart, nodeOffsetEnd } = lengths[i];\n            if (lengthLessThan(nodeOffsetStart, position)) {\n                const result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction getFirstBracketAfter(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThan(position, nodeOffsetEnd)) {\n                const result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, nestingLevelOfEqualBracketType, levelPerBracketType, onlyColorizedBrackets, parentPairIsIncomplete = false) {\n    if (level > 200) {\n        return true;\n    }\n    whileLoop: while (true) {\n        switch (node.kind) {\n            case 4 /* AstNodeKind.List */: {\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd) {\n                            // No child after this child in the requested window, don't recurse\n                            node = child;\n                            continue whileLoop;\n                        }\n                        const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets);\n                        if (!shouldContinue) {\n                            return false;\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                return true;\n            }\n            case 2 /* AstNodeKind.Pair */: {\n                const colorize = !onlyColorizedBrackets || !node.closingBracket || node.closingBracket.bracketInfo.closesColorized(node.openingBracket.bracketInfo);\n                let levelPerBracket = 0;\n                if (levelPerBracketType) {\n                    let existing = levelPerBracketType.get(node.openingBracket.text);\n                    if (existing === undefined) {\n                        existing = 0;\n                    }\n                    levelPerBracket = existing;\n                    if (colorize) {\n                        existing++;\n                        levelPerBracketType.set(node.openingBracket.text, existing);\n                    }\n                }\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd && child.kind !== 1 /* AstNodeKind.Bracket */) {\n                            // No child after this child in the requested window, don't recurse\n                            // Don't do this for brackets because of unclosed/unopened brackets\n                            node = child;\n                            if (colorize) {\n                                level++;\n                                nestingLevelOfEqualBracketType = levelPerBracket + 1;\n                            }\n                            else {\n                                nestingLevelOfEqualBracketType = levelPerBracket;\n                            }\n                            continue whileLoop;\n                        }\n                        if (colorize || child.kind !== 1 /* AstNodeKind.Bracket */ || !node.closingBracket) {\n                            const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, colorize ? level + 1 : level, colorize ? levelPerBracket + 1 : levelPerBracket, levelPerBracketType, onlyColorizedBrackets, !node.closingBracket);\n                            if (!shouldContinue) {\n                                return false;\n                            }\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n                return true;\n            }\n            case 3 /* AstNodeKind.UnexpectedClosingBracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, 0, true));\n            }\n            case 1 /* AstNodeKind.Bracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));\n            }\n            case 0 /* AstNodeKind.Text */:\n                return true;\n        }\n    }\n}\nclass CollectBracketPairsContext {\n    constructor(push, includeMinIndentation, textModel) {\n        this.push = push;\n        this.includeMinIndentation = includeMinIndentation;\n        this.textModel = textModel;\n    }\n}\nfunction collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {\n    if (level > 200) {\n        return true;\n    }\n    let shouldContinue = true;\n    if (node.kind === 2 /* AstNodeKind.Pair */) {\n        let levelPerBracket = 0;\n        if (levelPerBracketType) {\n            let existing = levelPerBracketType.get(node.openingBracket.text);\n            if (existing === undefined) {\n                existing = 0;\n            }\n            levelPerBracket = existing;\n            existing++;\n            levelPerBracketType.set(node.openingBracket.text, existing);\n        }\n        const openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n        let minIndentation = -1;\n        if (context.includeMinIndentation) {\n            minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel);\n        }\n        shouldContinue = context.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffsetStart, nodeOffsetEnd), lengthsToRange(nodeOffsetStart, openingBracketEnd), node.closingBracket\n            ? lengthsToRange(lengthAdd(openingBracketEnd, node.child?.length || lengthZero), nodeOffsetEnd)\n            : undefined, level, levelPerBracket, node, minIndentation));\n        nodeOffsetStart = openingBracketEnd;\n        if (shouldContinue && node.child) {\n            const child = node.child;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                shouldContinue = collectBracketPairs(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level + 1, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n        levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n    }\n    else {\n        let curOffset = nodeOffsetStart;\n        for (const child of node.children) {\n            const childOffset = curOffset;\n            curOffset = lengthAdd(curOffset, child.length);\n            if (lengthLessThanEqual(childOffset, endOffset) &&\n                lengthLessThanEqual(startOffset, curOffset)) {\n                shouldContinue = collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n    }\n    return shouldContinue;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CallbackIterable, compareBy } from '../../../../base/common/arrays.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nexport class BracketPairsTextModelPart extends Disposable {\n    get canBuildAST() {\n        const maxSupportedDocumentLength = /* max lines */ 50_000 * /* average column count */ 100;\n        return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n    }\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.bracketPairsTree = this._register(new MutableDisposable());\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.bracketsRequested = false;\n    }\n    //#region TextModel events\n    handleLanguageConfigurationServiceChange(e) {\n        if (!e.languageId || this.bracketPairsTree.value?.object.didLanguageChange(e.languageId)) {\n            this.bracketPairsTree.clear();\n            this.updateBracketPairsTree();\n        }\n    }\n    handleDidChangeOptions(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeLanguage(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeContent(change) {\n        this.bracketPairsTree.value?.object.handleContentChanged(change);\n    }\n    handleDidChangeBackgroundTokenizationState() {\n        this.bracketPairsTree.value?.object.handleDidChangeBackgroundTokenizationState();\n    }\n    handleDidChangeTokens(e) {\n        this.bracketPairsTree.value?.object.handleDidChangeTokens(e);\n    }\n    //#endregion\n    updateBracketPairsTree() {\n        if (this.bracketsRequested && this.canBuildAST) {\n            if (!this.bracketPairsTree.value) {\n                const store = new DisposableStore();\n                this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, (languageId) => {\n                    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n                })), store);\n                store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n                this.onDidChangeEmitter.fire();\n            }\n        }\n        else {\n            if (this.bracketPairsTree.value) {\n                this.bracketPairsTree.clear();\n                // Important: Don't call fire if there was no change!\n                this.onDidChangeEmitter.fire();\n            }\n        }\n    }\n    /**\n     * Returns all bracket pairs that intersect the given range.\n     * The result is sorted by the start position.\n    */\n    getBracketPairsInRange(range) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, false) || CallbackIterable.empty;\n    }\n    getBracketPairsInRangeWithMinIndentation(range) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, true) || CallbackIterable.empty;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets = false) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketsInRange(range, onlyColorizedBrackets) || CallbackIterable.empty;\n    }\n    findMatchingBracketUp(_bracket, _position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n        if (this.canBuildAST) {\n            const closingBracketInfo = this.languageConfigurationService\n                .getLanguageConfiguration(languageId)\n                .bracketsNew.getClosingBracketInfo(_bracket);\n            if (!closingBracketInfo) {\n                return null;\n            }\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(_position, _position)).findLast((b) => closingBracketInfo.closes(b.openingBracketInfo));\n            if (bracketPair) {\n                return bracketPair.openingBracketRange;\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const bracket = _bracket.toLowerCase();\n            const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            if (!bracketsSupport) {\n                return null;\n            }\n            const data = bracketsSupport.textIsBracket[bracket];\n            if (!data) {\n                return null;\n            }\n            return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n        }\n    }\n    matchBracket(position, maxDuration) {\n        if (this.canBuildAST) {\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).filter((item) => item.closingBracketRange !== undefined &&\n                (item.openingBracketRange.containsPosition(position) ||\n                    item.closingBracketRange.containsPosition(position))).findLastMaxBy(compareBy((item) => item.openingBracketRange.containsPosition(position)\n                ? item.openingBracketRange\n                : item.closingBracketRange, Range.compareRangesUsingStarts));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n            return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n        }\n    }\n    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n        const tokenCount = lineTokens.getCount();\n        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n        // limit search to not go before `maxBracketLength`\n        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n        for (let i = tokenIndex - 1; i >= 0; i--) {\n            const tokenEndOffset = lineTokens.getEndOffset(i);\n            if (tokenEndOffset <= searchStartOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchStartOffset = tokenEndOffset;\n                break;\n            }\n        }\n        // limit search to not go after `maxBracketLength`\n        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n        for (let i = tokenIndex + 1; i < tokenCount; i++) {\n            const tokenStartOffset = lineTokens.getStartOffset(i);\n            if (tokenStartOffset >= searchEndOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchEndOffset = tokenStartOffset;\n                break;\n            }\n        }\n        return { searchStartOffset, searchEndOffset };\n    }\n    _matchBracket(position, continueSearchPredicate) {\n        const lineNumber = position.lineNumber;\n        const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        const lineText = this.textModel.getLineContent(lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            let bestResult = null;\n            while (true) {\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            const prevTokenIndex = tokenIndex - 1;\n            const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n                const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n        if (!data) {\n            return null;\n        }\n        const matched = (isOpen\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\n        if (!matched) {\n            return null;\n        }\n        if (matched instanceof BracketSearchCanceled) {\n            return matched;\n        }\n        return [foundBracket, matched];\n    }\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const reversedBracketRegex = bracket.reversedRegex;\n        let count = -1;\n        let totalCallCount = 0;\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchEndOffset = r.startColumn - 1;\n            }\n            return null;\n        };\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const bracketRegex = bracket.forwardRegex;\n        let count = 1;\n        let totalCallCount = 0;\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        const lineCount = this.textModel.getLineCount();\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    findPrevBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return this.bracketPairsTree.value?.object.getFirstBracketBefore(position) || null;\n        }\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findNextBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return this.bracketPairsTree.value?.object.getFirstBracketAfter(position) || null;\n        }\n        const lineCount = this.textModel.getLineCount();\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findEnclosingBrackets(_position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            const range = Range.fromPositions(position);\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).findLast((item) => item.closingBracketRange !== undefined && item.range.strictContainsRange(range));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n        const lineCount = this.textModel.getLineCount();\n        const savedCounts = new Map();\n        let counts = [];\n        const resetCounts = (languageId, modeBrackets) => {\n            if (!savedCounts.has(languageId)) {\n                const tmp = [];\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n                    tmp[i] = 0;\n                }\n                savedCounts.set(languageId, tmp);\n            }\n            counts = savedCounts.get(languageId);\n        };\n        let totalCallCount = 0;\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                const bracket = modeBrackets.textIsBracket[hitText];\n                if (bracket) {\n                    if (bracket.isOpen(hitText)) {\n                        counts[bracket.index]++;\n                    }\n                    else if (bracket.isClose(hitText)) {\n                        counts[bracket.index]--;\n                    }\n                    if (counts[bracket.index] === -1) {\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n                    }\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return stripBracketSearchCanceled(r);\n                }\n            }\n        }\n        return null;\n    }\n    _toFoundBracket(bracketConfig, r) {\n        if (!r) {\n            return null;\n        }\n        let text = this.textModel.getValueInRange(r);\n        text = text.toLowerCase();\n        const bracketInfo = bracketConfig.getBracketInfo(text);\n        if (!bracketInfo) {\n            return null;\n        }\n        return {\n            range: r,\n            bracketInfo\n        };\n    }\n}\nfunction createDisposableRef(object, disposable) {\n    return {\n        object,\n        dispose: () => disposable?.dispose(),\n    };\n}\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration) {\n    if (typeof maxDuration === 'undefined') {\n        return () => true;\n    }\n    else {\n        const startTime = Date.now();\n        return () => {\n            return (Date.now() - startTime <= maxDuration);\n        };\n    }\n}\nclass BracketSearchCanceled {\n    static { this.INSTANCE = new BracketSearchCanceled(); }\n    constructor() {\n        this._searchCanceledBrand = undefined;\n    }\n}\nfunction stripBracketSearchCanceled(result) {\n    if (result instanceof BracketSearchCanceled) {\n        return null;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { editorBracketHighlightingForeground1, editorBracketHighlightingForeground2, editorBracketHighlightingForeground3, editorBracketHighlightingForeground4, editorBracketHighlightingForeground5, editorBracketHighlightingForeground6, editorBracketHighlightingUnexpectedBracketForeground } from '../../core/editorColorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nexport class ColorizedBracketPairsDecorationProvider extends Disposable {\n    constructor(textModel) {\n        super();\n        this.textModel = textModel;\n        this.colorProvider = new ColorProvider();\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.colorizationOptions = textModel.getOptions().bracketPairColorizationOptions;\n        this._register(textModel.bracketPairs.onDidChange(e => {\n            this.onDidChangeEmitter.fire();\n        }));\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;\n    }\n    //#endregion\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations) {\n        if (onlyMinimapDecorations) {\n            // Bracket pair colorization decorations are not rendered in the minimap\n            return [];\n        }\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        const result = this.textModel.bracketPairs.getBracketsInRange(range, true).map(bracket => ({\n            id: `bracket${bracket.range.toString()}-${bracket.nestingLevel}`,\n            options: {\n                description: 'BracketPairColorization',\n                inlineClassName: this.colorProvider.getInlineClassName(bracket, this.colorizationOptions.independentColorPoolPerBracketType),\n            },\n            ownerId: 0,\n            range: bracket.range,\n        })).toArray();\n        return result;\n    }\n    getAllDecorations(ownerId, filterOutValidation) {\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        return this.getDecorationsInRange(new Range(1, 1, this.textModel.getLineCount(), 1), ownerId, filterOutValidation);\n    }\n}\nclass ColorProvider {\n    constructor() {\n        this.unexpectedClosingBracketClassName = 'unexpected-closing-bracket';\n    }\n    getInlineClassName(bracket, independentColorPoolPerBracketType) {\n        if (bracket.isInvalid) {\n            return this.unexpectedClosingBracketClassName;\n        }\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? bracket.nestingLevelOfEqualBracketType : bracket.nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-highlighting-${level % 30}`;\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    const colors = [\n        editorBracketHighlightingForeground1,\n        editorBracketHighlightingForeground2,\n        editorBracketHighlightingForeground3,\n        editorBracketHighlightingForeground4,\n        editorBracketHighlightingForeground5,\n        editorBracketHighlightingForeground6\n    ];\n    const colorProvider = new ColorProvider();\n    collector.addRule(`.monaco-editor .${colorProvider.unexpectedClosingBracketClassName} { color: ${theme.getColor(editorBracketHighlightingUnexpectedBracketForeground)}; }`);\n    const colorValues = colors\n        .map(c => theme.getColor(c))\n        .filter((c) => !!c)\n        .filter(c => !c.isTransparent());\n    for (let level = 0; level < 30; level++) {\n        const color = colorValues[level % colorValues.length];\n        collector.addRule(`.monaco-editor .${colorProvider.getInlineClassNameOfLevel(level)} { color: ${color}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass SpacesDiffResult {\n    constructor() {\n        this.spacesDiff = 0;\n        this.looksLikeAlignment = false;\n    }\n}\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a, aLength, b, bLength, result) {\n    result.spacesDiff = 0;\n    result.looksLikeAlignment = false;\n    // This can go both ways (e.g.):\n    //  - a: \"\\t\"\n    //  - b: \"\\t    \"\n    //  => This should count 1 tab and 4 spaces\n    let i;\n    for (i = 0; i < aLength && i < bLength; i++) {\n        const aCharCode = a.charCodeAt(i);\n        const bCharCode = b.charCodeAt(i);\n        if (aCharCode !== bCharCode) {\n            break;\n        }\n    }\n    let aSpacesCnt = 0, aTabsCount = 0;\n    for (let j = i; j < aLength; j++) {\n        const aCharCode = a.charCodeAt(j);\n        if (aCharCode === 32 /* CharCode.Space */) {\n            aSpacesCnt++;\n        }\n        else {\n            aTabsCount++;\n        }\n    }\n    let bSpacesCnt = 0, bTabsCount = 0;\n    for (let j = i; j < bLength; j++) {\n        const bCharCode = b.charCodeAt(j);\n        if (bCharCode === 32 /* CharCode.Space */) {\n            bSpacesCnt++;\n        }\n        else {\n            bTabsCount++;\n        }\n    }\n    if (aSpacesCnt > 0 && aTabsCount > 0) {\n        return;\n    }\n    if (bSpacesCnt > 0 && bTabsCount > 0) {\n        return;\n    }\n    const tabsDiff = Math.abs(aTabsCount - bTabsCount);\n    const spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n    if (tabsDiff === 0) {\n        // check if the indentation difference might be caused by alignment reasons\n        // sometime folks like to align their code, but this should not be used as a hint\n        result.spacesDiff = spacesDiff;\n        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n            if (b.charCodeAt(bSpacesCnt) !== 32 /* CharCode.Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* CharCode.Space */) {\n                if (a.charCodeAt(a.length - 1) === 44 /* CharCode.Comma */) {\n                    // This looks like an alignment desire: e.g.\n                    // const a = b + c,\n                    //       d = b - c;\n                    result.looksLikeAlignment = true;\n                }\n            }\n        }\n        return;\n    }\n    if (spacesDiff % tabsDiff === 0) {\n        result.spacesDiff = spacesDiff / tabsDiff;\n        return;\n    }\n}\nexport function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n    // Look at most at the first 10k lines\n    const linesCount = Math.min(source.getLineCount(), 10000);\n    let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n    let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n    let previousLineText = ''; // content of latest line that contained non-whitespace chars\n    let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n    const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n    const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n    const tmp = new SpacesDiffResult();\n    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n        const currentLineLength = source.getLineLength(lineNumber);\n        const currentLineText = source.getLineContent(lineNumber);\n        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n        // checking charCode on chunks directly is cheaper.\n        const useCurrentLineText = (currentLineLength <= 65536);\n        let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n        let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n        let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n        let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n        for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n            const charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n            if (charCode === 9 /* CharCode.Tab */) {\n                currentLineTabsCount++;\n            }\n            else if (charCode === 32 /* CharCode.Space */) {\n                currentLineSpacesCount++;\n            }\n            else {\n                // Hit non whitespace character on this line\n                currentLineHasContent = true;\n                currentLineIndentation = j;\n                break;\n            }\n        }\n        // Ignore empty or only whitespace lines\n        if (!currentLineHasContent) {\n            continue;\n        }\n        if (currentLineTabsCount > 0) {\n            linesIndentedWithTabsCount++;\n        }\n        else if (currentLineSpacesCount > 1) {\n            linesIndentedWithSpacesCount++;\n        }\n        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n        if (tmp.looksLikeAlignment) {\n            // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n            //\n            // - item1\n            //   - item2\n            //\n            // otherwise skip this line entirely\n            //\n            // const a = 1,\n            //       b = 2;\n            if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n                continue;\n            }\n        }\n        const currentSpacesDiff = tmp.spacesDiff;\n        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n            spacesDiffCount[currentSpacesDiff]++;\n        }\n        previousLineText = currentLineText;\n        previousLineIndentation = currentLineIndentation;\n    }\n    let insertSpaces = defaultInsertSpaces;\n    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n    }\n    let tabSize = defaultTabSize;\n    // Guess tabSize only if inserting spaces...\n    if (insertSpaces) {\n        let tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n        // console.log(\"score threshold: \" + tabSizeScore);\n        ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n            const possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n            if (possibleTabSizeScore > tabSizeScore) {\n                tabSizeScore = possibleTabSizeScore;\n                tabSize = possibleTabSize;\n            }\n        });\n        // Let a tabSize of 2 win even if it is not the maximum\n        // (only in case 4 was guessed)\n        if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n            tabSize = 2;\n        }\n    }\n    // console.log('--------------------------');\n    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n    // console.log('spacesDiffCount: ' + spacesDiffCount);\n    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n    return {\n        insertSpaces: insertSpaces,\n        tabSize: tabSize\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n    return ((node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */);\n}\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & 254 /* Constants.ColorMaskInverse */) | (color << 0 /* Constants.ColorOffset */));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & 253 /* Constants.IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & 251 /* Constants.IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */));\n}\nfunction getNodeIsInGlyphMargin(node) {\n    return ((node.metadata & 64 /* Constants.IsMarginMask */) >>> 6 /* Constants.IsMarginOffset */) === 1;\n}\nfunction setNodeIsInGlyphMargin(node, value) {\n    node.metadata = ((node.metadata & 191 /* Constants.IsMarginMaskInverse */) | ((value ? 1 : 0) << 6 /* Constants.IsMarginOffset */));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & 231 /* Constants.StickinessMaskInverse */) | (stickiness << 3 /* Constants.StickinessOffset */));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */));\n}\nexport class IntervalNode {\n    constructor(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, 1 /* NodeColor.Red */);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        setNodeIsInGlyphMargin(this, false);\n        _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        setCollapseOnReplaceEdit(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    reset(versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    }\n    setOptions(options) {\n        this.options = options;\n        const className = this.options.className;\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* ClassName.EditorErrorDecoration */\n            || className === \"squiggly-warning\" /* ClassName.EditorWarningDecoration */\n            || className === \"squiggly-info\" /* ClassName.EditorInfoDecoration */));\n        setNodeIsInGlyphMargin(this, this.options.glyphMarginClassName !== null);\n        _setNodeStickiness(this, this.options.stickiness);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* NodeColor.Black */);\nexport class IntervalTree {\n    constructor() {\n        this.root = SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesFromOwner(ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesPostOrder() {\n        return collectNodesPostOrder(this);\n    }\n    insert(node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    delete(node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    resolveNode(node, cachedVersionId) {\n        const initialNode = node;\n        let delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        const nodeStart = initialNode.start + delta;\n        const nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    }\n    _normalizeDeltaIfNecessary() {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    let node = T.root;\n    let delta = 0;\n    while (node !== SENTINEL) {\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {\n        return false;\n    }\n    if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    const nodeStickiness = getNodeStickiness(node);\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const deletingCnt = (end - start);\n    const insertingCnt = textLength;\n    const commonLength = Math.min(deletingCnt, insertingCnt);\n    const nodeStart = node.start;\n    let startDone = false;\n    const nodeEnd = node.end;\n    let endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : (deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    const deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = (textLength - (end - start));\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    let node = T.root;\n    let delta = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        let include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === SENTINEL) {\n        newNode.parent = SENTINEL;\n        newNode.left = SENTINEL;\n        newNode.right = SENTINEL;\n        setNodeColor(newNode, 0 /* NodeColor.Black */);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, 0 /* NodeColor.Black */);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let delta = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    setNodeColor(z, 1 /* NodeColor.Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, 0 /* NodeColor.Black */);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (getNodeColor(y) === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.left, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.right, 0 /* NodeColor.Black */);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.right, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.left, 0 /* NodeColor.Black */);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, 0 /* NodeColor.Black */);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n    SENTINEL.delta = 0; // optional\n    SENTINEL.start = 0; // optional\n    SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class TreeNode {\n    constructor(piece, color) {\n        this.piece = piece;\n        this.color = color;\n        this.size_left = 0;\n        this.lf_left = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n    }\n    next() {\n        if (this.right !== SENTINEL) {\n            return leftest(this.right);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.left === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    prev() {\n        if (this.left !== SENTINEL) {\n            return righttest(this.left);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.right === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new TreeNode(null, 0 /* NodeColor.Black */);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = 0 /* NodeColor.Black */;\nexport function leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nexport function righttest(node) {\n    while (node.right !== SENTINEL) {\n        node = node.right;\n    }\n    return node;\n}\nfunction calculateSize(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.size_left + node.piece.length + calculateSize(node.right);\n}\nfunction calculateLF(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n}\nexport function leftRotate(tree, x) {\n    const y = x.right;\n    // fix size_left\n    y.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    x.right = y.left;\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent;\n    if (x.parent === SENTINEL) {\n        tree.root = y;\n    }\n    else if (x.parent.left === x) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n}\nexport function rightRotate(tree, y) {\n    const x = y.left;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    // fix size_left\n    y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    if (y.parent === SENTINEL) {\n        tree.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n}\nexport function rbDelete(tree, z) {\n    let x;\n    let y;\n    if (z.left === SENTINEL) {\n        y = z;\n        x = y.right;\n    }\n    else if (z.right === SENTINEL) {\n        y = z;\n        x = y.left;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n    }\n    if (y === tree.root) {\n        tree.root = x;\n        // if x is null, we are removing the only node\n        x.color = 0 /* NodeColor.Black */;\n        z.detach();\n        resetSentinel();\n        tree.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (y.color === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n        recomputeTreeMetadata(tree, x);\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        // as we make changes to x's hierarchy, update size_left of subtree first\n        recomputeTreeMetadata(tree, x);\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        y.color = z.color;\n        if (z === tree.root) {\n            tree.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n        // update metadata\n        // we replace z with y, so in this sub tree, the length change is z.item.length\n        y.size_left = z.size_left;\n        y.lf_left = z.lf_left;\n        recomputeTreeMetadata(tree, y);\n    }\n    z.detach();\n    if (x.parent.left === x) {\n        const newSizeLeft = calculateSize(x);\n        const newLFLeft = calculateLF(x);\n        if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n            const delta = newSizeLeft - x.parent.size_left;\n            const lf_delta = newLFLeft - x.parent.lf_left;\n            x.parent.size_left = newSizeLeft;\n            x.parent.lf_left = newLFLeft;\n            updateTreeMetadata(tree, x.parent, delta, lf_delta);\n        }\n    }\n    recomputeTreeMetadata(tree, x.parent);\n    if (yWasRed) {\n        resetSentinel();\n        return;\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== tree.root && x.color === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent);\n                w = x.parent.right;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.right.color === 0 /* NodeColor.Black */) {\n                    w.left.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    rightRotate(tree, w);\n                    w = x.parent.right;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.right.color = 0 /* NodeColor.Black */;\n                leftRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent);\n                w = x.parent.left;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.left.color === 0 /* NodeColor.Black */) {\n                    w.right.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    leftRotate(tree, w);\n                    w = x.parent.left;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.left.color = 0 /* NodeColor.Black */;\n                rightRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n    }\n    x.color = 0 /* NodeColor.Black */;\n    resetSentinel();\n}\nexport function fixInsert(tree, x) {\n    recomputeTreeMetadata(tree, x);\n    while (x !== tree.root && x.parent.color === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent.parent);\n            }\n        }\n    }\n    tree.root.color = 0 /* NodeColor.Black */;\n}\nexport function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {\n    // node length change or line feed count change\n    while (x !== tree.root && x !== SENTINEL) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lineFeedCntDelta;\n        }\n        x = x.parent;\n    }\n}\nexport function recomputeTreeMetadata(tree, x) {\n    let delta = 0;\n    let lf_delta = 0;\n    if (x === tree.root) {\n        return;\n    }\n    // go upwards till the node whose left subtree is changed.\n    while (x !== tree.root && x === x.parent.right) {\n        x = x.parent;\n    }\n    if (x === tree.root) {\n        // well, it means we add a node to the end (inorder)\n        return;\n    }\n    // x is the node whose right subtree is changed.\n    x = x.parent;\n    delta = calculateSize(x.left) - x.size_left;\n    lf_delta = calculateLF(x.left) - x.lf_left;\n    x.size_left += delta;\n    x.lf_left += lf_delta;\n    // go upwards till root. O(logN)\n    while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lf_delta;\n        }\n        x = x.parent;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nconst AverageBufferSize = 65535;\nfunction createUintArray(arr) {\n    let r;\n    if (arr[arr.length - 1] < 65536) {\n        r = new Uint16Array(arr.length);\n    }\n    else {\n        r = new Uint32Array(arr.length);\n    }\n    r.set(arr, 0);\n    return r;\n}\nclass LineStarts {\n    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\n        this.lineStarts = lineStarts;\n        this.cr = cr;\n        this.lf = lf;\n        this.crlf = crlf;\n        this.isBasicASCII = isBasicASCII;\n    }\n}\nexport function createLineStartsFast(str, readonly = true) {\n    const r = [0];\n    let rLength = 1;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            r[rLength++] = i + 1;\n        }\n    }\n    if (readonly) {\n        return createUintArray(r);\n    }\n    else {\n        return r;\n    }\n}\nexport function createLineStarts(r, str) {\n    r.length = 0;\n    r[0] = 0;\n    let rLength = 1;\n    let cr = 0, lf = 0, crlf = 0;\n    let isBasicASCII = true;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                crlf++;\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                cr++;\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            lf++;\n            r[rLength++] = i + 1;\n        }\n        else {\n            if (isBasicASCII) {\n                if (chr !== 9 /* CharCode.Tab */ && (chr < 32 || chr > 126)) {\n                    isBasicASCII = false;\n                }\n            }\n        }\n    }\n    const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n    r.length = 0;\n    return result;\n}\nexport class Piece {\n    constructor(bufferIndex, start, end, lineFeedCnt, length) {\n        this.bufferIndex = bufferIndex;\n        this.start = start;\n        this.end = end;\n        this.lineFeedCnt = lineFeedCnt;\n        this.length = length;\n    }\n}\nexport class StringBuffer {\n    constructor(buffer, lineStarts) {\n        this.buffer = buffer;\n        this.lineStarts = lineStarts;\n    }\n}\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot {\n    constructor(tree, BOM) {\n        this._pieces = [];\n        this._tree = tree;\n        this._BOM = BOM;\n        this._index = 0;\n        if (tree.root !== SENTINEL) {\n            tree.iterate(tree.root, node => {\n                if (node !== SENTINEL) {\n                    this._pieces.push(node.piece);\n                }\n                return true;\n            });\n        }\n    }\n    read() {\n        if (this._pieces.length === 0) {\n            if (this._index === 0) {\n                this._index++;\n                return this._BOM;\n            }\n            else {\n                return null;\n            }\n        }\n        if (this._index > this._pieces.length - 1) {\n            return null;\n        }\n        if (this._index === 0) {\n            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n        }\n        return this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n}\nclass PieceTreeSearchCache {\n    constructor(limit) {\n        this._limit = limit;\n        this._cache = [];\n    }\n    get(offset) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    get2(lineNumber) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    set(nodePosition) {\n        if (this._cache.length >= this._limit) {\n            this._cache.shift();\n        }\n        this._cache.push(nodePosition);\n    }\n    validate(offset) {\n        let hasInvalidVal = false;\n        const tmp = this._cache;\n        for (let i = 0; i < tmp.length; i++) {\n            const nodePos = tmp[i];\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n                tmp[i] = null;\n                hasInvalidVal = true;\n                continue;\n            }\n        }\n        if (hasInvalidVal) {\n            const newArr = [];\n            for (const entry of tmp) {\n                if (entry !== null) {\n                    newArr.push(entry);\n                }\n            }\n            this._cache = newArr;\n        }\n    }\n}\nexport class PieceTreeBase {\n    constructor(chunks, eol, eolNormalized) {\n        this.create(chunks, eol, eolNormalized);\n    }\n    create(chunks, eol, eolNormalized) {\n        this._buffers = [\n            new StringBuffer('', [0])\n        ];\n        this._lastChangeBufferPos = { line: 0, column: 0 };\n        this.root = SENTINEL;\n        this._lineCnt = 1;\n        this._length = 0;\n        this._EOL = eol;\n        this._EOLLength = eol.length;\n        this._EOLNormalized = eolNormalized;\n        let lastNode = null;\n        for (let i = 0, len = chunks.length; i < len; i++) {\n            if (chunks[i].buffer.length > 0) {\n                if (!chunks[i].lineStarts) {\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n                }\n                const piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n                this._buffers.push(chunks[i]);\n                lastNode = this.rbInsertRight(lastNode, piece);\n            }\n        }\n        this._searchCache = new PieceTreeSearchCache(1);\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\n        this.computeBufferMetadata();\n    }\n    normalizeEOL(eol) {\n        const averageBufferSize = AverageBufferSize;\n        const min = averageBufferSize - Math.floor(averageBufferSize / 3);\n        const max = min * 2;\n        let tempChunk = '';\n        let tempChunkLen = 0;\n        const chunks = [];\n        this.iterate(this.root, node => {\n            const str = this.getNodeContent(node);\n            const len = str.length;\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\n                tempChunk += str;\n                tempChunkLen += len;\n                return true;\n            }\n            // flush anyways\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n            tempChunk = str;\n            tempChunkLen = len;\n            return true;\n        });\n        if (tempChunkLen > 0) {\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n        }\n        this.create(chunks, eol, true);\n    }\n    // #region Buffer API\n    getEOL() {\n        return this._EOL;\n    }\n    setEOL(newEOL) {\n        this._EOL = newEOL;\n        this._EOLLength = this._EOL.length;\n        this.normalizeEOL(newEOL);\n    }\n    createSnapshot(BOM) {\n        return new PieceTreeSnapshot(this, BOM);\n    }\n    getOffsetAt(lineNumber, column) {\n        let leftLen = 0; // inorder\n        let x = this.root;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n                leftLen += x.size_left;\n                // lineNumber >= 2\n                const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                leftLen += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return leftLen;\n    }\n    getPositionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        let x = this.root;\n        let lfCnt = 0;\n        const originalOffset = offset;\n        while (x !== SENTINEL) {\n            if (x.size_left !== 0 && x.size_left >= offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                const out = this.getIndexOf(x, offset - x.size_left);\n                lfCnt += x.lf_left + out.index;\n                if (out.index === 0) {\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                return new Position(lfCnt + 1, out.remainder + 1);\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                if (x.right === SENTINEL) {\n                    // last node\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - offset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                else {\n                    x = x.right;\n                }\n            }\n        }\n        return new Position(1, 1);\n    }\n    getValueInRange(range, eol) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            return '';\n        }\n        const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n        const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n        const value = this.getValueInRange2(startPosition, endPosition);\n        if (eol) {\n            if (eol !== this._EOL || !this._EOLNormalized) {\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\n            }\n            if (eol === this.getEOL() && this._EOLNormalized) {\n                if (eol === '\\r\\n') {\n                }\n                return value;\n            }\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n        return value;\n    }\n    getValueInRange2(startPosition, endPosition) {\n        if (startPosition.node === endPosition.node) {\n            const node = startPosition.node;\n            const buffer = this._buffers[node.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n            return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n        }\n        let x = startPosition.node;\n        const buffer = this._buffers[x.piece.bufferIndex].buffer;\n        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (x === endPosition.node) {\n                ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n                break;\n            }\n            else {\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    getLinesContent() {\n        const lines = [];\n        let linesLength = 0;\n        let currentLine = '';\n        let danglingCR = false;\n        this.iterate(this.root, node => {\n            if (node === SENTINEL) {\n                return true;\n            }\n            const piece = node.piece;\n            let pieceLength = piece.length;\n            if (pieceLength === 0) {\n                return true;\n            }\n            const buffer = this._buffers[piece.bufferIndex].buffer;\n            const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n            const pieceStartLine = piece.start.line;\n            const pieceEndLine = piece.end.line;\n            let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n            if (danglingCR) {\n                if (buffer.charCodeAt(pieceStartOffset) === 10 /* CharCode.LineFeed */) {\n                    // pretend the \\n was in the previous piece..\n                    pieceStartOffset++;\n                    pieceLength--;\n                }\n                lines[linesLength++] = currentLine;\n                currentLine = '';\n                danglingCR = false;\n                if (pieceLength === 0) {\n                    return true;\n                }\n            }\n            if (pieceStartLine === pieceEndLine) {\n                // this piece has no new lines\n                if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CharCode.CarriageReturn */) {\n                    danglingCR = true;\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n                }\n                else {\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\n                }\n                return true;\n            }\n            // add the text before the first line start in this piece\n            currentLine += (this._EOLNormalized\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n            lines[linesLength++] = currentLine;\n            for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n                currentLine = (this._EOLNormalized\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n                lines[linesLength++] = currentLine;\n            }\n            if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CharCode.CarriageReturn */) {\n                danglingCR = true;\n                if (piece.end.column === 0) {\n                    // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n                    linesLength--;\n                }\n                else {\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n                }\n            }\n            else {\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n            }\n            return true;\n        });\n        if (danglingCR) {\n            lines[linesLength++] = currentLine;\n            currentLine = '';\n        }\n        lines[linesLength++] = currentLine;\n        return lines;\n    }\n    getLength() {\n        return this._length;\n    }\n    getLineCount() {\n        return this._lineCnt;\n    }\n    getLineContent(lineNumber) {\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\n            return this._lastVisitedLine.value;\n        }\n        this._lastVisitedLine.lineNumber = lineNumber;\n        if (lineNumber === this._lineCnt) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n        }\n        else if (this._EOLNormalized) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n        }\n        else {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n        }\n        return this._lastVisitedLine.value;\n    }\n    _getCharCode(nodePos) {\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            // the char we want to fetch is at the head of next node.\n            const matchingNode = nodePos.node.next();\n            if (!matchingNode) {\n                return 0;\n            }\n            const buffer = this._buffers[matchingNode.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.charCodeAt(startOffset);\n        }\n        else {\n            const buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            const targetOffset = startOffset + nodePos.remainder;\n            return buffer.buffer.charCodeAt(targetOffset);\n        }\n    }\n    getLineCharCode(lineNumber, index) {\n        const nodePos = this.nodeAt2(lineNumber, index + 1);\n        return this._getCharCode(nodePos);\n    }\n    getLineLength(lineNumber) {\n        if (lineNumber === this.getLineCount()) {\n            const startOffset = this.getOffsetAt(lineNumber, 1);\n            return this.getLength() - startOffset;\n        }\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    }\n    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n        const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n        const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n        let m;\n        // Reset regex to search from the beginning\n        const ret = { line: 0, column: 0 };\n        let searchText;\n        let offsetInBuffer;\n        if (searcher._wordSeparators) {\n            searchText = buffer.buffer.substring(start, end);\n            offsetInBuffer = (offset) => offset + start;\n            searcher.reset(0);\n        }\n        else {\n            searchText = buffer.buffer;\n            offsetInBuffer = (offset) => offset;\n            searcher.reset(start);\n        }\n        do {\n            m = searcher.next(searchText);\n            if (m) {\n                if (offsetInBuffer(m.index) >= end) {\n                    return resultLen;\n                }\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n                const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n                const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n                const retEndColumn = retStartColumn + m[0].length;\n                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\n                    return resultLen;\n                }\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n        if (startPosition === null) {\n            return [];\n        }\n        const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n        if (endPosition === null) {\n            return [];\n        }\n        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        const end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n        if (startPosition.node === endPosition.node) {\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n            return result;\n        }\n        let startLineNumber = searchRange.startLineNumber;\n        let currentNode = startPosition.node;\n        while (currentNode !== endPosition.node) {\n            const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n            if (lineBreakCnt >= 1) {\n                // last line break position\n                const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n                const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n                const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n                const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n                if (resultLen >= limitResultCount) {\n                    return result;\n                }\n                startLineNumber += lineBreakCnt;\n            }\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            // search for the remaining content\n            if (startLineNumber === searchRange.endLineNumber) {\n                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                return result;\n            }\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            if (resultLen >= limitResultCount) {\n                return result;\n            }\n            startLineNumber++;\n            startPosition = this.nodeAt2(startLineNumber, 1);\n            currentNode = startPosition.node;\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        }\n        if (startLineNumber === searchRange.endLineNumber) {\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n    }\n    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    // #endregion\n    // #region Piece Table\n    insert(offset, value, eolNormalized = false) {\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (this.root !== SENTINEL) {\n            const { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n            const piece = node.piece;\n            const bufferIndex = piece.bufferIndex;\n            const insertPosInBuffer = this.positionInBuffer(node, remainder);\n            if (node.piece.bufferIndex === 0 &&\n                piece.end.line === this._lastChangeBufferPos.line &&\n                piece.end.column === this._lastChangeBufferPos.column &&\n                (nodeStartOffset + piece.length === offset) &&\n                value.length < AverageBufferSize) {\n                // changed buffer\n                this.appendToNode(node, value);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (nodeStartOffset === offset) {\n                this.insertContentToNodeLeft(value, node);\n                this._searchCache.validate(offset);\n            }\n            else if (nodeStartOffset + node.piece.length > offset) {\n                // we are inserting into the middle of a node.\n                const nodesToDel = [];\n                let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                    const headOfRight = this.nodeCharCodeAt(node, remainder);\n                    if (headOfRight === 10 /** \\n */) {\n                        const newStart = { line: newRightPiece.start.line + 1, column: 0 };\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n                        value += '\\n';\n                    }\n                }\n                // reuse node for content before insertion point.\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n                    const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n                    if (tailOfLeft === 13 /** \\r */) {\n                        const previousPos = this.positionInBuffer(node, remainder - 1);\n                        this.deleteNodeTail(node, previousPos);\n                        value = '\\r' + value;\n                        if (node.piece.length === 0) {\n                            nodesToDel.push(node);\n                        }\n                    }\n                    else {\n                        this.deleteNodeTail(node, insertPosInBuffer);\n                    }\n                }\n                else {\n                    this.deleteNodeTail(node, insertPosInBuffer);\n                }\n                const newPieces = this.createNewPieces(value);\n                if (newRightPiece.length > 0) {\n                    this.rbInsertRight(node, newRightPiece);\n                }\n                let tmpNode = node;\n                for (let k = 0; k < newPieces.length; k++) {\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n                }\n                this.deleteNodes(nodesToDel);\n            }\n            else {\n                this.insertContentToNodeRight(value, node);\n            }\n        }\n        else {\n            // insert new node\n            const pieces = this.createNewPieces(value);\n            let node = this.rbInsertLeft(null, pieces[0]);\n            for (let k = 1; k < pieces.length; k++) {\n                node = this.rbInsertRight(node, pieces[k]);\n            }\n        }\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n        this.computeBufferMetadata();\n    }\n    delete(offset, cnt) {\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (cnt <= 0 || this.root === SENTINEL) {\n            return;\n        }\n        const startPosition = this.nodeAt(offset);\n        const endPosition = this.nodeAt(offset + cnt);\n        const startNode = startPosition.node;\n        const endNode = endPosition.node;\n        if (startNode === endNode) {\n            const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n            const endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n            if (startPosition.nodeStartOffset === offset) {\n                if (cnt === startNode.piece.length) { // delete node\n                    const next = startNode.next();\n                    rbDelete(this, startNode);\n                    this.validateCRLFWithPrevNode(next);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                this.deleteNodeHead(startNode, endSplitPosInBuffer);\n                this._searchCache.validate(offset);\n                this.validateCRLFWithPrevNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n                this.deleteNodeTail(startNode, startSplitPosInBuffer);\n                this.validateCRLFWithNextNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            // delete content in the middle, this node will be splitted to nodes\n            this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n            this.computeBufferMetadata();\n            return;\n        }\n        const nodesToDel = [];\n        const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\n        this._searchCache.validate(offset);\n        if (startNode.piece.length === 0) {\n            nodesToDel.push(startNode);\n        }\n        // update last touched node\n        const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\n        if (endNode.piece.length === 0) {\n            nodesToDel.push(endNode);\n        }\n        // delete nodes in between\n        const secondNode = startNode.next();\n        for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n            nodesToDel.push(node);\n        }\n        const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n        this.deleteNodes(nodesToDel);\n        this.validateCRLFWithNextNode(prev);\n        this.computeBufferMetadata();\n    }\n    insertContentToNodeLeft(value, node) {\n        // we are inserting content to the beginning of node\n        const nodesToDel = [];\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n            // move `\\n` to new node.\n            const piece = node.piece;\n            const newStart = { line: piece.start.line + 1, column: 0 };\n            const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n            node.piece = nPiece;\n            value += '\\n';\n            updateTreeMetadata(this, node, -1, -1);\n            if (node.piece.length === 0) {\n                nodesToDel.push(node);\n            }\n        }\n        const newPieces = this.createNewPieces(value);\n        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n        for (let k = newPieces.length - 2; k >= 0; k--) {\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n        this.deleteNodes(nodesToDel);\n    }\n    insertContentToNodeRight(value, node) {\n        // we are inserting to the right of this node.\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            // move \\n to the new node.\n            value += '\\n';\n        }\n        const newPieces = this.createNewPieces(value);\n        const newNode = this.rbInsertRight(node, newPieces[0]);\n        let tmpNode = newNode;\n        for (let k = 1; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    positionInBuffer(node, remainder, ret) {\n        const piece = node.piece;\n        const bufferIndex = node.piece.bufferIndex;\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        const startOffset = lineStarts[piece.start.line] + piece.start.column;\n        const offset = startOffset + remainder;\n        // binary search offset between startOffset and endOffset\n        let low = piece.start.line;\n        let high = piece.end.line;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStart = lineStarts[mid];\n            if (mid === high) {\n                break;\n            }\n            midStop = lineStarts[mid + 1];\n            if (offset < midStart) {\n                high = mid - 1;\n            }\n            else if (offset >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        if (ret) {\n            ret.line = mid;\n            ret.column = offset - midStart;\n            return null;\n        }\n        return {\n            line: mid,\n            column: offset - midStart\n        };\n    }\n    getLineFeedCnt(bufferIndex, start, end) {\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n        if (end.column === 0) {\n            return end.line - start.line;\n        }\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n            return end.line - start.line;\n        }\n        const nextLineStartOffset = lineStarts[end.line + 1];\n        const endOffset = lineStarts[end.line] + end.column;\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n            return end.line - start.line;\n        }\n        // endOffset + 1 === nextLineStartOffset\n        // character at endOffset is \\n, so we check the character before first\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\n        const previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n        const buffer = this._buffers[bufferIndex].buffer;\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\n            return end.line - start.line + 1;\n        }\n        else {\n            return end.line - start.line;\n        }\n    }\n    offsetInBuffer(bufferIndex, cursor) {\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        return lineStarts[cursor.line] + cursor.column;\n    }\n    deleteNodes(nodes) {\n        for (let i = 0; i < nodes.length; i++) {\n            rbDelete(this, nodes[i]);\n        }\n    }\n    createNewPieces(text) {\n        if (text.length > AverageBufferSize) {\n            // the content is large, operations like substring, charCode becomes slow\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n            const newPieces = [];\n            while (text.length > AverageBufferSize) {\n                const lastChar = text.charCodeAt(AverageBufferSize - 1);\n                let splitText;\n                if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                    // last character is \\r or a high surrogate => keep it back\n                    splitText = text.substring(0, AverageBufferSize - 1);\n                    text = text.substring(AverageBufferSize - 1);\n                }\n                else {\n                    splitText = text.substring(0, AverageBufferSize);\n                    text = text.substring(AverageBufferSize);\n                }\n                const lineStarts = createLineStartsFast(splitText);\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));\n                this._buffers.push(new StringBuffer(splitText, lineStarts));\n            }\n            const lineStarts = createLineStartsFast(text);\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));\n            this._buffers.push(new StringBuffer(text, lineStarts));\n            return newPieces;\n        }\n        let startOffset = this._buffers[0].buffer.length;\n        const lineStarts = createLineStartsFast(text, false);\n        let start = this._lastChangeBufferPos;\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n            && startOffset !== 0\n            && this.startWithLF(text)\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n        ) {\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n            start = this._lastChangeBufferPos;\n            for (let i = 0; i < lineStarts.length; i++) {\n                lineStarts[i] += startOffset + 1;\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += '_' + text;\n            startOffset += 1;\n        }\n        else {\n            if (startOffset !== 0) {\n                for (let i = 0; i < lineStarts.length; i++) {\n                    lineStarts[i] += startOffset;\n                }\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += text;\n        }\n        const endOffset = this._buffers[0].buffer.length;\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n        const endPos = { line: endIndex, column: endColumn };\n        const newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n        this._lastChangeBufferPos = endPos;\n        return [newPiece];\n    }\n    getLineRawContent(lineNumber, endOffset = 0) {\n        let x = this.root;\n        let ret = '';\n        const cache = this._searchCache.get2(lineNumber);\n        if (cache) {\n            x = cache.node;\n            const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n                ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n            }\n            else {\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n                return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n            }\n        }\n        else {\n            let nodeStartOffset = 0;\n            const originalLineNumber = lineNumber;\n            while (x !== SENTINEL) {\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    nodeStartOffset += x.size_left;\n                    this._searchCache.set({\n                        node: x,\n                        nodeStartOffset,\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n                    });\n                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n                    break;\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n        }\n        // search in order, to find the node contains end column\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n                return ret;\n            }\n            else {\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    computeBufferMetadata() {\n        let x = this.root;\n        let lfCnt = 1;\n        let len = 0;\n        while (x !== SENTINEL) {\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\n            len += x.size_left + x.piece.length;\n            x = x.right;\n        }\n        this._lineCnt = lfCnt;\n        this._length = len;\n        this._searchCache.validate(this._length);\n    }\n    // #region node operations\n    getIndexOf(node, accumulatedValue) {\n        const piece = node.piece;\n        const pos = this.positionInBuffer(node, accumulatedValue);\n        const lineCnt = pos.line - piece.start.line;\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n            // we are checking the end of this node, so a CRLF check is necessary.\n            const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n            if (realLineCnt !== lineCnt) {\n                // aha yes, CRLF\n                return { index: realLineCnt, remainder: 0 };\n            }\n        }\n        return { index: lineCnt, remainder: pos.column };\n    }\n    getAccumulatedValue(node, index) {\n        if (index < 0) {\n            return 0;\n        }\n        const piece = node.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const expectedLineStartIndex = piece.start.line + index + 1;\n        if (expectedLineStartIndex > piece.end.line) {\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n        }\n        else {\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n        }\n    }\n    deleteNodeTail(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const newEnd = pos;\n        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = newEndOffset - originalEndOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    deleteNodeHead(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const newStart = pos;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = originalStartOffset - newStartOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    shrinkNode(node, start, end) {\n        const piece = node.piece;\n        const originalStartPos = piece.start;\n        const originalEndPos = piece.end;\n        // old piece, originalStartPos, start\n        const oldLength = piece.length;\n        const oldLFCnt = piece.lineFeedCnt;\n        const newEnd = start;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n        // new right piece, end, originalEndPos\n        const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n        const newNode = this.rbInsertRight(node, newPiece);\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    appendToNode(node, value) {\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            value += '\\n';\n        }\n        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n        const startOffset = this._buffers[0].buffer.length;\n        this._buffers[0].buffer += value;\n        const lineStarts = createLineStartsFast(value, false);\n        for (let i = 0; i < lineStarts.length; i++) {\n            lineStarts[i] += startOffset;\n        }\n        if (hitCRLF) {\n            const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n            this._buffers[0].lineStarts.pop();\n            // _lastChangeBufferPos is already wrong\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n        const newEnd = { line: endIndex, column: endColumn };\n        const newLength = node.piece.length + value.length;\n        const oldLineFeedCnt = node.piece.lineFeedCnt;\n        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - oldLineFeedCnt;\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n        this._lastChangeBufferPos = newEnd;\n        updateTreeMetadata(this, node, value.length, lf_delta);\n    }\n    nodeAt(offset) {\n        let x = this.root;\n        const cache = this._searchCache.get(offset);\n        if (cache) {\n            return {\n                node: cache.node,\n                nodeStartOffset: cache.nodeStartOffset,\n                remainder: offset - cache.nodeStartOffset\n            };\n        }\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.size_left > offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                nodeStartOffset += x.size_left;\n                const ret = {\n                    node: x,\n                    remainder: offset - x.size_left,\n                    nodeStartOffset\n                };\n                this._searchCache.set(ret);\n                return ret;\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return null;\n    }\n    nodeAt2(lineNumber, column) {\n        let x = this.root;\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                nodeStartOffset += x.size_left;\n                return {\n                    node: x,\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n                    return {\n                        node: x,\n                        remainder: prevAccumualtedValue + column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length - prevAccumualtedValue;\n                    break;\n                }\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        // search in order, to find the node contains position.column\n        x = x.next();\n        while (x !== SENTINEL) {\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const nodeStartOffset = this.offsetOfNode(x);\n                return {\n                    node: x,\n                    remainder: Math.min(column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else {\n                if (x.piece.length >= column - 1) {\n                    const nodeStartOffset = this.offsetOfNode(x);\n                    return {\n                        node: x,\n                        remainder: column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length;\n                }\n            }\n            x = x.next();\n        }\n        return null;\n    }\n    nodeCharCodeAt(node, offset) {\n        if (node.piece.lineFeedCnt < 1) {\n            return -1;\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n        return buffer.buffer.charCodeAt(newOffset);\n    }\n    offsetOfNode(node) {\n        if (!node) {\n            return 0;\n        }\n        let pos = node.size_left;\n        while (node !== this.root) {\n            if (node.parent.right === node) {\n                pos += node.parent.size_left + node.parent.piece.length;\n            }\n            node = node.parent;\n        }\n        return pos;\n    }\n    // #endregion\n    // #region CRLF\n    shouldCheckCRLF() {\n        return !(this._EOLNormalized && this._EOL === '\\n');\n    }\n    startWithLF(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(0) === 10;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        const piece = val.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const line = piece.start.line;\n        const startOffset = lineStarts[line] + piece.start.column;\n        if (line === lineStarts.length - 1) {\n            // last line, so there is no line feed at the end of this line\n            return false;\n        }\n        const nextLineOffset = lineStarts[line + 1];\n        if (nextLineOffset > startOffset + 1) {\n            return false;\n        }\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    }\n    endWithCR(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(val.length - 1) === 13;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    }\n    validateCRLFWithPrevNode(nextNode) {\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n            const node = nextNode.prev();\n            if (this.endWithCR(node)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    validateCRLFWithNextNode(node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    fixCRLF(prev, next) {\n        const nodesToDel = [];\n        // update node\n        const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n        let newEnd;\n        if (prev.piece.end.column === 0) {\n            // it means, last line ends with \\r, not \\r\\n\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n        }\n        else {\n            // \\r\\n\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n        }\n        const prevNewLength = prev.piece.length - 1;\n        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n        updateTreeMetadata(this, prev, -1, -1);\n        if (prev.piece.length === 0) {\n            nodesToDel.push(prev);\n        }\n        // update nextNode\n        const newStart = { line: next.piece.start.line + 1, column: 0 };\n        const newLength = next.piece.length - 1;\n        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, next, -1, -1);\n        if (next.piece.length === 0) {\n            nodesToDel.push(next);\n        }\n        // create new piece which contains \\r\\n\n        const pieces = this.createNewPieces('\\r\\n');\n        this.rbInsertRight(prev, pieces[0]);\n        // delete empty nodes\n        for (let i = 0; i < nodesToDel.length; i++) {\n            rbDelete(this, nodesToDel[i]);\n        }\n    }\n    adjustCarriageReturnFromNext(value, node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                // move `\\n` forward\n                value += '\\n';\n                if (nextNode.piece.length === 1) {\n                    rbDelete(this, nextNode);\n                }\n                else {\n                    const piece = nextNode.piece;\n                    const newStart = { line: piece.start.line + 1, column: 0 };\n                    const newLength = piece.length - 1;\n                    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n                    updateTreeMetadata(this, nextNode, -1, -1);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    // #endregion\n    // #endregion\n    // #region Tree operations\n    iterate(node, callback) {\n        if (node === SENTINEL) {\n            return callback(SENTINEL);\n        }\n        const leftRet = this.iterate(node.left, callback);\n        if (!leftRet) {\n            return leftRet;\n        }\n        return callback(node) && this.iterate(node.right, callback);\n    }\n    getNodeContent(node) {\n        if (node === SENTINEL) {\n            return '';\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const piece = node.piece;\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    getPieceContent(piece) {\n        const buffer = this._buffers[piece.bufferIndex];\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b    <----   a    b\n     *                         /\n     *                        z\n     */\n    rbInsertRight(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        const x = this.root;\n        if (x === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.right === SENTINEL) {\n            node.right = z;\n            z.parent = node;\n        }\n        else {\n            const nextNode = leftest(node.right);\n            nextNode.left = z;\n            z.parent = nextNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b     ---->   a    b\n     *                       \\\n     *                        z\n     */\n    rbInsertLeft(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        if (this.root === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.left === SENTINEL) {\n            node.left = z;\n            z.parent = node;\n        }\n        else {\n            const prevNode = righttest(node.left); // a\n            prevNode.right = z;\n            z.parent = prevNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n        super();\n        this._onDidChangeContent = this._register(new Emitter());\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    }\n    mightContainRTL() {\n        return this._mightContainRTL;\n    }\n    mightContainUnusualLineTerminators() {\n        return this._mightContainUnusualLineTerminators;\n    }\n    resetMightContainUnusualLineTerminators() {\n        this._mightContainUnusualLineTerminators = false;\n    }\n    mightContainNonBasicASCII() {\n        return this._mightContainNonBasicASCII;\n    }\n    getBOM() {\n        return this._BOM;\n    }\n    getEOL() {\n        return this._pieceTree.getEOL();\n    }\n    createSnapshot(preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n    getOffsetAt(lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n    getPositionAt(offset) {\n        return this._pieceTree.getPositionAt(offset);\n    }\n    getRangeAt(start, length) {\n        const end = start + length;\n        const startPosition = this.getPositionAt(start);\n        const endPosition = this.getPositionAt(end);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    getValueInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return '';\n        }\n        const lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n    getValueLengthInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        // offsets use the text EOL, so we need to compensate for length differences\n        // if the requested EOL doesn't match the text EOL\n        let eolOffsetCompensation = 0;\n        const desiredEOL = this._getEndOfLine(eol);\n        const actualEOL = this.getEOL();\n        if (desiredEOL.length !== actualEOL.length) {\n            const delta = desiredEOL.length - actualEOL.length;\n            const eolCount = range.endLineNumber - range.startLineNumber;\n            eolOffsetCompensation = delta * eolCount;\n        }\n        return endOffset - startOffset + eolOffsetCompensation;\n    }\n    getCharacterCountInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (this._mightContainNonBasicASCII) {\n            // we must count by iterating\n            let result = 0;\n            const fromLineNumber = range.startLineNumber;\n            const toLineNumber = range.endLineNumber;\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n                const lineContent = this.getLineContent(lineNumber);\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n                for (let offset = fromOffset; offset < toOffset; offset++) {\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n                        result = result + 1;\n                        offset = offset + 1;\n                    }\n                    else {\n                        result = result + 1;\n                    }\n                }\n            }\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n            return result;\n        }\n        return this.getValueLengthInRange(range, eol);\n    }\n    getLength() {\n        return this._pieceTree.getLength();\n    }\n    getLineCount() {\n        return this._pieceTree.getLineCount();\n    }\n    getLinesContent() {\n        return this._pieceTree.getLinesContent();\n    }\n    getLineContent(lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n    getLineLength(lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    _getEndOfLine(eol) {\n        switch (eol) {\n            case 1 /* EndOfLinePreference.LF */:\n                return '\\n';\n            case 2 /* EndOfLinePreference.CRLF */:\n                return '\\r\\n';\n            case 0 /* EndOfLinePreference.TextDefined */:\n                return this.getEOL();\n            default:\n                throw new Error('Unknown EOL preference');\n        }\n    }\n    setEOL(newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    }\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n        let mightContainRTL = this._mightContainRTL;\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        let canReduceOperations = true;\n        let operations = [];\n        for (let i = 0; i < rawOperations.length; i++) {\n            const op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            const validatedRange = op.range;\n            if (op.text) {\n                let textMightContainNonBasicASCII = true;\n                if (!mightContainNonBasicASCII) {\n                    textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\n                }\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains RTL\n                    mightContainRTL = strings.containsRTL(op.text);\n                }\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains unusual line terminators\n                    mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n                }\n            }\n            let validText = '';\n            let eolCount = 0;\n            let firstLineLength = 0;\n            let lastLineLength = 0;\n            if (op.text) {\n                let strEOL;\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n                const bufferEOL = this.getEOL();\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* StringEOL.CRLF */ : 1 /* StringEOL.LF */);\n                if (strEOL === 0 /* StringEOL.Unknown */ || strEOL === expectedStrEOL) {\n                    validText = op.text;\n                }\n                else {\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n                }\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                text: validText,\n                eolCount: eolCount,\n                firstLineLength: firstLineLength,\n                lastLineLength: lastLineLength,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        // Sort operations ascending\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        let hasTouchingRanges = false;\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\n            const rangeEnd = operations[i].range.getEndPosition();\n            const nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    throw new Error('Overlapping ranges are not allowed!');\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        // Delta encode operations\n        const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n        const newTrimAutoWhitespaceCandidates = [];\n        if (recordTrimAutoWhitespace) {\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n        }\n        let reverseOperations = null;\n        if (computeUndoEdits) {\n            let reverseRangeDeltaOffset = 0;\n            reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                const bufferText = this.getValueInRange(op.range);\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: bufferText,\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n                };\n            }\n            // Can only sort reverse operations when the order is not significant\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        const contentChanges = this._doApplyEdits(operations);\n        let trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            // sort line numbers auto whitespace removal candidates for next edit descending\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n            trimAutoWhitespaceLineNumbers = [];\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    // Do not have the same line number twice\n                    continue;\n                }\n                const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                const lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        this._onDidChangeContent.fire();\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n    _reduceOperations(operations) {\n        if (operations.length < 1000) {\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\n            return operations;\n        }\n        // At one point, due to how events are emitted and how each operation is handled,\n        // some operations can trigger a high amount of temporary string allocations,\n        // that will immediately get edited again.\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n        return [this._toSingleEditOperation(operations)];\n    }\n    _toSingleEditOperation(operations) {\n        let forceMoveMarkers = false;\n        const firstEditRange = operations[0].range;\n        const lastEditRange = operations[operations.length - 1].range;\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n        let lastEndLineNumber = firstEditRange.startLineNumber;\n        let lastEndColumn = firstEditRange.startColumn;\n        const result = [];\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const operation = operations[i];\n            const range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            // (1) -- Push old text\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n            // (2) -- Push new text\n            if (operation.text.length > 0) {\n                result.push(operation.text);\n            }\n            lastEndLineNumber = range.endLineNumber;\n            lastEndColumn = range.endColumn;\n        }\n        const text = result.join('');\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* EndOfLinePreference.TextDefined */),\n            text: text,\n            eolCount: eolCount,\n            firstLineLength: firstLineLength,\n            lastLineLength: lastLineLength,\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    }\n    _doApplyEdits(operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        const contentChanges = [];\n        // operations are from bottom to top\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i];\n            const startLineNumber = op.range.startLineNumber;\n            const startColumn = op.range.startColumn;\n            const endLineNumber = op.range.endLineNumber;\n            const endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n                // no-op\n                continue;\n            }\n            if (op.text) {\n                // replacement\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\n            }\n            else {\n                // deletion\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: op.text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n    static _getInverseEditRanges(operations) {\n        const result = [];\n        let prevOpEndLineNumber = 0;\n        let prevOpEndColumn = 0;\n        let prevOp = null;\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const op = operations[i];\n            let startLineNumber;\n            let startColumn;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            let resultRange;\n            if (op.text.length > 0) {\n                // the operation inserts something\n                const lineCount = op.eolCount + 1;\n                if (lineCount === 1) {\n                    // single line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n                }\n                else {\n                    // multi line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n                }\n            }\n            else {\n                // There is nothing to insert\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    }\n    static _sortOpsAscending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    }\n    static _sortOpsDescending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nclass PieceTreeTextBufferFactory {\n    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n        this._chunks = _chunks;\n        this._bom = _bom;\n        this._cr = _cr;\n        this._lf = _lf;\n        this._crlf = _crlf;\n        this._containsRTL = _containsRTL;\n        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n        this._isBasicASCII = _isBasicASCII;\n        this._normalizeEOL = _normalizeEOL;\n    }\n    _getEOL(defaultEOL) {\n        const totalEOLCount = this._cr + this._lf + this._crlf;\n        const totalCRCount = this._cr + this._crlf;\n        if (totalEOLCount === 0) {\n            // This is an empty file or a file with precisely one line\n            return (defaultEOL === 1 /* DefaultEndOfLine.LF */ ? '\\n' : '\\r\\n');\n        }\n        if (totalCRCount > totalEOLCount / 2) {\n            // More than half of the file contains \\r\\n ending lines\n            return '\\r\\n';\n        }\n        // At least one line more ends in \\n\n        return '\\n';\n    }\n    create(defaultEOL) {\n        const eol = this._getEOL(defaultEOL);\n        const chunks = this._chunks;\n        if (this._normalizeEOL &&\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\n            // Normalize pieces\n            for (let i = 0, len = chunks.length; i < len; i++) {\n                const str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n                const newLineStart = createLineStartsFast(str);\n                chunks[i] = new StringBuffer(str, newLineStart);\n            }\n        }\n        const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n        return { textBuffer: textBuffer, disposable: textBuffer };\n    }\n}\nexport class PieceTreeTextBufferBuilder {\n    constructor() {\n        this.chunks = [];\n        this.BOM = '';\n        this._hasPreviousChar = false;\n        this._previousChar = 0;\n        this._tmpLineStarts = [];\n        this.cr = 0;\n        this.lf = 0;\n        this.crlf = 0;\n        this.containsRTL = false;\n        this.containsUnusualLineTerminators = false;\n        this.isBasicASCII = true;\n    }\n    acceptChunk(chunk) {\n        if (chunk.length === 0) {\n            return;\n        }\n        if (this.chunks.length === 0) {\n            if (strings.startsWithUTF8BOM(chunk)) {\n                this.BOM = strings.UTF8_BOM_CHARACTER;\n                chunk = chunk.substr(1);\n            }\n        }\n        const lastChar = chunk.charCodeAt(chunk.length - 1);\n        if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n            // last character is \\r or a high surrogate => keep it back\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n            this._hasPreviousChar = true;\n            this._previousChar = lastChar;\n        }\n        else {\n            this._acceptChunk1(chunk, false);\n            this._hasPreviousChar = false;\n            this._previousChar = lastChar;\n        }\n    }\n    _acceptChunk1(chunk, allowEmptyStrings) {\n        if (!allowEmptyStrings && chunk.length === 0) {\n            // Nothing to do\n            return;\n        }\n        if (this._hasPreviousChar) {\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n        }\n        else {\n            this._acceptChunk2(chunk);\n        }\n    }\n    _acceptChunk2(chunk) {\n        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n        this.cr += lineStarts.cr;\n        this.lf += lineStarts.lf;\n        this.crlf += lineStarts.crlf;\n        if (!lineStarts.isBasicASCII) {\n            // this chunk contains non basic ASCII characters\n            this.isBasicASCII = false;\n            if (!this.containsRTL) {\n                this.containsRTL = strings.containsRTL(chunk);\n            }\n            if (!this.containsUnusualLineTerminators) {\n                this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n            }\n        }\n    }\n    finish(normalizeEOL = true) {\n        this._finish();\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n    }\n    _finish() {\n        if (this.chunks.length === 0) {\n            this._acceptChunk1('', true);\n        }\n        if (this._hasPreviousChar) {\n            this._hasPreviousChar = false;\n            // recreate last chunk\n            const lastChunk = this.chunks[this.chunks.length - 1];\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\n            const newLineStarts = createLineStartsFast(lastChunk.buffer);\n            lastChunk.lineStarts = newLineStarts;\n            if (this._previousChar === 13 /* CharCode.CarriageReturn */) {\n                this.cr++;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { arrayInsert } from '../../../base/common/arrays.js';\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nexport class FixedArray {\n    constructor(_default) {\n        this._default = _default;\n        this._store = [];\n    }\n    get(index) {\n        if (index < this._store.length) {\n            return this._store[index];\n        }\n        return this._default;\n    }\n    set(index, value) {\n        while (index >= this._store.length) {\n            this._store[this._store.length] = this._default;\n        }\n        this._store[index] = value;\n    }\n    replace(index, oldLength, newLength) {\n        if (index >= this._store.length) {\n            return;\n        }\n        if (oldLength === 0) {\n            this.insert(index, newLength);\n            return;\n        }\n        else if (newLength === 0) {\n            this.delete(index, oldLength);\n            return;\n        }\n        const before = this._store.slice(0, index);\n        const after = this._store.slice(index + oldLength);\n        const insertArr = arrayFill(newLength, this._default);\n        this._store = before.concat(insertArr, after);\n    }\n    delete(deleteIndex, deleteCount) {\n        if (deleteCount === 0 || deleteIndex >= this._store.length) {\n            return;\n        }\n        this._store.splice(deleteIndex, deleteCount);\n    }\n    insert(insertIndex, insertCount) {\n        if (insertCount === 0 || insertIndex >= this._store.length) {\n            return;\n        }\n        const arr = [];\n        for (let i = 0; i < insertCount; i++) {\n            arr[i] = this._default;\n        }\n        this._store = arrayInsert(this._store, insertIndex, arr);\n    }\n}\nfunction arrayFill(length, value) {\n    const arr = [];\n    for (let i = 0; i < length; i++) {\n        arr[i] = value;\n    }\n    return arr;\n}\n","/**\n * Represents contiguous tokens over a contiguous range of lines.\n */\nexport class ContiguousMultilineTokens {\n    /**\n     * (Inclusive) start line number for these tokens.\n     */\n    get startLineNumber() {\n        return this._startLineNumber;\n    }\n    /**\n     * (Inclusive) end line number for these tokens.\n     */\n    get endLineNumber() {\n        return this._startLineNumber + this._tokens.length - 1;\n    }\n    constructor(startLineNumber, tokens) {\n        this._startLineNumber = startLineNumber;\n        this._tokens = tokens;\n    }\n    /**\n     * @see {@link _tokens}\n     */\n    getLineTokens(lineNumber) {\n        return this._tokens[lineNumber - this._startLineNumber];\n    }\n    appendLineTokens(lineTokens) {\n        this._tokens.push(lineTokens);\n    }\n}\n","import { ContiguousMultilineTokens } from './contiguousMultilineTokens.js';\nexport class ContiguousMultilineTokensBuilder {\n    constructor() {\n        this._tokens = [];\n    }\n    add(lineNumber, lineTokens) {\n        if (this._tokens.length > 0) {\n            const last = this._tokens[this._tokens.length - 1];\n            if (last.endLineNumber + 1 === lineNumber) {\n                // append\n                last.appendLineTokens(lineTokens);\n                return;\n            }\n        }\n        this._tokens.push(new ContiguousMultilineTokens(lineNumber, [lineTokens]));\n    }\n    finalize() {\n        return this._tokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { runWhenGlobalIdle } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { setTimeout0 } from '../../../base/common/platform.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { OffsetRange } from '../core/offsetRange.js';\nimport { nullTokenizeEncoded } from '../languages/nullTokenize.js';\nimport { FixedArray } from './fixedArray.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nexport class TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport) {\n        this.tokenizationSupport = tokenizationSupport;\n        this.initialState = this.tokenizationSupport.getInitialState();\n        this.store = new TrackingTokenizationStateStore(lineCount);\n    }\n    getStartState(lineNumber) {\n        return this.store.getStartState(lineNumber, this.initialState);\n    }\n    getFirstInvalidLine() {\n        return this.store.getFirstInvalidLine(this.initialState);\n    }\n}\nexport class TokenizerWithStateStoreAndTextModel extends TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport, _textModel, _languageIdCodec) {\n        super(lineCount, tokenizationSupport);\n        this._textModel = _textModel;\n        this._languageIdCodec = _languageIdCodec;\n    }\n    updateTokensUntilLine(builder, lineNumber) {\n        const languageId = this._textModel.getLanguageId();\n        while (true) {\n            const lineToTokenize = this.getFirstInvalidLine();\n            if (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {\n                break;\n            }\n            const text = this._textModel.getLineContent(lineToTokenize.lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);\n            builder.add(lineToTokenize.lineNumber, r.tokens);\n            this.store.setEndState(lineToTokenize.lineNumber, r.endState);\n        }\n    }\n    /** assumes state is up to date */\n    getTokenTypeIfInsertingCharacter(position, character) {\n        // TODO@hediet: use tokenizeLineWithEdit\n        const lineStartState = this.getStartState(position.lineNumber);\n        if (!lineStartState) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const languageId = this._textModel.getLanguageId();\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        // Create the text as if `character` was inserted\n        const text = (lineContent.substring(0, position.column - 1)\n            + character\n            + lineContent.substring(position.column - 1));\n        const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);\n        const lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n        if (lineTokens.getCount() === 0) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        return lineTokens.getStandardTokenType(tokenIndex);\n    }\n    /** assumes state is up to date */\n    tokenizeLineWithEdit(position, length, newText) {\n        const lineNumber = position.lineNumber;\n        const column = position.column;\n        const lineStartState = this.getStartState(lineNumber);\n        if (!lineStartState) {\n            return null;\n        }\n        const curLineContent = this._textModel.getLineContent(lineNumber);\n        const newLineContent = curLineContent.substring(0, column - 1)\n            + newText + curLineContent.substring(column - 1 + length);\n        const languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);\n        const result = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, newLineContent, true, lineStartState);\n        const lineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);\n        return lineTokens;\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        return (lineNumber < firstInvalidLineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        if (lineNumber < firstInvalidLineNumber) {\n            return true;\n        }\n        if (lineNumber === firstInvalidLineNumber\n            && this._textModel.getLineLength(lineNumber) < 2048 /* Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT */) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * The result is not cached.\n     */\n    tokenizeHeuristically(builder, startLineNumber, endLineNumber) {\n        if (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // nothing to do\n            return { heuristicTokens: false };\n        }\n        if (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // tokenization has reached the viewport start...\n            this.updateTokensUntilLine(builder, endLineNumber);\n            return { heuristicTokens: false };\n        }\n        let state = this.guessStartState(startLineNumber);\n        const languageId = this._textModel.getLanguageId();\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const text = this._textModel.getLineContent(lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);\n            builder.add(lineNumber, r.tokens);\n            state = r.endState;\n        }\n        return { heuristicTokens: true };\n    }\n    guessStartState(lineNumber) {\n        let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n        const likelyRelevantLines = [];\n        let initialState = null;\n        for (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n            const newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n            // Ignore lines full of whitespace\n            if (newNonWhitespaceIndex === 0) {\n                continue;\n            }\n            if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n                likelyRelevantLines.push(this._textModel.getLineContent(i));\n                nonWhitespaceColumn = newNonWhitespaceIndex;\n                initialState = this.getStartState(i);\n                if (initialState) {\n                    break;\n                }\n            }\n        }\n        if (!initialState) {\n            initialState = this.tokenizationSupport.getInitialState();\n        }\n        likelyRelevantLines.reverse();\n        const languageId = this._textModel.getLanguageId();\n        let state = initialState;\n        for (const line of likelyRelevantLines) {\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);\n            state = r.endState;\n        }\n        return state;\n    }\n}\n/**\n * **Invariant:**\n * If the text model is retokenized from line 1 to {@link getFirstInvalidEndStateLineNumber}() - 1,\n * then the recomputed end state for line l will be equal to {@link getEndState}(l).\n */\nexport class TrackingTokenizationStateStore {\n    constructor(lineCount) {\n        this.lineCount = lineCount;\n        this._tokenizationStateStore = new TokenizationStateStore();\n        this._invalidEndStatesLineNumbers = new RangePriorityQueueImpl();\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(1, lineCount + 1));\n    }\n    getEndState(lineNumber) {\n        return this._tokenizationStateStore.getEndState(lineNumber);\n    }\n    /**\n     * @returns if the end state has changed.\n     */\n    setEndState(lineNumber, state) {\n        if (!state) {\n            throw new BugIndicatingError('Cannot set null/undefined state');\n        }\n        this._invalidEndStatesLineNumbers.delete(lineNumber);\n        const r = this._tokenizationStateStore.setEndState(lineNumber, state);\n        if (r && lineNumber < this.lineCount) {\n            // because the state changed, we cannot trust the next state anymore and have to invalidate it.\n            this._invalidEndStatesLineNumbers.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));\n        }\n        return r;\n    }\n    acceptChange(range, newLineCount) {\n        this.lineCount += newLineCount - range.length;\n        this._tokenizationStateStore.acceptChange(range, newLineCount);\n        this._invalidEndStatesLineNumbers.addRangeAndResize(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);\n    }\n    acceptChanges(changes) {\n        for (const c of changes) {\n            const [eolCount] = countEOL(c.text);\n            this.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n        }\n    }\n    invalidateEndStateRange(range) {\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive));\n    }\n    getFirstInvalidEndStateLineNumber() { return this._invalidEndStatesLineNumbers.min; }\n    getFirstInvalidEndStateLineNumberOrMax() {\n        return this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;\n    }\n    allStatesValid() { return this._invalidEndStatesLineNumbers.min === null; }\n    getStartState(lineNumber, initialState) {\n        if (lineNumber === 1) {\n            return initialState;\n        }\n        return this.getEndState(lineNumber - 1);\n    }\n    getFirstInvalidLine(initialState) {\n        const lineNumber = this.getFirstInvalidEndStateLineNumber();\n        if (lineNumber === null) {\n            return null;\n        }\n        const startState = this.getStartState(lineNumber, initialState);\n        if (!startState) {\n            throw new BugIndicatingError('Start state must be defined');\n        }\n        return { lineNumber, startState };\n    }\n}\nexport class TokenizationStateStore {\n    constructor() {\n        this._lineEndStates = new FixedArray(null);\n    }\n    getEndState(lineNumber) {\n        return this._lineEndStates.get(lineNumber);\n    }\n    setEndState(lineNumber, state) {\n        const oldState = this._lineEndStates.get(lineNumber);\n        if (oldState && oldState.equals(state)) {\n            return false;\n        }\n        this._lineEndStates.set(lineNumber, state);\n        return true;\n    }\n    acceptChange(range, newLineCount) {\n        let length = range.length;\n        if (newLineCount > 0 && length > 0) {\n            // Keep the last state, even though it is unrelated.\n            // But if the new state happens to agree with this last state, then we know we can stop tokenizing.\n            length--;\n            newLineCount--;\n        }\n        this._lineEndStates.replace(range.startLineNumber, length, newLineCount);\n    }\n}\nexport class RangePriorityQueueImpl {\n    constructor() {\n        this._ranges = [];\n    }\n    get min() {\n        if (this._ranges.length === 0) {\n            return null;\n        }\n        return this._ranges[0].start;\n    }\n    delete(value) {\n        const idx = this._ranges.findIndex(r => r.contains(value));\n        if (idx !== -1) {\n            const range = this._ranges[idx];\n            if (range.start === value) {\n                if (range.endExclusive === value + 1) {\n                    this._ranges.splice(idx, 1);\n                }\n                else {\n                    this._ranges[idx] = new OffsetRange(value + 1, range.endExclusive);\n                }\n            }\n            else {\n                if (range.endExclusive === value + 1) {\n                    this._ranges[idx] = new OffsetRange(range.start, value);\n                }\n                else {\n                    this._ranges.splice(idx, 1, new OffsetRange(range.start, value), new OffsetRange(value + 1, range.endExclusive));\n                }\n            }\n        }\n    }\n    addRange(range) {\n        OffsetRange.addRange(range, this._ranges);\n    }\n    addRangeAndResize(range, newLength) {\n        let idxFirstMightBeIntersecting = 0;\n        while (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {\n            idxFirstMightBeIntersecting++;\n        }\n        let idxFirstIsAfter = idxFirstMightBeIntersecting;\n        while (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {\n            idxFirstIsAfter++;\n        }\n        const delta = newLength - range.length;\n        for (let i = idxFirstIsAfter; i < this._ranges.length; i++) {\n            this._ranges[i] = this._ranges[i].delta(delta);\n        }\n        if (idxFirstMightBeIntersecting === idxFirstIsAfter) {\n            const newRange = new OffsetRange(range.start, range.start + newLength);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);\n            }\n        }\n        else {\n            const start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);\n            const endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);\n            const newRange = new OffsetRange(start, endEx + delta);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);\n            }\n            else {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);\n            }\n        }\n    }\n    toString() {\n        return this._ranges.map(r => r.toString()).join(' + ');\n    }\n}\nfunction safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {\n    let r = null;\n    if (tokenizationSupport) {\n        try {\n            r = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n    }\n    if (!r) {\n        r = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n    }\n    LineTokens.convertToEndOffset(r.tokens, text.length);\n    return r;\n}\nexport class DefaultBackgroundTokenizer {\n    constructor(_tokenizerWithStateStore, _backgroundTokenStore) {\n        this._tokenizerWithStateStore = _tokenizerWithStateStore;\n        this._backgroundTokenStore = _backgroundTokenStore;\n        this._isDisposed = false;\n        this._isScheduled = false;\n    }\n    dispose() {\n        this._isDisposed = true;\n    }\n    handleChanges() {\n        this._beginBackgroundTokenization();\n    }\n    _beginBackgroundTokenization() {\n        if (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n            return;\n        }\n        this._isScheduled = true;\n        runWhenGlobalIdle((deadline) => {\n            this._isScheduled = false;\n            this._backgroundTokenizeWithDeadline(deadline);\n        });\n    }\n    /**\n     * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n     */\n    _backgroundTokenizeWithDeadline(deadline) {\n        // Read the time remaining from the `deadline` immediately because it is unclear\n        // if the `deadline` object will be valid after execution leaves this function.\n        const endTime = Date.now() + deadline.timeRemaining();\n        const execute = () => {\n            if (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n                // disposed in the meantime or detached or finished\n                return;\n            }\n            this._backgroundTokenizeForAtLeast1ms();\n            if (Date.now() < endTime) {\n                // There is still time before reaching the deadline, so yield to the browser and then\n                // continue execution\n                setTimeout0(execute);\n            }\n            else {\n                // The deadline has been reached, so schedule a new idle callback if necessary\n                this._beginBackgroundTokenization();\n            }\n        };\n        execute();\n    }\n    /**\n     * Tokenize for at least 1ms.\n     */\n    _backgroundTokenizeForAtLeast1ms() {\n        const lineCount = this._tokenizerWithStateStore._textModel.getLineCount();\n        const builder = new ContiguousMultilineTokensBuilder();\n        const sw = StopWatch.create(false);\n        do {\n            if (sw.elapsed() > 1) {\n                // the comparison is intentionally > 1 and not >= 1 to ensure that\n                // a full millisecond has elapsed, given how microseconds are rounded\n                // to milliseconds\n                break;\n            }\n            const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n            if (tokenizedLineNumber >= lineCount) {\n                break;\n            }\n        } while (this._hasLinesToTokenize());\n        this._backgroundTokenStore.setTokens(builder.finalize());\n        this.checkFinished();\n    }\n    _hasLinesToTokenize() {\n        if (!this._tokenizerWithStateStore) {\n            return false;\n        }\n        return !this._tokenizerWithStateStore.store.allStatesValid();\n    }\n    _tokenizeOneInvalidLine(builder) {\n        const firstInvalidLine = this._tokenizerWithStateStore?.getFirstInvalidLine();\n        if (!firstInvalidLine) {\n            return this._tokenizerWithStateStore._textModel.getLineCount() + 1;\n        }\n        this._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);\n        return firstInvalidLine.lineNumber;\n    }\n    checkFinished() {\n        if (this._isDisposed) {\n            return;\n        }\n        if (this._tokenizerWithStateStore.store.allStatesValid()) {\n            this._backgroundTokenStore.backgroundTokenizationFinished();\n        }\n    }\n    requestTokens(startLineNumber, endLineNumberExclusive) {\n        this._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { LineRange } from '../core/lineRange.js';\n/**\n * @internal\n */\nexport class AttachedViews {\n    constructor() {\n        this._onDidChangeVisibleRanges = new Emitter();\n        this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event;\n        this._views = new Set();\n    }\n    attachView() {\n        const view = new AttachedViewImpl((state) => {\n            this._onDidChangeVisibleRanges.fire({ view, state });\n        });\n        this._views.add(view);\n        return view;\n    }\n    detachView(view) {\n        this._views.delete(view);\n        this._onDidChangeVisibleRanges.fire({ view, state: undefined });\n    }\n}\nclass AttachedViewImpl {\n    constructor(handleStateChange) {\n        this.handleStateChange = handleStateChange;\n    }\n    setVisibleLines(visibleLines, stabilized) {\n        const visibleLineRanges = visibleLines.map((line) => new LineRange(line.startLineNumber, line.endLineNumber + 1));\n        this.handleStateChange({ visibleLineRanges, stabilized });\n    }\n}\nexport class AttachedViewHandler extends Disposable {\n    get lineRanges() { return this._lineRanges; }\n    constructor(_refreshTokens) {\n        super();\n        this._refreshTokens = _refreshTokens;\n        this.runner = this._register(new RunOnceScheduler(() => this.update(), 50));\n        this._computedLineRanges = [];\n        this._lineRanges = [];\n    }\n    update() {\n        if (equals(this._computedLineRanges, this._lineRanges, (a, b) => a.equals(b))) {\n            return;\n        }\n        this._computedLineRanges = this._lineRanges;\n        this._refreshTokens();\n    }\n    handleStateChange(state) {\n        this._lineRanges = state.visibleLineRanges;\n        if (state.stabilized) {\n            this.runner.cancel();\n            this.update();\n        }\n        else {\n            this.runner.schedule();\n        }\n    }\n}\nexport class AbstractTokens extends Disposable {\n    get backgroundTokenizationState() {\n        return this._backgroundTokenizationState;\n    }\n    constructor(_languageIdCodec, _textModel, getLanguageId) {\n        super();\n        this._languageIdCodec = _languageIdCodec;\n        this._textModel = _textModel;\n        this.getLanguageId = getLanguageId;\n        this._backgroundTokenizationState = 1 /* BackgroundTokenizationState.InProgress */;\n        this._onDidChangeBackgroundTokenizationState = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n    }\n    tokenizeIfCheap(lineNumber) {\n        if (this.isCheapToTokenize(lineNumber)) {\n            this.forceTokenization(lineNumber);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TreeSitterTokenizationRegistry } from '../languages.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { AbstractTokens } from './tokens.js';\nexport class TreeSitterTokens extends AbstractTokens {\n    constructor(_treeSitterService, languageIdCodec, textModel, languageId) {\n        super(languageIdCodec, textModel, languageId);\n        this._treeSitterService = _treeSitterService;\n        this._tokenizationSupport = null;\n        this._initialize();\n    }\n    _initialize() {\n        const newLanguage = this.getLanguageId();\n        if (!this._tokenizationSupport || this._lastLanguageId !== newLanguage) {\n            this._lastLanguageId = newLanguage;\n            this._tokenizationSupport = TreeSitterTokenizationRegistry.get(newLanguage);\n        }\n    }\n    getLineTokens(lineNumber) {\n        const content = this._textModel.getLineContent(lineNumber);\n        if (this._tokenizationSupport) {\n            const rawTokens = this._tokenizationSupport.tokenizeEncoded(lineNumber, this._textModel);\n            if (rawTokens) {\n                return new LineTokens(rawTokens, content, this._languageIdCodec);\n            }\n        }\n        return LineTokens.createEmpty(content, this._languageIdCodec);\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        this._initialize();\n    }\n    handleDidChangeAttached() {\n        // TODO @alexr00 implement for background tokenization\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n    }\n    forceTokenization(lineNumber) {\n        // TODO @alexr00 implement\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        // TODO @alexr00 update for background tokenization\n        return true;\n    }\n    isCheapToTokenize(lineNumber) {\n        // TODO @alexr00 update for background tokenization\n        return true;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        // TODO @alexr00 implement once we have custom parsing and don't just feed in the whole text model value\n        return 0 /* StandardTokenType.Other */;\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        // TODO @alexr00 understand what this is for and implement\n        return null;\n    }\n    get hasTokens() {\n        // TODO @alexr00 once we have a token store, implement properly\n        const hasTree = this._treeSitterService.getParseResult(this._textModel) !== undefined;\n        return hasTree;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from './lineTokens.js';\nexport const EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\nexport class ContiguousTokensEditing {\n    static deleteBeginning(lineTokens, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        return ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);\n    }\n    static deleteEnding(lineTokens, fromChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const lineTextLength = tokens[tokens.length - 2];\n        return ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);\n    }\n    static delete(lineTokens, fromChIndex, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        // special case: deleting everything\n        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n            return EMPTY_LINE_TOKENS;\n        }\n        const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n        const fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n        const fromTokenEndOffset = tokens[fromTokenIndex << 1];\n        if (toChIndex < fromTokenEndOffset) {\n            // the delete range is inside a single token\n            const delta = (toChIndex - fromChIndex);\n            for (let i = fromTokenIndex; i < tokensCount; i++) {\n                tokens[i << 1] -= delta;\n            }\n            return lineTokens;\n        }\n        let dest;\n        let lastEnd;\n        if (fromTokenStartOffset !== fromChIndex) {\n            tokens[fromTokenIndex << 1] = fromChIndex;\n            dest = ((fromTokenIndex + 1) << 1);\n            lastEnd = fromChIndex;\n        }\n        else {\n            dest = (fromTokenIndex << 1);\n            lastEnd = fromTokenStartOffset;\n        }\n        const delta = (toChIndex - fromChIndex);\n        for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n            const tokenEndOffset = tokens[tokenIndex << 1] - delta;\n            if (tokenEndOffset > lastEnd) {\n                tokens[dest++] = tokenEndOffset;\n                tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n                lastEnd = tokenEndOffset;\n            }\n        }\n        if (dest === tokens.length) {\n            // nothing to trim\n            return lineTokens;\n        }\n        const tmp = new Uint32Array(dest);\n        tmp.set(tokens.subarray(0, dest), 0);\n        return tmp.buffer;\n    }\n    static append(lineTokens, _otherTokens) {\n        if (_otherTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        if (lineTokens === EMPTY_LINE_TOKENS) {\n            return _otherTokens;\n        }\n        if (lineTokens === null) {\n            return lineTokens;\n        }\n        if (_otherTokens === null) {\n            // cannot determine combined line length...\n            return null;\n        }\n        const myTokens = toUint32Array(lineTokens);\n        const otherTokens = toUint32Array(_otherTokens);\n        const otherTokensCount = (otherTokens.length >>> 1);\n        const result = new Uint32Array(myTokens.length + otherTokens.length);\n        result.set(myTokens, 0);\n        let dest = myTokens.length;\n        const delta = myTokens[myTokens.length - 2];\n        for (let i = 0; i < otherTokensCount; i++) {\n            result[dest++] = otherTokens[(i << 1)] + delta;\n            result[dest++] = otherTokens[(i << 1) + 1];\n        }\n        return result.buffer;\n    }\n    static insert(lineTokens, chIndex, textLength) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            // nothing to do\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n        if (fromTokenIndex > 0) {\n            const fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n            if (fromTokenStartOffset === chIndex) {\n                fromTokenIndex--;\n            }\n        }\n        for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n            tokens[tokenIndex << 1] += textLength;\n        }\n        return lineTokens;\n    }\n}\nexport function toUint32Array(arr) {\n    if (arr instanceof Uint32Array) {\n        return arr;\n    }\n    else {\n        return new Uint32Array(arr);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { ContiguousTokensEditing, EMPTY_LINE_TOKENS, toUint32Array } from './contiguousTokensEditing.js';\nimport { LineTokens } from './lineTokens.js';\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\n/**\n * Represents contiguous tokens in a text model.\n */\nexport class ContiguousTokensStore {\n    constructor(languageIdCodec) {\n        this._lineTokens = [];\n        this._len = 0;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._lineTokens = [];\n        this._len = 0;\n    }\n    get hasTokens() {\n        return this._lineTokens.length > 0;\n    }\n    getTokens(topLevelLanguageId, lineIndex, lineText) {\n        let rawLineTokens = null;\n        if (lineIndex < this._len) {\n            rawLineTokens = this._lineTokens[lineIndex];\n        }\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n            return new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);\n        }\n        const lineTokens = new Uint32Array(2);\n        lineTokens[0] = lineText.length;\n        lineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));\n        return new LineTokens(lineTokens, lineText, this._languageIdCodec);\n    }\n    static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\n        const tokens = _tokens ? toUint32Array(_tokens) : null;\n        if (lineTextLength === 0) {\n            let hasDifferentLanguageId = false;\n            if (tokens && tokens.length > 1) {\n                hasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n            }\n            if (!hasDifferentLanguageId) {\n                return EMPTY_LINE_TOKENS;\n            }\n        }\n        if (!tokens || tokens.length === 0) {\n            const tokens = new Uint32Array(2);\n            tokens[0] = lineTextLength;\n            tokens[1] = getDefaultMetadata(topLevelLanguageId);\n            return tokens.buffer;\n        }\n        // Ensure the last token covers the end of the text\n        tokens[tokens.length - 2] = lineTextLength;\n        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n            // Store directly the ArrayBuffer pointer to save an object\n            return tokens.buffer;\n        }\n        return tokens;\n    }\n    _ensureLine(lineIndex) {\n        while (lineIndex >= this._len) {\n            this._lineTokens[this._len] = null;\n            this._len++;\n        }\n    }\n    _deleteLines(start, deleteCount) {\n        if (deleteCount === 0) {\n            return;\n        }\n        if (start + deleteCount > this._len) {\n            deleteCount = this._len - start;\n        }\n        this._lineTokens.splice(start, deleteCount);\n        this._len -= deleteCount;\n    }\n    _insertLines(insertIndex, insertCount) {\n        if (insertCount === 0) {\n            return;\n        }\n        const lineTokens = [];\n        for (let i = 0; i < insertCount; i++) {\n            lineTokens[i] = null;\n        }\n        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n        this._len += insertCount;\n    }\n    setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\n        const tokens = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);\n        this._ensureLine(lineIndex);\n        const oldTokens = this._lineTokens[lineIndex];\n        this._lineTokens[lineIndex] = tokens;\n        if (checkEquality) {\n            return !ContiguousTokensStore._equals(oldTokens, tokens);\n        }\n        return false;\n    }\n    static _equals(_a, _b) {\n        if (!_a || !_b) {\n            return !_a && !_b;\n        }\n        const a = toUint32Array(_a);\n        const b = toUint32Array(_b);\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //#region Editing\n    acceptEdit(range, eolCount, firstLineLength) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n    }\n    _acceptDeleteRange(range) {\n        const firstLineIndex = range.startLineNumber - 1;\n        if (firstLineIndex >= this._len) {\n            return;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            this._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n            return;\n        }\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n        const lastLineIndex = range.endLineNumber - 1;\n        let lastLineTokens = null;\n        if (lastLineIndex < this._len) {\n            lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);\n        // Delete middle lines\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n    _acceptInsertText(position, eolCount, firstLineLength) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - 1;\n        if (lineIndex >= this._len) {\n            return;\n        }\n        if (eolCount === 0) {\n            // Inserting text on one line\n            this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n            return;\n        }\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n        this._insertLines(position.lineNumber, eolCount);\n    }\n    //#endregion\n    setMultilineTokens(tokens, textModel) {\n        if (tokens.length === 0) {\n            return { changes: [] };\n        }\n        const ranges = [];\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const element = tokens[i];\n            let minChangedLineNumber = 0;\n            let maxChangedLineNumber = 0;\n            let hasChange = false;\n            for (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {\n                if (hasChange) {\n                    this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);\n                    maxChangedLineNumber = lineNumber;\n                }\n                else {\n                    const lineHasChange = this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);\n                    if (lineHasChange) {\n                        hasChange = true;\n                        minChangedLineNumber = lineNumber;\n                        maxChangedLineNumber = lineNumber;\n                    }\n                }\n            }\n            if (hasChange) {\n                ranges.push({ fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber, });\n            }\n        }\n        return { changes: ranges };\n    }\n}\nfunction getDefaultMetadata(topLevelLanguageId) {\n    return ((topLevelLanguageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)\n        // If there is no grammar, we just take a guess and try to match brackets.\n        | (1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */)) >>> 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from './lineTokens.js';\n/**\n * Represents sparse tokens in a text model.\n */\nexport class SparseTokensStore {\n    constructor(languageIdCodec) {\n        this._pieces = [];\n        this._isComplete = false;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._pieces = [];\n        this._isComplete = false;\n    }\n    isEmpty() {\n        return (this._pieces.length === 0);\n    }\n    set(pieces, isComplete) {\n        this._pieces = pieces || [];\n        this._isComplete = isComplete;\n    }\n    setPartial(_range, pieces) {\n        // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n        let range = _range;\n        if (pieces.length > 0) {\n            const _firstRange = pieces[0].getRange();\n            const _lastRange = pieces[pieces.length - 1].getRange();\n            if (!_firstRange || !_lastRange) {\n                return _range;\n            }\n            range = _range.plusRange(_firstRange).plusRange(_lastRange);\n        }\n        let insertPosition = null;\n        for (let i = 0, len = this._pieces.length; i < len; i++) {\n            const piece = this._pieces[i];\n            if (piece.endLineNumber < range.startLineNumber) {\n                // this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // this piece is after the range, so mark the spot before this piece\n                // as a good insertion position and stop looping\n                insertPosition = insertPosition || { index: i };\n                break;\n            }\n            // this piece might intersect with the range\n            piece.removeTokens(range);\n            if (piece.isEmpty()) {\n                // remove the piece if it became empty\n                this._pieces.splice(i, 1);\n                i--;\n                len--;\n                continue;\n            }\n            if (piece.endLineNumber < range.startLineNumber) {\n                // after removal, this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // after removal, this piece is after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            // after removal, this piece contains the range\n            const [a, b] = piece.split(range);\n            if (a.isEmpty()) {\n                // this piece is actually after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            if (b.isEmpty()) {\n                // this piece is actually before the range\n                continue;\n            }\n            this._pieces.splice(i, 1, a, b);\n            i++;\n            len++;\n            insertPosition = insertPosition || { index: i };\n        }\n        insertPosition = insertPosition || { index: this._pieces.length };\n        if (pieces.length > 0) {\n            this._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n        }\n        // console.log(`I HAVE ${this._pieces.length} pieces`);\n        // console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n        return range;\n    }\n    isComplete() {\n        return this._isComplete;\n    }\n    addSparseTokens(lineNumber, aTokens) {\n        if (aTokens.getLineContent().length === 0) {\n            // Don't do anything for empty lines\n            return aTokens;\n        }\n        const pieces = this._pieces;\n        if (pieces.length === 0) {\n            return aTokens;\n        }\n        const pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);\n        const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n        if (!bTokens) {\n            return aTokens;\n        }\n        const aLen = aTokens.getCount();\n        const bLen = bTokens.getCount();\n        let aIndex = 0;\n        const result = [];\n        let resultLen = 0;\n        let lastEndOffset = 0;\n        const emitToken = (endOffset, metadata) => {\n            if (endOffset === lastEndOffset) {\n                return;\n            }\n            lastEndOffset = endOffset;\n            result[resultLen++] = endOffset;\n            result[resultLen++] = metadata;\n        };\n        for (let bIndex = 0; bIndex < bLen; bIndex++) {\n            const bStartCharacter = bTokens.getStartCharacter(bIndex);\n            const bEndCharacter = bTokens.getEndCharacter(bIndex);\n            const bMetadata = bTokens.getMetadata(bIndex);\n            const bMask = (((bMetadata & 1 /* MetadataConsts.SEMANTIC_USE_ITALIC */) ? 2048 /* MetadataConsts.ITALIC_MASK */ : 0)\n                | ((bMetadata & 2 /* MetadataConsts.SEMANTIC_USE_BOLD */) ? 4096 /* MetadataConsts.BOLD_MASK */ : 0)\n                | ((bMetadata & 4 /* MetadataConsts.SEMANTIC_USE_UNDERLINE */) ? 8192 /* MetadataConsts.UNDERLINE_MASK */ : 0)\n                | ((bMetadata & 8 /* MetadataConsts.SEMANTIC_USE_STRIKETHROUGH */) ? 16384 /* MetadataConsts.STRIKETHROUGH_MASK */ : 0)\n                | ((bMetadata & 16 /* MetadataConsts.SEMANTIC_USE_FOREGROUND */) ? 16744448 /* MetadataConsts.FOREGROUND_MASK */ : 0)\n                | ((bMetadata & 32 /* MetadataConsts.SEMANTIC_USE_BACKGROUND */) ? 4278190080 /* MetadataConsts.BACKGROUND_MASK */ : 0)) >>> 0;\n            const aMask = (~bMask) >>> 0;\n            // push any token from `a` that is before `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n                aIndex++;\n            }\n            // push the token from `a` if it intersects the token from `b`\n            if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n                emitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n            }\n            // skip any tokens from `a` that are contained inside `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                aIndex++;\n            }\n            if (aIndex < aLen) {\n                emitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                if (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n                    // `a` ends exactly at the same spot as `b`!\n                    aIndex++;\n                }\n            }\n            else {\n                const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n                // push the token from `b`\n                emitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\n            }\n        }\n        // push the remaining tokens from `a`\n        while (aIndex < aLen) {\n            emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n            aIndex++;\n        }\n        return new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);\n    }\n    static _findFirstPieceWithLine(pieces, lineNumber) {\n        let low = 0;\n        let high = pieces.length - 1;\n        while (low < high) {\n            let mid = low + Math.floor((high - low) / 2);\n            if (pieces[mid].endLineNumber < lineNumber) {\n                low = mid + 1;\n            }\n            else if (pieces[mid].startLineNumber > lineNumber) {\n                high = mid - 1;\n            }\n            else {\n                while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n                    mid--;\n                }\n                return mid;\n            }\n        }\n        return low;\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        for (const piece of this._pieces) {\n            piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Disposable } from '../../../base/common/lifecycle.js';\nexport class TextModelPart extends Disposable {\n    constructor() {\n        super(...arguments);\n        this._isDisposed = false;\n    }\n    dispose() {\n        super.dispose();\n        this._isDisposed = true;\n    }\n    assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('TextModelPart is disposed!');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Returns:\n *  - -1 => the line consists of whitespace\n *  - otherwise => the indent level is returned value\n */\nexport function computeIndentLevel(line, tabSize) {\n    let indent = 0;\n    let i = 0;\n    const len = line.length;\n    while (i < len) {\n        const chCode = line.charCodeAt(i);\n        if (chCode === 32 /* CharCode.Space */) {\n            indent++;\n        }\n        else if (chCode === 9 /* CharCode.Tab */) {\n            indent = indent - indent % tabSize + tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    if (i === len) {\n        return -1; // line only consists of whitespace\n    }\n    return indent;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar ModelService_1;\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport { TextModel } from '../model/textModel.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { ITextResourcePropertiesService } from './textResourceConfiguration.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nimport { StringSHA1 } from '../../../base/common/hash.js';\nimport { isEditStackElement } from '../model/editStack.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { equals } from '../../../base/common/objects.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nfunction MODEL_ID(resource) {\n    return resource.toString();\n}\nclass ModelData {\n    constructor(model, onWillDispose, onDidChangeLanguage) {\n        this.model = model;\n        this._modelEventListeners = new DisposableStore();\n        this.model = model;\n        this._modelEventListeners.add(model.onWillDispose(() => onWillDispose(model)));\n        this._modelEventListeners.add(model.onDidChangeLanguage((e) => onDidChangeLanguage(model, e)));\n    }\n    dispose() {\n        this._modelEventListeners.dispose();\n    }\n}\nconst DEFAULT_EOL = (platform.isLinux || platform.isMacintosh) ? 1 /* DefaultEndOfLine.LF */ : 2 /* DefaultEndOfLine.CRLF */;\nclass DisposedModelInfo {\n    constructor(uri, initialUndoRedoSnapshot, time, sharesUndoRedoStack, heapSize, sha1, versionId, alternativeVersionId) {\n        this.uri = uri;\n        this.initialUndoRedoSnapshot = initialUndoRedoSnapshot;\n        this.time = time;\n        this.sharesUndoRedoStack = sharesUndoRedoStack;\n        this.heapSize = heapSize;\n        this.sha1 = sha1;\n        this.versionId = versionId;\n        this.alternativeVersionId = alternativeVersionId;\n    }\n}\nlet ModelService = class ModelService extends Disposable {\n    static { ModelService_1 = this; }\n    static { this.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024; }\n    constructor(_configurationService, _resourcePropertiesService, _undoRedoService, _instantiationService) {\n        super();\n        this._configurationService = _configurationService;\n        this._resourcePropertiesService = _resourcePropertiesService;\n        this._undoRedoService = _undoRedoService;\n        this._instantiationService = _instantiationService;\n        this._onModelAdded = this._register(new Emitter());\n        this.onModelAdded = this._onModelAdded.event;\n        this._onModelRemoved = this._register(new Emitter());\n        this.onModelRemoved = this._onModelRemoved.event;\n        this._onModelModeChanged = this._register(new Emitter());\n        this.onModelLanguageChanged = this._onModelModeChanged.event;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        this._models = {};\n        this._disposedModels = new Map();\n        this._disposedModelsHeapSize = 0;\n        this._register(this._configurationService.onDidChangeConfiguration(e => this._updateModelOptions(e)));\n        this._updateModelOptions(undefined);\n    }\n    static _readModelOptions(config, isForSimpleWidget) {\n        let tabSize = EDITOR_MODEL_DEFAULTS.tabSize;\n        if (config.editor && typeof config.editor.tabSize !== 'undefined') {\n            const parsedTabSize = parseInt(config.editor.tabSize, 10);\n            if (!isNaN(parsedTabSize)) {\n                tabSize = parsedTabSize;\n            }\n            if (tabSize < 1) {\n                tabSize = 1;\n            }\n        }\n        let indentSize = 'tabSize';\n        if (config.editor && typeof config.editor.indentSize !== 'undefined' && config.editor.indentSize !== 'tabSize') {\n            const parsedIndentSize = parseInt(config.editor.indentSize, 10);\n            if (!isNaN(parsedIndentSize)) {\n                indentSize = Math.max(parsedIndentSize, 1);\n            }\n        }\n        let insertSpaces = EDITOR_MODEL_DEFAULTS.insertSpaces;\n        if (config.editor && typeof config.editor.insertSpaces !== 'undefined') {\n            insertSpaces = (config.editor.insertSpaces === 'false' ? false : Boolean(config.editor.insertSpaces));\n        }\n        let newDefaultEOL = DEFAULT_EOL;\n        const eol = config.eol;\n        if (eol === '\\r\\n') {\n            newDefaultEOL = 2 /* DefaultEndOfLine.CRLF */;\n        }\n        else if (eol === '\\n') {\n            newDefaultEOL = 1 /* DefaultEndOfLine.LF */;\n        }\n        let trimAutoWhitespace = EDITOR_MODEL_DEFAULTS.trimAutoWhitespace;\n        if (config.editor && typeof config.editor.trimAutoWhitespace !== 'undefined') {\n            trimAutoWhitespace = (config.editor.trimAutoWhitespace === 'false' ? false : Boolean(config.editor.trimAutoWhitespace));\n        }\n        let detectIndentation = EDITOR_MODEL_DEFAULTS.detectIndentation;\n        if (config.editor && typeof config.editor.detectIndentation !== 'undefined') {\n            detectIndentation = (config.editor.detectIndentation === 'false' ? false : Boolean(config.editor.detectIndentation));\n        }\n        let largeFileOptimizations = EDITOR_MODEL_DEFAULTS.largeFileOptimizations;\n        if (config.editor && typeof config.editor.largeFileOptimizations !== 'undefined') {\n            largeFileOptimizations = (config.editor.largeFileOptimizations === 'false' ? false : Boolean(config.editor.largeFileOptimizations));\n        }\n        let bracketPairColorizationOptions = EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions;\n        if (config.editor?.bracketPairColorization && typeof config.editor.bracketPairColorization === 'object') {\n            bracketPairColorizationOptions = {\n                enabled: !!config.editor.bracketPairColorization.enabled,\n                independentColorPoolPerBracketType: !!config.editor.bracketPairColorization.independentColorPoolPerBracketType\n            };\n        }\n        return {\n            isForSimpleWidget: isForSimpleWidget,\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            detectIndentation: detectIndentation,\n            defaultEOL: newDefaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            largeFileOptimizations: largeFileOptimizations,\n            bracketPairColorizationOptions\n        };\n    }\n    _getEOL(resource, language) {\n        if (resource) {\n            return this._resourcePropertiesService.getEOL(resource, language);\n        }\n        const eol = this._configurationService.getValue('files.eol', { overrideIdentifier: language });\n        if (eol && typeof eol === 'string' && eol !== 'auto') {\n            return eol;\n        }\n        return platform.OS === 3 /* platform.OperatingSystem.Linux */ || platform.OS === 2 /* platform.OperatingSystem.Macintosh */ ? '\\n' : '\\r\\n';\n    }\n    _shouldRestoreUndoStack() {\n        const result = this._configurationService.getValue('files.restoreUndoStack');\n        if (typeof result === 'boolean') {\n            return result;\n        }\n        return true;\n    }\n    getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget) {\n        const language = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        let creationOptions = this._modelCreationOptionsByLanguageAndResource[language + resource];\n        if (!creationOptions) {\n            const editor = this._configurationService.getValue('editor', { overrideIdentifier: language, resource });\n            const eol = this._getEOL(resource, language);\n            creationOptions = ModelService_1._readModelOptions({ editor, eol }, isForSimpleWidget);\n            this._modelCreationOptionsByLanguageAndResource[language + resource] = creationOptions;\n        }\n        return creationOptions;\n    }\n    _updateModelOptions(e) {\n        const oldOptionsByLanguageAndResource = this._modelCreationOptionsByLanguageAndResource;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        // Update options on all models\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            const modelData = this._models[modelId];\n            const language = modelData.model.getLanguageId();\n            const uri = modelData.model.uri;\n            if (e && !e.affectsConfiguration('editor', { overrideIdentifier: language, resource: uri }) && !e.affectsConfiguration('files.eol', { overrideIdentifier: language, resource: uri })) {\n                continue; // perf: skip if this model is not affected by configuration change\n            }\n            const oldOptions = oldOptionsByLanguageAndResource[language + uri];\n            const newOptions = this.getCreationOptions(language, uri, modelData.model.isForSimpleWidget);\n            ModelService_1._setModelOptionsForModel(modelData.model, newOptions, oldOptions);\n        }\n    }\n    static _setModelOptionsForModel(model, newOptions, currentOptions) {\n        if (currentOptions && currentOptions.defaultEOL !== newOptions.defaultEOL && model.getLineCount() === 1) {\n            model.setEOL(newOptions.defaultEOL === 1 /* DefaultEndOfLine.LF */ ? 0 /* EndOfLineSequence.LF */ : 1 /* EndOfLineSequence.CRLF */);\n        }\n        if (currentOptions\n            && (currentOptions.detectIndentation === newOptions.detectIndentation)\n            && (currentOptions.insertSpaces === newOptions.insertSpaces)\n            && (currentOptions.tabSize === newOptions.tabSize)\n            && (currentOptions.indentSize === newOptions.indentSize)\n            && (currentOptions.trimAutoWhitespace === newOptions.trimAutoWhitespace)\n            && equals(currentOptions.bracketPairColorizationOptions, newOptions.bracketPairColorizationOptions)) {\n            // Same indent opts, no need to touch the model\n            return;\n        }\n        if (newOptions.detectIndentation) {\n            model.detectIndentation(newOptions.insertSpaces, newOptions.tabSize);\n            model.updateOptions({\n                trimAutoWhitespace: newOptions.trimAutoWhitespace,\n                bracketColorizationOptions: newOptions.bracketPairColorizationOptions\n            });\n        }\n        else {\n            model.updateOptions({\n                insertSpaces: newOptions.insertSpaces,\n                tabSize: newOptions.tabSize,\n                indentSize: newOptions.indentSize,\n                trimAutoWhitespace: newOptions.trimAutoWhitespace,\n                bracketColorizationOptions: newOptions.bracketPairColorizationOptions\n            });\n        }\n    }\n    // --- begin IModelService\n    _insertDisposedModel(disposedModelData) {\n        this._disposedModels.set(MODEL_ID(disposedModelData.uri), disposedModelData);\n        this._disposedModelsHeapSize += disposedModelData.heapSize;\n    }\n    _removeDisposedModel(resource) {\n        const disposedModelData = this._disposedModels.get(MODEL_ID(resource));\n        if (disposedModelData) {\n            this._disposedModelsHeapSize -= disposedModelData.heapSize;\n        }\n        this._disposedModels.delete(MODEL_ID(resource));\n        return disposedModelData;\n    }\n    _ensureDisposedModelsHeapSize(maxModelsHeapSize) {\n        if (this._disposedModelsHeapSize > maxModelsHeapSize) {\n            // we must remove some old undo stack elements to free up some memory\n            const disposedModels = [];\n            this._disposedModels.forEach(entry => {\n                if (!entry.sharesUndoRedoStack) {\n                    disposedModels.push(entry);\n                }\n            });\n            disposedModels.sort((a, b) => a.time - b.time);\n            while (disposedModels.length > 0 && this._disposedModelsHeapSize > maxModelsHeapSize) {\n                const disposedModel = disposedModels.shift();\n                this._removeDisposedModel(disposedModel.uri);\n                if (disposedModel.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModel.initialUndoRedoSnapshot);\n                }\n            }\n        }\n    }\n    _createModelData(value, languageIdOrSelection, resource, isForSimpleWidget) {\n        // create & save the model\n        const options = this.getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget);\n        const model = this._instantiationService.createInstance(TextModel, value, languageIdOrSelection, options, resource);\n        if (resource && this._disposedModels.has(MODEL_ID(resource))) {\n            const disposedModelData = this._removeDisposedModel(resource);\n            const elements = this._undoRedoService.getElements(resource);\n            const sha1Computer = this._getSHA1Computer();\n            const sha1IsEqual = (sha1Computer.canComputeSHA1(model)\n                ? sha1Computer.computeSHA1(model) === disposedModelData.sha1\n                : false);\n            if (sha1IsEqual || disposedModelData.sharesUndoRedoStack) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                this._undoRedoService.setElementsValidFlag(resource, true, (element) => (isEditStackElement(element) && element.matchesResource(resource)));\n                if (sha1IsEqual) {\n                    model._overwriteVersionId(disposedModelData.versionId);\n                    model._overwriteAlternativeVersionId(disposedModelData.alternativeVersionId);\n                    model._overwriteInitialUndoRedoSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n            else {\n                if (disposedModelData.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n        }\n        const modelId = MODEL_ID(model.uri);\n        if (this._models[modelId]) {\n            // There already exists a model with this id => this is a programmer error\n            throw new Error('ModelService: Cannot add model because it already exists!');\n        }\n        const modelData = new ModelData(model, (model) => this._onWillDispose(model), (model, e) => this._onDidChangeLanguage(model, e));\n        this._models[modelId] = modelData;\n        return modelData;\n    }\n    createModel(value, languageSelection, resource, isForSimpleWidget = false) {\n        let modelData;\n        if (languageSelection) {\n            modelData = this._createModelData(value, languageSelection, resource, isForSimpleWidget);\n        }\n        else {\n            modelData = this._createModelData(value, PLAINTEXT_LANGUAGE_ID, resource, isForSimpleWidget);\n        }\n        this._onModelAdded.fire(modelData.model);\n        return modelData.model;\n    }\n    getModels() {\n        const ret = [];\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            ret.push(this._models[modelId].model);\n        }\n        return ret;\n    }\n    getModel(resource) {\n        const modelId = MODEL_ID(resource);\n        const modelData = this._models[modelId];\n        if (!modelData) {\n            return null;\n        }\n        return modelData.model;\n    }\n    // --- end IModelService\n    _schemaShouldMaintainUndoRedoElements(resource) {\n        return (resource.scheme === Schemas.file\n            || resource.scheme === Schemas.vscodeRemote\n            || resource.scheme === Schemas.vscodeUserData\n            || resource.scheme === Schemas.vscodeNotebookCell\n            || resource.scheme === 'fake-fs' // for tests\n        );\n    }\n    _onWillDispose(model) {\n        const modelId = MODEL_ID(model.uri);\n        const modelData = this._models[modelId];\n        const sharesUndoRedoStack = (this._undoRedoService.getUriComparisonKey(model.uri) !== model.uri.toString());\n        let maintainUndoRedoStack = false;\n        let heapSize = 0;\n        if (sharesUndoRedoStack || (this._shouldRestoreUndoStack() && this._schemaShouldMaintainUndoRedoElements(model.uri))) {\n            const elements = this._undoRedoService.getElements(model.uri);\n            if (elements.past.length > 0 || elements.future.length > 0) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n            }\n        }\n        const maxMemory = ModelService_1.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK;\n        const sha1Computer = this._getSHA1Computer();\n        if (!maintainUndoRedoStack) {\n            if (!sharesUndoRedoStack) {\n                const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n                if (initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n                }\n            }\n        }\n        else if (!sharesUndoRedoStack && (heapSize > maxMemory || !sha1Computer.canComputeSHA1(model))) {\n            // the undo stack for this file would never fit in the configured memory or the file is very large, so don't bother with it.\n            const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n            if (initialUndoRedoSnapshot !== null) {\n                this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n            }\n        }\n        else {\n            this._ensureDisposedModelsHeapSize(maxMemory - heapSize);\n            // We only invalidate the elements, but they remain in the undo-redo service.\n            this._undoRedoService.setElementsValidFlag(model.uri, false, (element) => (isEditStackElement(element) && element.matchesResource(model.uri)));\n            this._insertDisposedModel(new DisposedModelInfo(model.uri, modelData.model.getInitialUndoRedoSnapshot(), Date.now(), sharesUndoRedoStack, heapSize, sha1Computer.computeSHA1(model), model.getVersionId(), model.getAlternativeVersionId()));\n        }\n        delete this._models[modelId];\n        modelData.dispose();\n        // clean up cache\n        delete this._modelCreationOptionsByLanguageAndResource[model.getLanguageId() + model.uri];\n        this._onModelRemoved.fire(model);\n    }\n    _onDidChangeLanguage(model, e) {\n        const oldLanguageId = e.oldLanguage;\n        const newLanguageId = model.getLanguageId();\n        const oldOptions = this.getCreationOptions(oldLanguageId, model.uri, model.isForSimpleWidget);\n        const newOptions = this.getCreationOptions(newLanguageId, model.uri, model.isForSimpleWidget);\n        ModelService_1._setModelOptionsForModel(model, newOptions, oldOptions);\n        this._onModelModeChanged.fire({ model, oldLanguageId: oldLanguageId });\n    }\n    _getSHA1Computer() {\n        return new DefaultModelSHA1Computer();\n    }\n};\nModelService = ModelService_1 = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ITextResourcePropertiesService),\n    __param(2, IUndoRedoService),\n    __param(3, IInstantiationService)\n], ModelService);\nexport { ModelService };\nexport class DefaultModelSHA1Computer {\n    static { this.MAX_MODEL_SIZE = 10 * 1024 * 1024; } // takes 200ms to compute a sha1 on a 10MB model on a new machine\n    canComputeSHA1(model) {\n        return (model.getValueLength() <= DefaultModelSHA1Computer.MAX_MODEL_SIZE);\n    }\n    computeSHA1(model) {\n        // compute the sha1\n        const shaComputer = new StringSHA1();\n        const snapshot = model.createSnapshot();\n        let text;\n        while ((text = snapshot.read())) {\n            shaComputer.update(text);\n        }\n        return shaComputer.digest();\n    }\n}\n","import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ITextResourceConfigurationService = createDecorator('textResourceConfigurationService');\nexport const ITextResourcePropertiesService = createDecorator('textResourcePropertiesService');\n","import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ITreeSitterParserService = createDecorator('treeSitterParserService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * An event describing that a model has been reset to a new value.\n * @internal\n */\nexport class ModelRawFlush {\n    constructor() {\n        this.changeType = 1 /* RawContentChangedType.Flush */;\n    }\n}\n/**\n * Represents text injected on a line\n * @internal\n */\nexport class LineInjectedText {\n    static applyInjectedText(lineText, injectedTexts) {\n        if (!injectedTexts || injectedTexts.length === 0) {\n            return lineText;\n        }\n        let result = '';\n        let lastOriginalOffset = 0;\n        for (const injectedText of injectedTexts) {\n            result += lineText.substring(lastOriginalOffset, injectedText.column - 1);\n            lastOriginalOffset = injectedText.column - 1;\n            result += injectedText.options.content;\n        }\n        result += lineText.substring(lastOriginalOffset);\n        return result;\n    }\n    static fromDecorations(decorations) {\n        const result = [];\n        for (const decoration of decorations) {\n            if (decoration.options.before && decoration.options.before.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.startLineNumber, decoration.range.startColumn, decoration.options.before, 0));\n            }\n            if (decoration.options.after && decoration.options.after.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.endLineNumber, decoration.range.endColumn, decoration.options.after, 1));\n            }\n        }\n        result.sort((a, b) => {\n            if (a.lineNumber === b.lineNumber) {\n                if (a.column === b.column) {\n                    return a.order - b.order;\n                }\n                return a.column - b.column;\n            }\n            return a.lineNumber - b.lineNumber;\n        });\n        return result;\n    }\n    constructor(ownerId, lineNumber, column, options, order) {\n        this.ownerId = ownerId;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.options = options;\n        this.order = order;\n    }\n}\n/**\n * An event describing that a line has changed in a model.\n * @internal\n */\nexport class ModelRawLineChanged {\n    constructor(lineNumber, detail, injectedText) {\n        this.changeType = 2 /* RawContentChangedType.LineChanged */;\n        this.lineNumber = lineNumber;\n        this.detail = detail;\n        this.injectedText = injectedText;\n    }\n}\n/**\n * An event describing that line(s) have been deleted in a model.\n * @internal\n */\nexport class ModelRawLinesDeleted {\n    constructor(fromLineNumber, toLineNumber) {\n        this.changeType = 3 /* RawContentChangedType.LinesDeleted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\n/**\n * An event describing that line(s) have been inserted in a model.\n * @internal\n */\nexport class ModelRawLinesInserted {\n    constructor(fromLineNumber, toLineNumber, detail, injectedTexts) {\n        this.changeType = 4 /* RawContentChangedType.LinesInserted */;\n        this.injectedTexts = injectedTexts;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n        this.detail = detail;\n    }\n}\n/**\n * An event describing that a model has had its EOL changed.\n * @internal\n */\nexport class ModelRawEOLChanged {\n    constructor() {\n        this.changeType = 5 /* RawContentChangedType.EOLChanged */;\n    }\n}\n/**\n * An event describing a change in the text of a model.\n * @internal\n */\nexport class ModelRawContentChangedEvent {\n    constructor(changes, versionId, isUndoing, isRedoing) {\n        this.changes = changes;\n        this.versionId = versionId;\n        this.isUndoing = isUndoing;\n        this.isRedoing = isRedoing;\n        this.resultingSelection = null;\n    }\n    containsEvent(type) {\n        for (let i = 0, len = this.changes.length; i < len; i++) {\n            const change = this.changes[i];\n            if (change.changeType === type) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static merge(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        return new ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing);\n    }\n}\n/**\n * An event describing a change in injected text.\n * @internal\n */\nexport class ModelInjectedTextChangedEvent {\n    constructor(changes) {\n        this.changes = changes;\n    }\n}\n/**\n * @internal\n */\nexport class InternalModelContentChangeEvent {\n    constructor(rawContentChangedEvent, contentChangedEvent) {\n        this.rawContentChangedEvent = rawContentChangedEvent;\n        this.contentChangedEvent = contentChangedEvent;\n    }\n    merge(other) {\n        const rawContentChangedEvent = ModelRawContentChangedEvent.merge(this.rawContentChangedEvent, other.rawContentChangedEvent);\n        const contentChangedEvent = InternalModelContentChangeEvent._mergeChangeEvents(this.contentChangedEvent, other.contentChangedEvent);\n        return new InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent);\n    }\n    static _mergeChangeEvents(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const eol = b.eol;\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        const isFlush = (a.isFlush || b.isFlush);\n        const isEolChange = a.isEolChange && b.isEolChange; // both must be true to not confuse listeners who skip such edits\n        return {\n            changes: changes,\n            eol: eol,\n            isEolChange: isEolChange,\n            versionId: versionId,\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush,\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var HorizontalGuidesState;\n(function (HorizontalGuidesState) {\n    HorizontalGuidesState[HorizontalGuidesState[\"Disabled\"] = 0] = \"Disabled\";\n    HorizontalGuidesState[HorizontalGuidesState[\"EnabledForActive\"] = 1] = \"EnabledForActive\";\n    HorizontalGuidesState[HorizontalGuidesState[\"Enabled\"] = 2] = \"Enabled\";\n})(HorizontalGuidesState || (HorizontalGuidesState = {}));\nexport class IndentGuide {\n    constructor(visibleColumn, column, className, \n    /**\n     * If set, this indent guide is a horizontal guide (no vertical part).\n     * It starts at visibleColumn and continues until endColumn.\n    */\n    horizontalLine, \n    /**\n     * If set (!= -1), only show this guide for wrapped lines that don't contain this model column, but are after it.\n    */\n    forWrappedLinesAfterColumn, forWrappedLinesBeforeOrAtColumn) {\n        this.visibleColumn = visibleColumn;\n        this.column = column;\n        this.className = className;\n        this.horizontalLine = horizontalLine;\n        this.forWrappedLinesAfterColumn = forWrappedLinesAfterColumn;\n        this.forWrappedLinesBeforeOrAtColumn = forWrappedLinesBeforeOrAtColumn;\n        if ((visibleColumn !== -1) === (column !== -1)) {\n            throw new Error();\n        }\n    }\n}\nexport class IndentGuideHorizontalLine {\n    constructor(top, endColumn) {\n        this.top = top;\n        this.endColumn = endColumn;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nexport class LineTokens {\n    static { this.defaultTokenMetadata = ((0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0; }\n    static createEmpty(lineContent, decoder) {\n        const defaultMetadata = LineTokens.defaultTokenMetadata;\n        const tokens = new Uint32Array(2);\n        tokens[0] = lineContent.length;\n        tokens[1] = defaultMetadata;\n        return new LineTokens(tokens, lineContent, decoder);\n    }\n    static createFromTextAndMetadata(data, decoder) {\n        let offset = 0;\n        let fullText = '';\n        const tokens = new Array();\n        for (const { text, metadata } of data) {\n            tokens.push(offset + text.length, metadata);\n            offset += text.length;\n            fullText += text;\n        }\n        return new LineTokens(new Uint32Array(tokens), fullText, decoder);\n    }\n    constructor(tokens, text, decoder) {\n        this._lineTokensBrand = undefined;\n        this._tokens = tokens;\n        this._tokensCount = (this._tokens.length >>> 1);\n        this._text = text;\n        this.languageIdCodec = decoder;\n    }\n    equals(other) {\n        if (other instanceof LineTokens) {\n            return this.slicedEquals(other, 0, this._tokensCount);\n        }\n        return false;\n    }\n    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n        if (this._text !== other._text) {\n            return false;\n        }\n        if (this._tokensCount !== other._tokensCount) {\n            return false;\n        }\n        const from = (sliceFromTokenIndex << 1);\n        const to = from + (sliceTokenCount << 1);\n        for (let i = from; i < to; i++) {\n            if (this._tokens[i] !== other._tokens[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getLineContent() {\n        return this._text;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStartOffset(tokenIndex) {\n        if (tokenIndex > 0) {\n            return this._tokens[(tokenIndex - 1) << 1];\n        }\n        return 0;\n    }\n    getMetadata(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return metadata;\n    }\n    getLanguageId(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        const languageId = TokenMetadata.getLanguageId(metadata);\n        return this.languageIdCodec.decodeLanguageId(languageId);\n    }\n    getStandardTokenType(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getTokenType(metadata);\n    }\n    getForeground(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getForeground(metadata);\n    }\n    getClassName(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getClassNameFromMetadata(metadata);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getPresentationFromMetadata(metadata);\n    }\n    getEndOffset(tokenIndex) {\n        return this._tokens[tokenIndex << 1];\n    }\n    /**\n     * Find the token containing offset `offset`.\n     * @param offset The search offset\n     * @return The index of the token containing the offset.\n     */\n    findTokenIndexAtOffset(offset) {\n        return LineTokens.findIndexInTokensArray(this._tokens, offset);\n    }\n    inflate() {\n        return this;\n    }\n    sliceAndInflate(startOffset, endOffset, deltaOffset) {\n        return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n    }\n    static convertToEndOffset(tokens, lineTextLength) {\n        const tokenCount = (tokens.length >>> 1);\n        const lastTokenIndex = tokenCount - 1;\n        for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n        }\n        tokens[lastTokenIndex << 1] = lineTextLength;\n    }\n    static findIndexInTokensArray(tokens, desiredIndex) {\n        if (tokens.length <= 2) {\n            return 0;\n        }\n        let low = 0;\n        let high = (tokens.length >>> 1) - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const endOffset = tokens[(mid << 1)];\n            if (endOffset === desiredIndex) {\n                return mid + 1;\n            }\n            else if (endOffset < desiredIndex) {\n                low = mid + 1;\n            }\n            else if (endOffset > desiredIndex) {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    /**\n     * @pure\n     * @param insertTokens Must be sorted by offset.\n    */\n    withInserted(insertTokens) {\n        if (insertTokens.length === 0) {\n            return this;\n        }\n        let nextOriginalTokenIdx = 0;\n        let nextInsertTokenIdx = 0;\n        let text = '';\n        const newTokens = new Array();\n        let originalEndOffset = 0;\n        while (true) {\n            const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n            const nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n            if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n                // original token ends before next insert token\n                text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n                const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                newTokens.push(text.length, metadata);\n                nextOriginalTokenIdx++;\n                originalEndOffset = nextOriginalTokenEndOffset;\n            }\n            else if (nextInsertToken) {\n                if (nextInsertToken.offset > originalEndOffset) {\n                    // insert token is in the middle of the next token.\n                    text += this._text.substring(originalEndOffset, nextInsertToken.offset);\n                    const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                    newTokens.push(text.length, metadata);\n                    originalEndOffset = nextInsertToken.offset;\n                }\n                text += nextInsertToken.text;\n                newTokens.push(text.length, nextInsertToken.tokenMetadata);\n                nextInsertTokenIdx++;\n            }\n            else {\n                break;\n            }\n        }\n        return new LineTokens(new Uint32Array(newTokens), text, this.languageIdCodec);\n    }\n    getTokenText(tokenIndex) {\n        const startOffset = this.getStartOffset(tokenIndex);\n        const endOffset = this.getEndOffset(tokenIndex);\n        const text = this._text.substring(startOffset, endOffset);\n        return text;\n    }\n    forEach(callback) {\n        const tokenCount = this.getCount();\n        for (let tokenIndex = 0; tokenIndex < tokenCount; tokenIndex++) {\n            callback(tokenIndex);\n        }\n    }\n}\nclass SliceLineTokens {\n    constructor(source, startOffset, endOffset, deltaOffset) {\n        this._source = source;\n        this._startOffset = startOffset;\n        this._endOffset = endOffset;\n        this._deltaOffset = deltaOffset;\n        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n        this.languageIdCodec = source.languageIdCodec;\n        this._tokensCount = 0;\n        for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n            const tokenStartOffset = source.getStartOffset(i);\n            if (tokenStartOffset >= endOffset) {\n                break;\n            }\n            this._tokensCount++;\n        }\n    }\n    getMetadata(tokenIndex) {\n        return this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n    }\n    getLanguageId(tokenIndex) {\n        return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n    }\n    getLineContent() {\n        return this._source.getLineContent().substring(this._startOffset, this._endOffset);\n    }\n    equals(other) {\n        if (other instanceof SliceLineTokens) {\n            return (this._startOffset === other._startOffset\n                && this._endOffset === other._endOffset\n                && this._deltaOffset === other._deltaOffset\n                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));\n        }\n        return false;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._source.getStandardTokenType(this._firstTokenIndex + tokenIndex);\n    }\n    getForeground(tokenIndex) {\n        return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n    }\n    getEndOffset(tokenIndex) {\n        const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n    }\n    getClassName(tokenIndex) {\n        return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        return this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n    }\n    getTokenText(tokenIndex) {\n        const adjustedTokenIndex = this._firstTokenIndex + tokenIndex;\n        const tokenStartOffset = this._source.getStartOffset(adjustedTokenIndex);\n        const tokenEndOffset = this._source.getEndOffset(adjustedTokenIndex);\n        let text = this._source.getTokenText(adjustedTokenIndex);\n        if (tokenStartOffset < this._startOffset) {\n            text = text.substring(this._startOffset - tokenStartOffset);\n        }\n        if (tokenEndOffset > this._endOffset) {\n            text = text.substring(0, text.length - (tokenEndOffset - this._endOffset));\n        }\n        return text;\n    }\n    forEach(callback) {\n        for (let tokenIndex = 0; tokenIndex < this.getCount(); tokenIndex++) {\n            callback(tokenIndex);\n        }\n    }\n}\nexport function getStandardTokenTypeAtPosition(model, position) {\n    const lineNumber = position.lineNumber;\n    if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n        return undefined;\n    }\n    model.tokenization.forceTokenization(lineNumber);\n    const lineTokens = model.tokenization.getLineTokens(lineNumber);\n    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n    const tokenType = lineTokens.getStandardTokenType(tokenIndex);\n    return tokenType;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class SyncDescriptor {\n    constructor(ctor, staticArguments = [], supportsDelayedInstantiation = false) {\n        this.ctor = ctor;\n        this.staticArguments = staticArguments;\n        this.supportsDelayedInstantiation = supportsDelayedInstantiation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SyncDescriptor } from './descriptors.js';\nconst _registry = [];\nexport function registerSingleton(id, ctorOrDescriptor, supportsDelayedInstantiation) {\n    if (!(ctorOrDescriptor instanceof SyncDescriptor)) {\n        ctorOrDescriptor = new SyncDescriptor(ctorOrDescriptor, [], Boolean(supportsDelayedInstantiation));\n    }\n    _registry.push([id, ctorOrDescriptor]);\n}\nexport function getSingletonServiceDescriptors() {\n    return _registry;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IUndoRedoService = createDecorator('undoRedoService');\nexport class ResourceEditStackSnapshot {\n    constructor(resource, elements) {\n        this.resource = resource;\n        this.elements = elements;\n    }\n}\nexport class UndoRedoGroup {\n    static { this._ID = 0; }\n    constructor() {\n        this.id = UndoRedoGroup._ID++;\n        this.order = 1;\n    }\n    nextOrder() {\n        if (this.id === 0) {\n            return 0;\n        }\n        return this.order++;\n    }\n    static { this.None = new UndoRedoGroup(); }\n}\nexport class UndoRedoSource {\n    static { this._ID = 0; }\n    constructor() {\n        this.id = UndoRedoSource._ID++;\n        this.order = 1;\n    }\n    nextOrder() {\n        if (this.id === 0) {\n            return 0;\n        }\n        return this.order++;\n    }\n    static { this.None = new UndoRedoSource(); }\n}\n"],"names":["textDecoder","hasBuffer","Buffer","Uint8Array","VSBuffer","actual","buffer","TextDecoder","readUInt16LE","source","offset","writeUInt16LE","destination","value","readUInt32BE","writeUInt32BE","readUInt8","writeUInt8","CursorColumns","codePoint","visibleColumn","tabSize","lineContent","column","textLen","Math","text","iterator","result","lineContentLength","beforeVisibleColumn","beforeColumn","afterVisibleColumn","afterColumn","beforeDelta","afterDelta","indentSize","countEOL","eolCount","firstLineLength","lastLineStart","eol","i","len","chr","normalizeIndentation","str","insertSpaces","firstNonWhitespaceIndex","_normalizeIndentationFromWhitespace","spacesCnt","tabsCnt","_utf16LE_TextDecoder","_utf16BE_TextDecoder","_platformTextDecoder","getUTF16LE_TextDecoder","getPlatformTextDecoder","decodeUTF16LE","view","Uint16Array","compatDecodeUTF16LE","resultLen","charCode","String","StringBuilder","capacity","bufferString","remainingSpace","strLen","escapeNewLine","TextChange","oldPosition","oldText","newPosition","newText","b","dest","compressConsecutiveTextChanges","prevEdits","currEdits","compressor","TextChangeCompressor","prevIndex","currIndex","prevEdit","currEdit","mergePrev","mergeCurr","e1","e2","merged","prevDeltaOffset","currDeltaOffset","edit","preText","postText","edits","prev","curr","EDITOR_MODEL_DEFAULTS","TokenMetadata","metadata","className","fontStyle","colorMap","foreground","textDecoration","Boolean","ILanguageService","IndentAction","StandardAutoClosingPairConditional","Array","standardToken","context","tokenIndex","standardTokenType","fromCharCode","toCharCode","character","AutoClosingPairs","autoClosingPairs","pair","Map","appendEntry","target","key","CharacterPairSupport","config","el","docComment","forQuotes","BracketElectricCharacterSupport","richEditBrackets","bracket","close","lastChar","reversedBracketRegex","r","bracketText","textBeforeBracket","resetGlobalRegex","reg","IndentRulesSupport","indentationRules","ret","OnEnterSupport","opts","openRegExp","closeRegExp","autoIndent","previousLineText","beforeEnterText","afterEnterText","rule","obj","strings","def","RegExp","err","LanguageBracketsConfiguration","languageId","bracketPairs","filterValidBrackets","openingBracketInfos","closing","Set","OpeningBracketKind","closingBracketInfos","opening","openingColorized","ClosingBracketKind","open","p","k","v","options","brackets","BracketKindBase","openedBrackets","openingBrackets","openingColorizedBrackets","other","__param","paramIndex","decorator","LanguageConfigurationServiceChangeEvent","ILanguageConfigurationService","configurationService","languageService","LanguageConfigurationRegistry","languageConfigKeys","Object","customizedLanguageConfigKeys","e","globalConfigChanged","localConfigChanged","overrideLangName","keys","undefined","configuration","priority","computeConfig","registry","languageConfig","ResolvedLanguageConfiguration","customizedConfig","getCustomizedLanguageConfig","colorizedBracketPairs","validateBracketPairs","data","combineLanguageConfigurations","__decorate","decorators","desc","d","c","arguments","Reflect","getIndentationAtPosition","model","lineNumber","lineText","indentation","ComposedLanguageConfiguration","entry","LanguageConfigurationContribution","configs","order","a","LanguageConfigurationChangeEvent","entries","disposable","underlyingConfig","conf","commentRule","comments","blockStart","blockEnd","NullState","nullTokenize","state","nullTokenizeEncoded","tokens","Uint32Array","createScopedLineTokens","tokenCount","desiredLanguageId","lastTokenIndex","firstTokenIndex","ScopedLineTokens","firstCharOffset","lastCharOffset","actualLineContent","ignoreBracketsInToken","lastInput","lastOutput","RichEditBracket","index","forwardRegex","reversedRegex","arr","element","RichEditBrackets","_brackets","groupFuzzyBrackets","N","group","areOverlapping","aOpen","aClose","bOpen","bClose","mergeGroups","g1","g2","newG","oldG","j","g","currentOpen","currentClose","getRegexForBracketPair","currentIndex","pieces","collectSuperstrings","unique","lengthcmp","createBracketOrRegExp","getReversedRegexForBracketPair","toReversedString","getRegexForBrackets","getReversedRegexForBrackets","seen","prepareBracketForRegExp","insertWordBoundaries","regexStr","reverse","BracketsUtils","reversedText","m","matchOffset","matchLength","absoluteMatchOffset","startOffset","endOffset","reversedSubstr","reversedLineText","bracketRegex","substr","BaseAstNode","length","PairAstNode","openingBracket","child","closingBracket","idx","Error","missingOpeningBracketIds","openBracketIds","textModel","Number","ListAstNode","item1","item2","item3","immutable","missingBracketIds","Immutable23ListAstNode","TwoThreeListAstNode","ImmutableArrayListAstNode","listHeight","_missingOpeningBracketIds","childCount","lastChild","mutable","firstChild","lastLength","count","unopenedBrackets","minIndentation","childOffset","node","_item1","_item2","_item3","ArrayListAstNode","_children","children","item","emptyArray","ImmutableLeafAstNode","TextAstNode","_openedBracketIds","start","startLineNumber","endLineNumber","firstNonWsColumn","BracketAstNode","bracketInfo","bracketIds","InvalidBracketAstNode","closingBrackets","openedBracketIds","TextEditInfo","changes","range","newLength","BeforeEditPositionMapper","TextEditInfoCache","nextEdit","nextChangeOffset","oldOffsetObj","newOffset","offsetObj","nextEditEndOffsetInCur","nextEditEndOffsetInCurObj","nextEditEndOffsetBeforeInCurObj","lineDelta","previousColumnDelta","columnDelta","textLength","BracketTokens","denseKeyProvider","getId","map","openingTextId","escaped","regExpStr","openingBracketIds","closingText","info","LanguageAgnosticBracketTokens","getLanguageConfiguration","singleLanguageBracketTokens","combineTextEditInfos","textEditInfoFirst","textEditInfoSecond","s0ToS1Map","toLengthMapping","s1ToS2Map","curItem","pushEdit","lastResult","s0offset","s1ToS2","nextS0ToS1MapWithS1LengthOf","s1Length","remainingItem","LengthMapping","s0Length","s","s0EndOffset","s1","s0startOffset","modified","lengthBefore","lengthAfter","remainingLengthAfter","textEditInfos","lastOffset","textEditInfo","spaceLength","lengthDiff","startLineCount","startColumnCount","endLineCount","endColumnCount","toLength","lengthZero","lengthIsZero","lineCount","columnCount","lengthToObj","l","lengthGetLineCount","lengthGetColumnCountIfZeroLineCount","lengthAdd","l1","l2","sumLengths","items","lengthFn","lengthEquals","length1","length2","lengthDiffNonNegative","diff","lineCount1","lineCount2","colCount2","lengthLessThan","lengthLessThanEqual","lengthGreaterThanEqual","positionToLength","position","lengthsToRange","lengthStart","lengthEnd","colCount","lengthOfString","lines","concat23TreesOfSameHeight","createImmutableLists","heightDiff","node1","node2","concat","append","list","nodeToAppend","nodeToAppendOfCorrectHeight","curNode","parents","parent","prepend","nodeToPrependOfCorrectHeight","NodeReader","predicate","lastOrUndefined","curNodeOffset","nextChildIdx","getNextChildIdx","currentOffset","currentNode","curIdx","parseDocument","tokenizer","oldNode","parser","Parser","level","token","concat23Trees","readNode","height","first","second","maxCacheableLength","cachedNode","set","nextToken","emptyArr","SmallImmutableSet","additionalItems","cached","keyProvider","newItem","newItems","identityKeyProvider","DenseKeyProvider","existing","Token","kind","bracketId","astNode","TextBufferTokenizer","bracketTokens","NonPeekableTextBufferTokenizer","lineIdx","startLineIdx","startLineCharOffset","lengthHeuristic","lineTokens","peekedBracketToken","tokenMetadata","isOther","containsBracketType","regexp","match","FastTokenizer","curLineCount","lastLineBreakOffset","lastTokenEndOffset","lastTokenEndLine","smallTextTokens0Line","smallTextTokens1Line","curOffset","uriGetComparisonKey","resource","SingleModelEditStackData","beforeCursorState","alternativeVersionId","getModelEOL","beforeVersionId","afterVersionId","beforeEOL","afterEOL","afterCursorState","textChanges","selections","selection","selectionStartLineNumber","selectionStartColumn","positionLineNumber","positionColumn","necessarySize","change","changeCount","SingleModelEditStackElement","label","code","uri","MultiModelEditStackElement","editStackElement","editStackElements","isEditStackElement","EditStack","undoRedoService","lastElement","newElement","editOperations","cursorStateComputer","inverseEditOperations","op","GuidesTextModelPart","languageConfigurationService","lineIndex","minLineNumber","maxLineNumber","foldingRules","offSide","up_aboveContentLineIndex","up_aboveContentLineIndent","up_belowContentLineIndex","up_belowContentLineIndent","up_resolveIndents","indent","down_aboveContentLineIndex","down_aboveContentLineIndent","down_belowContentLineIndex","down_belowContentLineIndent","down_resolveIndents","goUp","goDown","initialIndent","distance","upLineNumber","downLineNumber","upLineIndentLevel","currentIndent","downLineIndentLevel","activePosition","activeBracketPairRange","bracketsContainingActivePosition","bp","includeSingleLinePairs","independentColorPoolPerBracketType","colorProvider","BracketPairGuidesClassNames","isActive","end","horizontalGuides","endVisibleColumn","startVisibleColumn","guideVisibleColumn","renderHorizontalEndLineAtTheBottom","visibleGuideStartLineNumber","visibleGuideEndLineNumber","guides","aboveContentLineIndex","aboveContentLineIndent","belowContentLineIndex","belowContentLineIndent","resultIndex","nestingLevel","nestingLevelOfEqualBracketType","TokenizationTextModelPart_1","TextModel_1","BracketInfo","isInvalid","BracketPairInfo","openingBracketRange","closingBracketRange","bracketPairNode","BracketPairWithMinIndentationInfo","minVisibleColumnIndentation","BracketPairsTree","wasUndefined","ranges","tokenChange","previousAst","onlyColorizedBrackets","cb","collectBrackets","nodeOffsetStart","nodeOffsetEnd","push","levelPerBracketType","parentPairIsIncomplete","whileLoop","colorize","levelPerBracket","childEndsAfterEnd","includeMinIndentation","startLength","endLength","CollectBracketPairsContext","collectBracketPairs","shouldContinue","openingBracketEnd","getFirstBracketAfter","getFirstBracketBefore","lengths","BracketPairsTextModelPart","object","store","_bracket","_position","maxDuration","closingBracketInfo","bracketPair","bracketsSupport","stripBracketSearchCanceled","createTimeBasedContinueBracketSearchPredicate","continueSearchPredicate","modeBrackets","currentLanguageId","searchStartOffset","tokenEndOffset","searchEndOffset","tokenStartOffset","currentModeBrackets","bestResult","foundBracket","foundBracketText","BracketSearchCanceled","prevTokenIndex","prevModeBrackets","isOpen","matched","totalCallCount","searchPrevMatchingBracketInRange","hitText","prevSearchInToken","searchInToken","searchNextMatchingBracketInRange","bracketConfig","tokenLanguageId","savedCounts","counts","resetCounts","tmp","searchInRange","startTime","Date","ColorizedBracketPairsDecorationProvider","ColorProvider","ownerId","filterOutValidation","onlyMinimapDecorations","theme","collector","colors","colorValues","color","SpacesDiffResult","guessIndentation","defaultTabSize","defaultInsertSpaces","linesCount","linesIndentedWithTabsCount","linesIndentedWithSpacesCount","previousLineIndentation","spacesDiffCount","currentLineLength","currentLineText","useCurrentLineText","currentLineHasContent","currentLineIndentation","currentLineSpacesCount","currentLineTabsCount","aLength","bLength","aCharCode","aSpacesCnt","aTabsCount","bSpacesCnt","bTabsCount","bCharCode","tabsDiff","spacesDiff","currentSpacesDiff","tabSizeScore","ALLOWED_TAB_SIZE_GUESSES","possibleTabSize","possibleTabSizeScore","getNodeColor","setNodeColor","getNodeIsVisited","setNodeIsVisited","getNodeIsForValidation","setNodeIsForValidation","getNodeIsInGlyphMargin","setNodeIsInGlyphMargin","_setNodeStickiness","stickiness","setCollapseOnReplaceEdit","IntervalNode","id","versionId","absoluteStart","absoluteEnd","cachedVersionId","SENTINEL","IntervalTree","filterOwnerId","onlyMarginDecorations","intervalSearch","T","intervalStart","intervalEnd","delta","nodeMaxEnd","nodeStart","nodeEnd","include","search","collectNodesFromOwner","collectNodesPostOrder","rbTreeInsert","rbTreeDelete","initialNode","forceMoveMarkers","nodesOfInterest","searchForEditing","noOverlapReplace","editDelta","recomputeMaxEnd","nodeAcceptEdit","nodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","commonLength","startDone","endDone","moveSemantics","adjustMarkerBeforeColumn","deltaColumn","insertingCnt","normalizeDelta","markerOffset","markerStickToPreviousCharacter","checkOffset","newNode","treeInsert","z","x","zAbsoluteStart","zAbsoluteEnd","aStart","aEnd","bStart","bEnd","cmp","recomputeMaxEndWalkToRoot","y","leftRotate","rightRotate","w","leftest","resetSentinel","yWasRed","computeMaxEnd","maxEnd","leftMaxEnd","rightMaxEnd","TreeNode","piece","righttest","calculateSize","calculateLF","tree","rbDelete","recomputeTreeMetadata","newSizeLeft","newLFLeft","lf_delta","updateTreeMetadata","fixInsert","lineFeedCntDelta","createUintArray","LineStarts","lineStarts","cr","lf","crlf","isBasicASCII","createLineStartsFast","readonly","rLength","Piece","bufferIndex","lineFeedCnt","StringBuffer","PieceTreeSnapshot","BOM","PieceTreeSearchCache","limit","nodePos","nodePosition","hasInvalidVal","newArr","PieceTreeBase","chunks","eolNormalized","lastNode","min","averageBufferSize","max","tempChunk","tempChunkLen","newEOL","leftLen","accumualtedValInCurrentIndex","lfCnt","originalOffset","out","lineStartOffset","startPosition","endPosition","linesLength","currentLine","danglingCR","pieceLength","pieceStartLine","pieceEndLine","pieceStartOffset","line","matchingNode","targetOffset","searcher","startColumn","startCursor","endCursor","searchData","captureMatches","limitResultCount","searchText","offsetInBuffer","startOffsetInBuffer","retStartColumn","retEndColumn","searchRange","lineBreakCnt","nextLineStartOffset","deltaOffset","wordSeparators","searchString","searchStringLen","lastMatchIndex","remainder","nodeStartOffset","insertPosInBuffer","nodesToDel","newRightPiece","headOfRight","newStart","tailOfLeft","previousPos","newPieces","tmpNode","cnt","startNode","endNode","startSplitPosInBuffer","endSplitPosInBuffer","next","secondNode","nPiece","low","high","mid","midStop","midStart","cursor","nodes","splitText","AverageBufferSize","endIndex","endColumn","endPos","newPiece","cache","prevAccumulatedValue","accumulatedValue","originalLineNumber","pos","lineCnt","realLineCnt","expectedLineStartIndex","originalLFCnt","originalEndOffset","newEndOffset","newLineFeedCnt","size_delta","originalStartOffset","newStartOffset","originalStartPos","originalEndPos","oldLength","oldLFCnt","hitCRLF","prevStartOffset","newEnd","oldLineFeedCnt","prevAccumualtedValue","val","nextLineOffset","nextNode","prevNewLength","prevNewLFCnt","callback","leftRet","prevNode","PieceTreeTextBuffer","containsRTL","containsUnusualLineTerminators","preserveBOM","lineEnding","eolOffsetCompensation","desiredEOL","actualEOL","fromLineNumber","toLineNumber","fromOffset","toOffset","rawOperations","recordTrimAutoWhitespace","computeUndoEdits","mightContainRTL","mightContainUnusualLineTerminators","mightContainNonBasicASCII","canReduceOperations","operations","validatedRange","textMightContainNonBasicASCII","validText","lastLineLength","strEOL","bufferEOL","expectedStrEOL","hasTouchingRanges","rangeEnd","nextRangeStart","reverseRanges","newTrimAutoWhitespaceCandidates","reverseRange","currentLineContent","reverseOperations","reverseRangeDeltaOffset","bufferText","reverseRangeOffset","contentChanges","trimAutoWhitespaceLineNumbers","prevContent","firstEditRange","lastEditRange","entireEditRange","lastEndLineNumber","lastEndColumn","operation","contentChangeRange","prevOpEndLineNumber","prevOpEndColumn","prevOp","resultRange","PieceTreeTextBufferFactory","_chunks","_bom","_cr","_lf","_crlf","_containsRTL","_containsUnusualLineTerminators","_isBasicASCII","_normalizeEOL","defaultEOL","totalEOLCount","totalCRCount","newLineStart","textBuffer","PieceTreeTextBufferBuilder","chunk","allowEmptyStrings","createLineStarts","normalizeEOL","lastChunk","newLineStarts","FixedArray","_default","before","after","insertArr","arrayFill","deleteIndex","deleteCount","insertIndex","insertCount","ContiguousMultilineTokens","ContiguousMultilineTokensBuilder","last","TokenizerWithStateStore","tokenizationSupport","TrackingTokenizationStateStore","TokenizerWithStateStoreAndTextModel","_textModel","_languageIdCodec","builder","lineToTokenize","safeTokenize","lineStartState","curLineContent","newLineContent","firstInvalidLineNumber","nonWhitespaceColumn","likelyRelevantLines","initialState","newNonWhitespaceIndex","TokenizationStateStore","RangePriorityQueueImpl","newLineCount","startState","oldState","idxFirstMightBeIntersecting","idxFirstIsAfter","newRange","endEx","languageIdCodec","hasEOL","DefaultBackgroundTokenizer","_tokenizerWithStateStore","_backgroundTokenStore","deadline","endTime","execute","sw","tokenizedLineNumber","firstInvalidLine","endLineNumberExclusive","AttachedViews","AttachedViewImpl","handleStateChange","visibleLines","stabilized","visibleLineRanges","AttachedViewHandler","_refreshTokens","AbstractTokens","getLanguageId","TreeSitterTokens","_treeSitterService","newLanguage","content","rawTokens","fireTokenChangeEvent","EMPTY_LINE_TOKENS","ContiguousTokensEditing","toChIndex","fromChIndex","toUint32Array","lineTextLength","lastEnd","tokensCount","fromTokenIndex","fromTokenStartOffset","_otherTokens","myTokens","otherTokens","otherTokensCount","chIndex","ContiguousTokensStore","topLevelLanguageId","rawLineTokens","getDefaultMetadata","_tokens","hasDifferentLanguageId","arrays","checkEquality","oldTokens","_a","_b","firstLineIndex","lastLineIndex","lastLineTokens","minChangedLineNumber","maxChangedLineNumber","hasChange","SparseTokensStore","isComplete","_range","_firstRange","_lastRange","insertPosition","aTokens","pieceIndex","bTokens","aLen","bLen","aIndex","lastEndOffset","emitToken","bIndex","bStartCharacter","bEndCharacter","bMetadata","bMask","aMask","aMergeIndex","firstCharCode","_bracketPairsTextModelPart","_languageId","_attachedViews","_languageService","_languageConfigurationService","GrammarTokens","useTreeSitter","needsReset","syntacticTokens","changedRange","rbStartOffset","rbEndOffset","rightBiasedWord","lbStartOffset","lbEndOffset","leftBiasedWord","wordAtPosition","attachedViews","initializeTokenization","firstInvalidEndStateLineNumber","_","heuristicTokens","changedTokens","backgroundResult","validatedPosition","createTextBuffer","factory","createTextBufferFactory","createTextBufferFactoryFromSnapshot","snapshot","MODEL_ID","TextModelSnapshot","resultCnt","resultLength","invalidFunc","guessedIndentation","listener","languageIdOrSelection","creationOptions","associatedResource","_undoRedoService","instantiationService","DidChangeDecorationsEmitter","affectedInjectedTextLines","DidChangeContentEmitter","bufferLineCount","bufferTextLength","DecorationsTrees","emptyDisposedTextBuffer","rawChange","rangeOffset","rangeLength","isUndoing","isRedoing","isFlush","isEolChange","textBufferDisposable","oldFullModelRange","oldModelValueLength","allDecorations","smallLineCharCount","longLineCharCount","lineLength","_newOpts","trimAutoWhitespace","bracketPairColorizationOptions","newOpts","matches","rawPosition","rawOffset","newAlternativeVersionId","newInitialUndoRedoSnapshot","fullModelRange","fullModelValue","rawRange","initialStartLineNumber","initialStartColumn","isNaN","maxColumn","initialEndLineNumber","initialEndColumn","validationType","charCodeBefore","_lineNumber","_column","charCodeBeforeStart","charCodeBeforeEnd","startInsideSurrogatePair","endInsideSurrogatePair","candidate","rawSearchScope","isRegex","matchCase","matchMapper","searchRanges","searchScope","d1","d2","uniqueSearchRanges","searchParams","rawSearchStart","searchStart","currentEOL","rawOperation","incomingEdits","editsAreNearCursors","sel","foundEditNearSel","lenJ","editRange","selIsAbove","selIsBelow","trimLineNumber","maxLineColumn","allowTrimLine","editText","trimRange","resultingAlternativeVersionId","resultingSelection","rangeStart","oldLineCount","rawContentChanges","deletingLinesCnt","editingLinesCnt","changeLineCountDelta","insertingLinesCnt","currentEditStartLineNumber","lastInsertedLineNumber","decorationsWithInjectedTextInEditedRange","injectedTextInEditedRange","injectedTextInEditedRangeQueue","editLineNumber","currentEditLineNumber","decorationsInCurrentLine","spliceStartLineNumber","spliceLineNumber","injectedTexts","newLines","lineChangeEvents","affectedLines","changeAccessor","_normalizeOptions","oldDecorations","newDecorations","console","newStickiness","TRACKED_RANGE_OPTIONS","decorationId","_startLineNumber","_endLineNumber","decorations","t","filterRange","oldRange","nodeWasInOverviewRuler","nodeIsInOverviewRuler","nodeRange","changedWhetherInjectedText","isOptionsInjectedText","isNodeInjectedText","movedInOverviewRuler","oldDecorationsIds","suppressEvents","oldDecorationsLen","oldDecorationIndex","newDecorationsLen","newDecorationIndex","internalDecorationId","newDecoration","affinity","indentOfLine","isNodeInOverviewRuler","host","r0","r1","r2","overviewRulerOnly","cleanClassName","DecorationOptions","ModelDecorationOverviewRulerOptions","ModelDecorationGlyphMarginOptions","ModelDecorationMinimapOptions","ModelDecorationInjectedTextOptions","ModelDecorationOptions","handleBeforeFire","event","TextModelPart","computeIndentLevel","chCode","ModelService_1","ModelData","onWillDispose","onDidChangeLanguage","DEFAULT_EOL","DisposedModelInfo","initialUndoRedoSnapshot","time","sharesUndoRedoStack","heapSize","sha1","ModelService","_configurationService","_resourcePropertiesService","_instantiationService","isForSimpleWidget","parsedTabSize","parseInt","parsedIndentSize","newDefaultEOL","detectIndentation","largeFileOptimizations","language","editor","oldOptionsByLanguageAndResource","modelId","modelData","oldOptions","newOptions","currentOptions","disposedModelData","maxModelsHeapSize","disposedModels","disposedModel","elements","sha1Computer","sha1IsEqual","languageSelection","maintainUndoRedoStack","maxMemory","oldLanguageId","newLanguageId","DefaultModelSHA1Computer","shaComputer","ITextResourceConfigurationService","ITextResourcePropertiesService","ITreeSitterParserService","ModelRawFlush","LineInjectedText","lastOriginalOffset","injectedText","decoration","ModelRawLineChanged","detail","ModelRawLinesDeleted","ModelRawLinesInserted","ModelRawEOLChanged","ModelRawContentChangedEvent","type","ModelInjectedTextChangedEvent","InternalModelContentChangeEvent","rawContentChangedEvent","contentChangedEvent","HorizontalGuidesState","IndentGuide","horizontalLine","forWrappedLinesAfterColumn","forWrappedLinesBeforeOrAtColumn","IndentGuideHorizontalLine","top","LineTokens","decoder","defaultMetadata","fullText","sliceFromTokenIndex","sliceTokenCount","from","to","SliceLineTokens","desiredIndex","insertTokens","nextOriginalTokenIdx","nextInsertTokenIdx","newTokens","nextOriginalTokenEndOffset","nextInsertToken","adjustedTokenIndex","getStandardTokenTypeAtPosition","SyncDescriptor","ctor","staticArguments","supportsDelayedInstantiation","_registry","registerSingleton","ctorOrDescriptor","getSingletonServiceDescriptors","IUndoRedoService","ResourceEditStackSnapshot","UndoRedoGroup","UndoRedoSource"],"mappings":"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"}